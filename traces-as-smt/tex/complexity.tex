\section{NP Completeness Proof} 
The complexity proof is inspired by the NP-completeness proof for
memory coherence and consistency by Cantin \emph{et al.} that uses a
similar reduction from SAT only in the context of shared memory
\cite{Cantin:2005:CVM:1070608.1070722}. The complexity proof is on a
new decision problem: \emph{Verifying Assertions in Message Passing}
(VAMP).
\begin{definition}
\textbf{Verifying Assertions in Message Passing}.
\begin{compactdesc}
\item{INSTANCE}: A set of constants $D$, a set of variables $X$, and a
  finite set $H$ of task histories consisting of send, receive, and
  assert operations over $X$ and $D$.
\item{QUESTION}: Is there a feasible schedule $S$ for the operations
  of $P$ that satisfies all the assertions?
\end{compactdesc}
\label{def:np1}
\end{definition}

The VAMP problem is NP-complete. The proof is a reduction from
SAT. Given an instance $Q$ of SAT consisting of a set of variables $U$
and set of clauses $C$ over $U$, an instance $V$ of VAMP is
constructed such that $Q$ has a feasible schedule $S$ that meets all
the assertions if and only if there is a satisfying truth assignment
for $Q$.

The reduction is illustrated in \figref{fig:vampi}. The figure elides
the explicit calls to wait which directly follow each send and receive
operation, and it elides the subscript notation as it is redundant in
the figure.

The reduction relies on non-determinism in the message passing to
decide the value of each variable in $U$.  The tasks $h_{d_0}$ and
$h_{d_1}$ repeatedly send the constant value $d_0$ (constant 0) or
$d_1$ (constant 1) to task $h_C$. The key intuition is that these
tasks are synchronized with $h_C$ so they essentially wait to send the
value until asked.

The task $h_C$ sequentially requests and receives $d_0$ and $d_1$
values for each variable in the SAT instance $Q$. It does not request
values for a new variable until the current variable is resolved. As
the values come from two separate tasks upon request, they messages
race in the runtime and may arrive in either order at $h_C$. As a
result, the value in each variable is non-deterministically $d_0$ or $d_1$

Once each variable has a
value, a special task collects the values in a canonical order and
asserts each clause in $C$.

\begin{figure}
\begin{center}
\setlength{\tabcolsep}{2pt}
\begin{tabular}[t]{|l|l|l|}
\hline
\multicolumn{3}{|l|}{\textbf{SAT:} $\mathit{U\equiv\{u_0,u_1,...,u_m\}}$}\\
              \multicolumn{3}{|l|}{$\mathit{C\equiv\{c_0,c_1,...,c_n\}}$}\\
              \multicolumn{3}{|l|}{$\mathit{Q\equiv\{c_0\wedge c_1\wedge ...\wedge c_n\}}$}\\
\hline
\multicolumn{3}{|l|}{\textbf{VAMPI:} $\mathit{H\equiv\{h_{d_0},h_{d_1},h_{C}\}}$}\\
                \multicolumn{3}{|l|}{$\mathit{X\equiv\{u_0,...,u_n,g_0,g_1\}}$}\\
                \multicolumn{3}{|l|}{$\mathit{D\equiv\{d_0,d_1\}}$}\\
\hline
$h_{d_0}$ & $h_{d_1}$ & $h_C$ \\
\hline
$R(g_{0},*)$   & $R(g_{1},*)$   & $S(d_0,h_{d_0})$ \\
$S(d_{0},h_C)$ & $S(d_{1},h_C)$ & $S(d_0,h_{d_1})$ \\
              &                & $R(u_0,*)$        \\
              &                & $R(u_0,*)$        \\
\hline
$R(g_{0},*)$  &  $R(g_{1},*)$   & $S(d_0,h_{d_0})$ \\
$S(d_{0},h_C)$&  $S(d_{1},h_C)$ & $S(d_0,h_{d_1})$ \\
              &                & $R(u_1,*)$       \\
              &                & $R(u_1,*)$       \\
\hline
$\ldots$      &  $\ldots$      & $\ldots$                \\
\hline
              &                & \textit{assert}($c_0$) \\
              &                & \textit{assert}($c_1$) \\
              &                & $\ldots$ \\
\hline
\end{tabular}
\end{center}
\caption{General SAT to VAMPI reduction}
\label{fig:vampi}
\end{figure}
