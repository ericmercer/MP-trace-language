% ---------------------------------------------------------------------
% Save boxes for the various figures in the example section
% ---------------------------------------------------------------------
\newsavebox{\boxTZero}
\begin{lrbox}{\boxTZero}
\begin{minipage}[t]{0.65\linewidth}
\begin{alltt}
00 initialize(NODE_0,&v,&s);
01 e0 = create_endpoint(PORT_0,&s);

02 msg_recv_i(e0,A,sizeof(A),&rcvA,&s);
03 wait(&rcvA,&size,&s,MCAPI_INF);
04 a = atoi(A);

05 msg_recv_i(e0,B,sizeof(B),&rcvB,&s);
06 wait(&rcvB,&size,&status,MCAPI_INF);
07 b = atoi(B);

08 if(b > 0);
09  assert(a == 4);

10 finalize(&s);
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxATZero}
\begin{lrbox}{\boxATZero}
\begin{minipage}[t]{0.65\linewidth}
\begin{alltt}
08 0_0         (0_0 (rcvi rcvA 0 a))
09 (0_1 (0 1)) (0_1 (wait rcvA))

10 0_2         (0_2 (rcvi rcvB 0 b))
11 (0_3 (0 2)) (0_3 (wait rcvB))

12 0_4         (0_4 (assume (> b 0)))
13 0_5         (0_5 (assert (= a 4)))
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxTOne}
\begin{lrbox}{\boxTOne}
\begin{minipage}[t]{0.65\linewidth}
\begin{alltt}
00 initialize(NODE_1,&v,&s);
01 e1 = create_endpoint(PORT_1,&s);
02 e0 = get_endpoint(NODE_0,PORT_0,&s);

03 msg_recv_i(e1,C,sizeof(C),&rcvC,&s);
04 wait(&rcvC,&size,&s,MCAPI_INF);

05 msg_send_i(e1,e0,"1",2,N,&snd3,&s);
06 wait(&snd3,&size,&s,MCAPI_INF);

07 finalize(&s);
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxATOne}
\begin{lrbox}{\boxATOne}
\begin{minipage}[t]{0.65\linewidth}
\begin{alltt}
04 1_0         (1_0 (rcvi rcvC 1 c))
05 (1_1 (1 2)) (1_1 (wait rcvC))

06 1_2         (1_2 (sndi snd3 1 0 0x1))
07 1_3         (1_3 (wait snd3))
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxTTwo}
\begin{lrbox}{\boxTTwo}
\begin{minipage}[t]{0.65\linewidth}
\begin{alltt}
00 initialize(NODE_2,&v,&s);
01 t2 = create_endpoint(PORT_2,&s);
02 t0 = get_endpoint(NODE_0,PORT_0,&s);
03 t1 = get_endpoint(NODE_1,PORT_1,&s);

04 msg_send_i(e2,e0,"4",2,N,&snd1,&s);
05 wait(&snd1,&size,&status,MCAPI_INF);

06 msg_send_i(e2,e1,"Go",3,N,&snd2,&s);
07 wait(&snd2,&size,&status,MCAPI_INF);

08 finalize(&s);
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxATTwo}
\begin{lrbox}{\boxATTwo}
\begin{minipage}[t]{0.65\linewidth}
\begin{alltt}
00 2_0        (2_0 (sndi snd1 2 0 0x4))
01 2_1        (2_1 (wait snd1))

02 2_2        (2_2 (sndi snd2 2 1 0x476f00))
03 2_3        (2_3 (wait snd2))
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxMP}
\begin{lrbox}{\boxMP}
\begin{minipage}[c]{0.2\linewidth}
\begin{alltt}
(rcvA snd1)
(rcvA snd3)

(rcvB snd1)
(rcvB snd3)

(rcvC snd2)
\end{alltt}
\end{minipage}
\end{lrbox}


\newsavebox{\boxSMT}
\begin{lrbox}{\boxSMT}
\begin{minipage}[c]{0.4\linewidth}
\begin{alltt}
(HB rcvA_loc wait_rcvA_loc)
(HB wait_rcvA_loc rcvB_loc)
(HB rcvB_loc wait_rcvB_loc)
(HB wait_rcvB_loc assume_loc)
(HB assume_loc assert_loc)
(HB rcvC_loc wait_rcvC_loc)
(HB wait_rcvC_loc snd3_loc)
(HB snd3_loc wait_snd3_loc)
(HB snd1_loc wait_snd1_loc)
(HB wait_snd1_loc snd2_loc)
(HB snd2_loc wait_snd2_loc)

(or (MATCH rcvA snd3)
    (MATCH rcvA snd1))
(or (MATCH rcvB  snd1)
    (MATCH rcvB snd3))
(NE rcvA rcvB)

(MATCH rcvC snd2)

(assert (> b 0))
(assert (not (= a 4)))
\end{alltt}
\end{minipage}
\end{lrbox}
% ---------------------------------------------------------------------
% END Save boxes
% ---------------------------------------------------------------------

\section{Example}

It is a challenge to explain intended behavior in simple scenarios
consisting of a handful of calls when dealing with concurrency. Consider
the MCAPI program in \figref{fig:mcapi} that includes three
tasks that use send (\texttt{mcapi\_msg\_send\_i}) and receive
(\texttt{mcapi\_msg\_recv\_i}) calls to communicate with each other.
Line numbers appear in the first column for each task, and the
declarations of the local variables are omitted for space. Picking up
the scenario just after the endpoints are defined, lines \texttt{02}
and \texttt{05} of task 0 receive two messages on the endpoint
\textit{e0} in variables $A$ and $B$ which are
converted to integer values and stored in variables $a$ and
$b$ on lines \texttt{04} and \texttt{07}; task 1 receives one
message on endpoint \textit{e1} in variable \textit{C} on line
\texttt{03} and then sends the message \textit{``1''} on line \texttt{05} to
\textit{e0}; and finally, task 2 sends messages \textit{``4''} and \textit{``Go''} on
lines \texttt{04} and \texttt{06} to endpoints \textit{e0} and
\textit{e1} respectively. Task 0 has additional code (lines \texttt{08} -
\texttt{10}) to assert properties of the values in $a$ and
$b$. The \texttt{mcapi\_wait} calls block until the associated
send or receive buffer is able to be used. Given the scenario, we
might ask the question: \emph{``What are the possible values of
\texttt{a} and \texttt{b} after the scenario completes?''}


\begin{figure*}
\begin{center}
\setlength{\tabcolsep}{2pt}
\begin{tabular}[t]{c|c|c}
Task 0 & Task 1 & Task 2 \\
\hline
\scalebox{0.5}{\usebox{\boxTZero}}&
\scalebox{0.5}{\usebox{\boxTOne}} &
\scalebox{0.5}{\usebox{\boxTTwo}}\\
%& & \\
%\hline
%\scalebox{0.5}{\usebox{\boxATZero}} &
%\scalebox{0.5}{\usebox{\boxATOne}}  &
%\scalebox{0.5}{\usebox{\boxATTwo}}
\end{tabular}
\end{center}
\caption{An MCAPI concurrent program}
\label{fig:mcapi}
\end{figure*}


The intuitive trace is presented in the first three columns of \figref{fig:trace}. Note that the fist column contains the task number in \figref{fig:mcapi}. The second column presents the commands with line number shown in \figref{fig:mcapi}. Also, we use the shorthand for each command of send, receive or wait in the third column. The variable \textit{a} should contain $4$ and variable
\textit{b} should contain $1$ since task 2 must first send message \textit{``4''}
to \textit{e0} before it can send message \textit{``Go''} to \textit{e1};
consequently, task 1 is then able to send message \textit{``1''} to
\textit{e0}. The assume notation refers to the if statement on line \texttt{08} of task 0 in \figref{fig:mcapi}, such that it is the ``check" that the program follows the same control flow.  At the end of execution the assertion on line \texttt{09}
of task 0 holds and no error is found. Such intuition is a valid
program execution. Consider another scenario in the fourth and fifth column of \figref{fig:trace}. Note that we use the shorthand for each command of send, receive and wait in the fifth column because of space limit. The variable \textit{a} contains $1$ instead of $4$, since the message \textit{``1''} is sent to \textit{e0} after sending the message \textit{``Go''} to \textit{e1}. The send on line \texttt{04} of task 2 may be delayed in transit. The specification indicates that the wait on line \texttt{05} of task 2 returns once the buffer is available. That only means the message is somewhere in the MCAPI runtime; it does not mean the message is delivered. As such, it is possible for the message to be delayed in transit allowing the send from task 1 on line \texttt{05} to arrive at \textit{e0} first and be received in variable \textit{``a''}. Such a scenario is a valid program execution that results in an assertion failure at line \texttt{09} in \figref{fig:mcapi}. From the discussion above, a single valid sequential execution is not sufficient to prove correctness because of concurrency as other valid traces may exist. The next section presents our method of SMT encoding that follow the same control flow path through an MCAPI program. The encoding can be solved by an SMT solver such that the non-deterministic behavior of the program can be resolved.

\begin{figure*}
\begin{center}
\setlength{\tabcolsep}{1pt}
\footnotesize \begin{tabular}[t]{|c|l|l||c|l|}
\hline
\multicolumn{3}{|c||}{Trace 1} & \multicolumn{2}{|c|}{Trace 2}\\
\hline
Task\  & Command\ & Shorthand\ & Task\ & Command\  \\
\hline
2 & 04 $\mathtt{msg\_send\_i(e2,e0,"4",2,N,\&snd1,\&s);}$ & $\mathtt{snd1}$ & 2 & 04 $\mathtt{snd1}$ \\
2 & 05 $\mathtt{wait(\&snd1,\&size,\&status,MCAPI\_INF);}$ & $\mathtt{wait\_snd1}$ & 2 & 05 $\mathtt{wait\_snd1}$ \\
2 & 06 $\mathtt{msg\_send\_i(e2,e1,"Go",3,N,\&snd2,\&s);}$ & $\mathtt{snd2}$ & 2 & 06 $\mathtt{snd2}$ \\
2 & 07 $\mathtt{wait(\&snd2,\&size,\&status,MCAPI\_INF);}$ & $\mathtt{wait\_snd2}$ & 2 & 07 $\mathtt{wait\_snd2}$ \\
0 & 02 $\mathtt{msg\_recv\_i(e0,A,sizeof(A),\&rcvA,\&s);}$ & $\mathtt{rcvA}$ & 1 & 03 $\mathtt{rcvC}$ \\
0 & 03 $\mathtt{wait(\&rcvA,\&size,\&s,MCAPI\_INF);}$ & $\mathtt{wait\_rcvA}$ & 1 & 04 $\mathtt{wait\_rcvC}$ \\
0 & 04 $\mathtt{a = atoi(A);}$ & & 1 & 05 $\mathtt{snd3}$ \\
1 & 03 $\mathtt{msg\_recv\_i(e1,C,sizeof(C),\&rcvC,\&s);}$ & $\mathtt{rcvC}$ & 1 & 06 $\mathtt{wait\_snd3}$ \\
1 & 04 $\mathtt{wait(\&rcvC,\&size,\&s,MCAPI\_INF);}$ & $\mathtt{wait\_rcvC}$ & 0 & 02 $\mathtt{rcvA}$ \\
1 & 05 $\mathtt{msg\_send\_i(e1,e0,"1",2,N,\&snd3,\&s);}$ & $\mathtt{snd3}$ & 0 & 03 $\mathtt{wait\_rcvA}$ \\
1 & 06 $\mathtt{wait(\&snd3,\&size,\&status,MCAPI\_INF);}$ & $\mathtt{wait\_snd3}$ & 0 & 04 $\mathtt{a = atoi(A);}$ \\
0 & 05 $\mathtt{msg\_recv\_i(e0,B,sizeof(B),\&rcvB,\&s);}$ & $\mathtt{rcvB}$ & 0 & 05 $\mathtt{rcvB}$ \\
0 & 06 $\mathtt{wait(\&rcvB,\&size,\&status,MCAPI\_INF);}$ & $\mathtt{wait\_rcvB}$ & 0 & 06 $\mathtt{wait\_rcvB}$ \\
0 & 07 $\mathtt{b = atoi(B);}$ & & 0 & 07 $\mathtt{b = atoi(B);}$ \\
0 & 08 $\mathtt{assume (b > 0);}$ & & 0 & 08 $\mathtt{assume (b > 0);}$ \\
0 & 09 $\mathtt{assert(a == 4);}$ & & 0 & 09 $\mathtt{assert(a == 4);}$ \\
\hline
\end{tabular}
\end{center}
\caption{Two execution traces of the MCAPI program in \figref{fig:mcapi}}
\label{fig:trace}
\end{figure*}

%The novelty of the SMT encoding in this paper is its use of match pairs rather than the state-based or order-based encoding of prior work~\cite{elwakil:padtad10,elwakil:atva10}. A match pair is the coupling of a receive to a particular send. \figref{fig:smt}(a) is the set of possible match pairs for the CTP in the bottom of \figref{fig:mcapi} for our running example. The set admits, for example, that \texttt{rcvA} can be matched with either \texttt{snd1} or \texttt{snd2}. The SMT encoding in this paper asks the SMT solver to resolve the match pairs for the system.


