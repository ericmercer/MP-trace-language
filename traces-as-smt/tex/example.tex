\section{Example}

It is a challenge to explain intended behavior in simple scenarios
consisting of a handful of calls when dealing with concurrency. Consider
the MCAPI program execution in \figref{fig:mcapi} that includes three
tasks that use send (\texttt{mcapi\_msg\_sen\\d\_i}) and receive
(\texttt{mcapi\_msg\_recv\_i}) calls to communicate with each other.
Line numbers appear in the first column for each task, and the
declarations of the local variables are omitted for space. Picking up
the scenario just after the endpoints are defined, lines \texttt{02}
and \texttt{05} of task 0 receive two messages on the endpoint
\textit{e0} in variables $A$ and $B$ which are
converted to integer values and stored in variables $a$ and
$b$ on lines \texttt{04} and \texttt{07}; task 1 receives one
message on endpoint \textit{e1} in variable \textit{C} on line
\texttt{03} and then sends the message \textit{``1''} on line \texttt{05} to
\textit{e0}; and finally, task 2 sends messages \textit{``4''} and \textit{``Go''} on
lines \texttt{04} and \texttt{06} to endpoints \textit{e0} and
\textit{e1} respectively. Task 0 has additional code (lines \texttt{08} -
\texttt{09}) to assert properties of the values in $a$ and
$b$. The \texttt{mcapi\_wait} calls block until the associated
send or receive buffer is able to be used. Given the scenario, we
might ask the question: \emph{``What are the possible values of
\texttt{a} and \texttt{b} after the scenario completes?''}

\begin{figure}[h]
\begin{center}
\setlength{\tabcolsep}{2pt}
\scriptsize \begin{tabular}[t]{l}
2 04 $\mathtt{S_{2,4}(0,\&h5)}$ \\
2 05 $\mathtt{W(\&h5)}$\\
\hline
0 02 $\mathtt{R_{0,2}(2,\&h1)}$ \\
0 03 $\mathtt{W(\&h1)}$ \\
\hline
2 06 $\mathtt{S_{2,6}(1,\&h6)}$ \\
2 07 $\mathtt{W(\&h6)}$ \\
\hline
0 04 $\mathtt{a = atoi(A);}$ \\
\hline
1 03 $\mathtt{R_{1,3}(2,\&h3)}$ \\
1 04 $\mathtt{W(\&h3)}$ \\
1 05 $\mathtt{S_{1,5}(0,\&h4)}$ \\
1 06 $\mathtt{W(\&h4)}$ \\
\hline
0 05 $\mathtt{R_{0,5}(1,\&h2)}$ \\
0 06 $\mathtt{W(\&h2)}$ \\
0 07 $\mathtt{b = atoi(B);}$ \\
0 08 $\mathtt{assume (b > 0);}$ \\
0 09 $\mathtt{assert(a == 4);}$ \\
\end{tabular}
\end{center}
\caption{XXX Two execution traces of the MCAPI program execution in \figref{fig:mcapi}}
\label{fig:trace1}
\end{figure}

The intuitive trace is presented in the first four columns
of \figref{fig:trace}. Note that the first column contains the line
number of each command shown in the trace. The second column contains
the task number in \figref{fig:mcapi}. The third column presents the
commands identified by the source line numbers shown
in \figref{fig:mcapi}. Also, we define a shorthand for each command of
send (denoted as $\mathtt{S}$), receive (denoted as $\mathtt{R}$), or
wait (denoted as $\mathtt{W}$) in the fourth column for presenting
future examples. For each command $\mathtt{O_{i,j}(k,\&h)}$,
$\mathtt{O \in \{S,R\}}$ or $\mathtt{W(\&h)}$, $\mathtt{i}$ represents
the task number, $\mathtt{j}$ represents the source line number,
$\mathtt{k}$ represents the destination endpoint, and $\mathtt{h}$
represents the command handler. Note that a specific destination task
number can be assigned to each receive for a provided program trace,
which implies the matched send in the program runtime. We use the ``*"
notation when a receive has yet to be matched to a specific send. From
the trace, variable \textit{a} should contain $4$ and variable
\textit{b} should contain $1$ since task 2 must first send message \textit{``4''}
to \textit{e0} before it can send message \textit{``Go''} to \textit{e1};
consequently, task 1 is then able to send message \textit{``1''} to
\textit{e0}. The assume notation asserts the control flow taken by the program execution. In this example, the program takes the true branch of the condition on line \texttt{08} of task 0.  At the end of execution the assertion on line \texttt{09}
of task 0 holds and no error is found.

For our example in \figref{fig:mcapi}, if we use zero-buffer
semantics, the send call on line \texttt{05} of task 1 cannot match
with the receive call on line \texttt{02} of task 0. This is because
the send call on line \texttt{04} of task 2 must be completed before
the send call on line \texttt{06} of task 2 can match with the receive
call on line \texttt{03} of task 1. 

\begin{figure}[h]
\begin{center}
\setlength{\tabcolsep}{2pt}
\scriptsize \begin{tabular}[t]{l}
2 04 $\mathtt{S_{2,4}(0,\&h5)}$ \\
2 05 $\mathtt{W(\&h5)}$ \\
2 06 $\mathtt{S_{2,6}(1,\&h6)}$ \\
2 07 $\mathtt{W(\&h6)}$ \\
\hline
1 03 $\mathtt{R_{1,3}(2,\&h3)}$ \\
1 04 $\mathtt{W(\&h3)}$ \\
1 05 $\mathtt{S_{1,5}(0,\&h4)}$ \\
1 06 $\mathtt{W(\&h4)}$ \\
\hline
0 02 $\mathtt{R_{0,2}(1,\&h1)}$ \\
0 03 $\mathtt{W(\&h1)}$ \\
0 04 $\mathtt{a = atoi(A);}$ \\
0 05 $\mathtt{R_{0,5}(2,\&h2)}$\\
0 06 $\mathtt{W(\&h2)}$ \\
0 07 $\mathtt{b = atoi(B);}$ \\
0 08 $\mathtt{assume (b > 0);}$ \\
0 09 $\mathtt{assert(a == 4);}$ \\
\hline
\end{tabular}
\end{center}
\caption{XXX Two execution traces of the MCAPI program execution in \figref{fig:mcapi}}
\label{fig:trace2}
\end{figure}

When using infinite-buffer semantics, however, we can have another
scenario shown in the fifth and sixth column of \figref{fig:trace}
written in the shorthand notation. The variable \textit{a} contains
$1$ instead of $4$, since the message \textit{``1''} is sent
to \textit{e0} after sending the message \textit{``Go''}
to \textit{e1} as it is possible for the send on line \texttt{04} of
task 2 to be buffered in transit. The specification indicates that the
wait on line \texttt{05} of task 2 returns once the buffer is
available. That only means the message is somewhere in the MCAPI
runtime under infinite-buffer semantics; it does not mean the message
is delivered. As such, it is possible for the message to be buffered
in transit allowing the send from task 1 on line \texttt{05} to arrive
at \textit{e0} first and be received in variable \textit{``a''}. Such
a scenario is a program execution that results in an assertion failure
at line \texttt{09} in \figref{fig:mcapi}.

From the discussion above, it is important to consider non-determinism in the MCAPI runtime when testing or debugging an MCAPI program execution. Note that we use infinite-buffer for the program execution in the rest of our discussion. The next section presents an encoding algorithm that takes an MCAPI program execution with a set of possible send-receive match pairs and generates an SMT problem that if satisfied proves that non-determinism can be resolved in a way that violates a user provided assertion and if unsatisfiable proves the trace correct (meaning the user assertions hold on the given execution). The encoding can be solved by an SMT solver such as Yices \cite{dutertre:CAV06} or Z3 \cite{demoura:tacas08}, and the non-deterministic behaviors of the program execution can be resolved.

%The novelty of the SMT encoding in this paper is its use of match pairs rather than the state-based or order-based encoding of prior work~\cite{elwakil:padtad10,elwakil:atva10}. A match pair is the coupling of a receive to a particular send. \figref{fig:smt}(a) is the set of possible match pairs for the CTP in the bottom of \figref{fig:mcapi} for our running example. The set admits, for example, that \texttt{rcvA} can be matched with either \texttt{snd1} or \texttt{snd2}. The SMT encoding in this paper asks the SMT solver to resolve the match pairs for the system.


