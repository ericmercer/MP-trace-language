\section{Introduction}
Embedded devices fill all sorts of crucial roles in our lives. They exist as
medical devices, as network infrastructure, and they control our automobiles.
Embedded devices continue to become more powerful as computing hardware becomes
smaller and more modular. It is now becoming commonplace to find multiple
processing units inside a single device. The Multicore Association (MCA) is an
industry group that has formed to define specifications for low-level
communication, resource management, and task management for
multicore devices.

One specification that the MCA has released is the Multicore Association
Communications API (MCAPI). The specification defines basic data type, data
structures, and functions that can be used to perform simple message passing
operation between different computing entities within a device. Messages can be
passed across persistent channels that force an ordering of the messages, or
they can be passed to specific \emph{endpoints} within the system. The specification places few ordering constrains on messages passed from one
endpoint to another. This freedom introduces into the system possibilities for
non-deterministic behavior in the way the messages arrive at their destination. 

This non-deterministic behavior in MCAPI programs is difficult for current tools to test or debug. 
Chao Wang provided a description of a verification method for
multithreaded software that uses shared memory as a means of synchronization \cite{wang:fse09}.
Sharma et al. created a method of using concrete execution to verify MCAPI
programs, but it was later discovered that this method does not completely
explore the entire execution space of certain kinds of MCAPI programs \cite{sharma:fmcad09}. Elwakil
et al. also defined a method of representing MCAPI program executions as
satisfiability problems, but this method does not correctly model all kinds of
MCAPI program executions \cite{elwakil:padtad10}.

Either the existing technique can not correctly encodes the program, or they can not provide efficient method for testing or debugging.
Due to the difficulty and defect described above, we provide and present a method in this paper that creates a light weight encoding for an MCAPI program. In other words, the encoding itself provides efficiency. Most importantly, this method guarantees of finding all hidden errors by encoding all possible execution traces of a concurrent program into an SMT problem.

We define a trace language - a framework for match pair encoding in Section 3 that
takes as input an execution of an MCAPI program and verifies it, according to
provided correctness properties. Output is given in the form of a path of
execution to an error state, or as a declaration of correctness for the
provided trace. Given the output form of the process, we can model a single execution trace of an MCAPI program as a satisfiability problem in the same framework of our trace language in Section 4. By scheduling different executions for the same concurrent program, we know that it is the match pairs of the send and receive operations that
introduce non-determinism into the program. By combining several satisfiability problems for an identical program, we can model all possible execution traces into one satisfiability problem such that the size of the problem scales linearly based on the number of possible match pairs that are being modeled. Negated
system properties are integrated in the satisfiability problem in such a manner
that if a satisfiable assignment is discovered for the problem, then the
assignment can be used to simply create an error trace that indicates how the
program could reach an error state in the program under test. Our method provides correct and efficient encoding for modeling an MCAPI program. The experimental result is provided by comparing the encoding itself with the work in \cite{elwakil:padtad10} in Section 5. Finally, we describe how to determine an over-approximated set of match pairs and how this verification technique is used within a
refinement loop to provide a more efficient means of verifying MCAPI
applications in Section 6.  


%As an example we present an abstract of a small program that uses MCAPI in
%\figref{fig:mcapi}. Each node represents a different thread. The
%$\mathit{Send}$ function call parameters include a unique identifier, the
%source endpoint, the destination endpoint, and the message contents,
%respectively. The $\mathit{Recv}$ function call parameters include a unique
%identifier, the endpoint that will receive the message, and a buffer in which
%the contents of the message will be placed. We see that the first call to
%$\mathit{Send}$ in Node 2 sends the contents of $Y$ from \emph{ep3} to
%\emph{ep1}. This message can be received into $A$ by the first call to
%$\mathit{Recv}$ in Node 0. If this were to occur we would call this a
%\emph{match pair} of $\mathit{send1}$ and $\mathit{recvA}$.

%If this abstract program is examined carefully it will be observed that
%messages received by $\mathit{recvA}$ and $\mathit{recvB}$ will be determined
%non-deterministically. One possible execution of the program would have the
%messages sent from $\mathit{send1}$ and $\mathit{send2}$. $\mathit{recvC}$
%would receive the message from $\mathit{send2}$ and then the message from
%$\mathit{send3}$ would be sent. Then $\mathit{recvA}$ could receive the message
%from $\mathit{send1}$, and $\mathit{recvB}$ could receive the message from
%$\mathit{send3}$.

%Another possible execution would have the message from $\mathit{send1}$ being
%sent but then delayed in the communications layer. This would allow
%$\mathit{send2}$ to send its message to $\mathit{recvC}$ which would then allow
%$\mathit{send3}$ to be paired with $\mathit{recvA}$. The message that was
%originally sent from $\mathit{send1}$ might then be unblocked and be received
%by $\mathit{recvB}$.

%It is important to recognize that the thread schedules of these two executions
%are exactly the same, even though the resulting behavior is completely
%different.



%We model our satisfiability problem based on the match pairs of the send and receive operations. This method creates light-weighted encoding for MCAPI programs. In other words, it provides efficient solutions. Most importantly, this method guarantees of finding and verifying all possible execution traces through a concurrent program.


Our main contributions in this paper include:

\begin{enumerate}
\item An MCAPI program that introduces non-deterministic behavior.
\item A trace language framework that simulates and verifies an execution trace of an MCAPI program.
\item A modified trace language framework that generates an SMT problem for a single trace in the machine executions.
\item A combination function that combines several SMT problems for an identical concurrent program into one SMT encoding that provides a larger answer set.
\item An algorithm with low complexity that generates an over-approximated set of match pair.  
\end{enumerate}

%\noindent\textbf{We have 10 pages for the paper!}

%Problem statement (one paragraph)

%Create an SMT problem from a set of possible send-receive match pairs
%such that if the SMT problem can be satisfied, then the assignment is
%a violating execution.

%Input: CTP + match pairs (probably cannot use CTP and match pair--be
%more abstract) Output: Error or noError

%Why would anyone care about answering such a question? (Fusion in one
%paragraph) Enables the creation of property specific partial order
%reduction that helps scale verification technology (like model
%checking) to larger systems--better counteracts state explosion.
%Critical assumption is that SMT technology is better managing state
%explosion than model checking.  Directly Related work (one paragraph)

%Elwakil etc.
%Our Solution

%Accomplished in a refinement loop using SMT technology (refinement
%loop figure): CTP + Match Pairs --> SMT --> Error --> Validated -->
%(report or refine) Contributions:

%Efficient encoding of a CTP with match pairs as an SMT problem (scales
%linearly with the match pair set rather than quadratically)--whether
%or not the encoding size matters is debatable...we believe that
%smaller is always better (fewer terms to deal with).  Refinement loop
%for iterative verification (with supporting theorem) Precise algorithm
%for computing precise match pair sets
