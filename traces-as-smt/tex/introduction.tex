\section{Introduction}
Embedded devices fill all sorts of crucial roles in our lives. They exist as
medical devices, as network infrastructure, and they control our automobiles.
Embedded devices continue to become more powerful as computing hardware becomes
smaller and more modular. It is now becoming commonplace to find multiple
processing units inside a single device. The Multicore Association (MCA) \cite{mca} is an
industry group that has formed to define specifications for low-level
communication, resource management, and task management for
multicore devices.

One specification that the MCA has released is the Multicore Association
Communications API (MCAPI) \cite{mcapi}. The specification defines basic data type, data
structures, and functions that can be used to perform simple message passing
operations between different computing entities within a device. Messages can be
passed across persistent channels that force an ordering of the messages, or
they can be passed to specific \emph{endpoints} within the system. The specification places few ordering constraints on messages passed from one
endpoint to another. This freedom introduces into the system possibilities that two or more message are racing if the order of their arrival at the destinations are non-deterministic \cite{netzer:spdt96}. Without a way to explore this non-determinism in the MCAPI runtime, it is not possible to test and debug the programs.

Sharma et al. created a method of using concrete execution to verify MCAPI
programs, but it was later discovered that this method does not completely
explore the entire execution space of certain kinds of MCAPI programs \cite{sharma:fmcad09}. The method provides match pairs -- couplings for potential sends and receives that we use in our work. Instead of exploring all relevant interleavings of an MCAPI program in the concrete execution in \cite{sharma:fmcad09}, Wang et al. provided a symbolic algorithm that verifies each partitioned concurrent trace program with shared memory semantics (CTP) using a satisfiability solver \cite{wang:fse09}. Elwakil et al. also defined a method of representing MCAPI program executions as satisfiability problems building on the method of \cite{wang:fse09} adapting it to message passing, but this method does not correctly model all kinds of MCAPI program executions \cite{elwakil:padtad10}. A shortcoming of this method is the assumption that the user is able to provide the exact set of match pairs. Such an assumption is not reasonable for large complex program traces. In this paper, however, we assume a user provides a possible set of match pairs as input to an MCAPI program. As such, the existing technique either faces the state explosion problem \cite{sharma:fmcad09}, or provides incorrect encoding that does not capture the true program behavior in an MCAPI runtime \cite{elwakil:padtad10}.

 %we provide and present a method in this paper that creates a light weight encoding for an MCAPI program.
We present an encoding for MCAPI program executions that uses match pairs from \cite{sharma:fmcad09} in a new Satisfiability Modulo Theory (SMT) encoding that requires fewer terms than \cite{elwakil:padtad10} but includes all possible program executions unlike \cite{elwakil:padtad10}. In other words, the solution for our encoding provides efficiency. Most importantly, this method correctly captures all possible execution traces allowed by the MCAPI specification in a trace of a concurrent program as an SMT problem enabling the exploration of inherent non-determinism that may exist in any MCAPI runtime implementation.
Our main contributions in this paper include:

\begin{enumerate}
%\item An MCAPI program that introduces non-deterministic behavior.
%\item A trace language framework that simulates and verifies an execution trace of an MCAPI program.
%\item A modified trace language framework that generates an SMT problem for a single trace in the machine executions.
\item A correct and efficient SMT encoding of an MCAPI program execution; and
\item  An $O(n^2)$ algorithm to generate an over-approximation of possible match-pairs.
\end{enumerate}

The rest of the paper is organized as follows:
Section 2 presents an MCAPI program in which two program traces exist due to non-determinism in the MCAPI runtime. Section 3 defines an SMT encoding for an MCAPI program execution that captures non-determinism in message order by defining the set of possible match pairs between sends and receives on a common endpoint. Section 4 solves the outstanding problem in other encodings of generating feasible match-pairs to use in the encoding. It presents a $O(n^2)$ algorithm that over-approximates the true match set. It then uses our encoding in a framework that provides a $\mathit{CEGAR}$\footnote{The \textit{CEGAR} loop is defined as a \textbf{C}ounter \textbf{E}xample \textbf{G}uided \textbf{A}bstraction \textbf{R}efinement.} loop to prune infeasible match pairs from the initial set until we witness a true error or conclude no error is possible. Section 5 presents the experimental results that show our encoding to be correct and efficient, as other existing encodings both omit critical program behaviors and require more SMT clauses. Section 6 discusses related
work, and Section 7  presents our conclusions and future work.


