

\section{ Over-approximated Match Pairs Generation}


The exact set of match pairs can be generated by simulating program execution and using a depth-first search to enumerate non-determinism arising from concurrent sends and receives. Such an effort, however, solves the very problem we are trying to solve because if you simulate the entire program exploring all non-determinism, then you can also verify all program executions for property violations. In this section, we present an algorithm that does not require an exhaustive enumeration of program behavior in simulation. Our algorithm over-approximates the set of match pair, such that match pairs that can exist in the real execution are all included, and some bogus match pairs that can not exist in the execution may or may not be included. %With this set of match pairs, our solution provides a $\mathrm{CEGAR}$ loop to solve the SMT encoding for the MCAPI program we are trying to solve. If there is not any bogus match pair in the generated set of match pairs, our solution can capture the true behavior of the system. If there is some bogus match pairs, our solution returns an error trace for the SMT problem. To test if the error is in real execution or not, our solution provides an ``oracle'' that takes this trace as input and simulates it. If the ``oracle'' can simulate the trace, we stop the $\mathrm{CEGAR}$ loop and guarantee of finding an error. If it is impossible for the ``oracle'' to simulate the trace, we prune the bogus match pairs founded by the ``oracle'', generate a new SMT problem with a new set of match pairs, and repeat the $\mathrm{CEGAR}$ loop.
 %We then input this over-approximated set of match pair to a CEGAR loop for further verification. Either error is found during one iteration and the process stops, or the current set of match pair is prune to a more precise one for the next iteration.

Other than simulating all possible executions of the program, the algorithm that generates the over-approximated match pairs is basically a strategy of matching each pair of the send and receive commands with common endpoint and pruning some bogus matches that can not exist in the real executions. First, we linearly traverse each task of the program, for example, the program in \figref{fig:mcapi}, and store each receive and send command to two lists as (\ref{equation:rcv}) and (\ref{equation:snd}), respectively. This step takes $O(N)$ to complete, where $N$ is the number of commands in the program. Second, we linearly traverse the list of receives in (\ref{equation:rcv}) and the sublist in (\ref{equation:snd}), and then apply the criteria below to each send command and receive command, for example, $\mathtt{snd1}$ and $\mathtt{rcvA}$ in \figref{fig:mcapi}. If all rules of the criteria are satisfied for $\mathtt{snd1}$ and $\mathtt{rcvA}$, we build a match pair $(\mathtt{snd1},\mathtt{rcvA})$ in the result set. Otherwise, we repeat the step without building a match pair for $\mathtt{snds}$ and $\mathtt{rcvA}$. This step takes $O(N^2)$ to complete since each pair of a send and a receive should be determined by the criteria. Once step 2 is completed, we build a set of match pairs, where all match pairs that can exist in the program runtime are included, and those can not exist in the real execution may or may not be included. Totally, the algorithm takes $O(N + N^2) \approx O(N^2)$ to complete. In our running example in \figref{fig:mcapi}, however, the match pairs we generated is precise, indicating that any match pair in the set can exist in the program runtime. Consider the following scenario that an imprecise set of match pairs is generated. 
\[
\begin{array}{ccc}
\mathtt{Task 0} &  \mathtt{Task 1} & \mathtt{Task 2}\\
\mathtt{rcvA} & \mathtt{snd1} & \mathtt{snd3} \\
\mathtt{rcvB} & \mathtt{rcvD} &  \\
\mathtt{snd4} & \mathtt{snd2} & \\
\mathtt{rcvC} & &
\end{array}
\] 
Omitted are the definitions of $\mathtt{snd1}$, $\mathtt{rcvA}$, etc., and the shorthand is used for describing our problem. The sends $\mathtt{snd1}$ ,$\mathtt{snd2}$ and $\mathtt{snd3}$ have Task 0 as an identical destination endpoint. The send $\mathtt{snd4}$ has Task 1 as the destination endpoint. By applying our algorithm to generate the match pairs for this program, the match pair $(\mathtt{snd3}\ \mathtt{rcvC})$ is built in the final set. However, it is a ``bogus" match pair since it can not exist in the real execution of program. If we add this match pair, however, there is no way to order $\mathtt{snd2}$ happening before $\mathtt{rcvB}$ since $\mathtt{rcvD}$ should be matched with $\mathtt{snd4}$ which is ``blocked" by $\mathtt{rcvB}$.

As discussed in the algorithm, we use two lists to keep record of the send and receive commands.

\begin{equation}
\footnotesize \begin{array}{l}
(e_0\ \rightarrow\ ((0,\ rcv_{00}),\ (1,\ rcv_{01}),\ \ldots))\\
(e_1\ \rightarrow\ ((0,\ rcv_{10}),\ (1,\ rcv_{11}),\ \ldots))\\
\ldots \\
(e_n\ \rightarrow\ ((0,\ rcv_{n0}),\ (1,\ rcv_{n1}),\ \ldots))\\
\end{array}
\label{equation:rcv}
\end{equation}

The list in (\ref{equation:rcv}) keeps record of the receive commands uniquely identified by the endpoint $\mathit{e}_x$, where $x$ is the number of the endpoint. The integer in the first field of each pair represents the index of the receive command for each endpoint. We use $I_r$ to denote the index. Note that the receive command with smaller $I_r$ should be served first in the program runtime. The receive command $rcv_{xx}$ in the second field of the list is defined as a record $R$ in equation \ref{equation:record} of the previous section. The number $xx$ represents the command number.

\begin{equation}
\footnotesize \begin{array}{l}
 ``dst" \;\;\;\; ``src" \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; ``src"\\
(e_0\ \rightarrow\ ((e_1\ \rightarrow\ ((0,\ snd_{100}),\ (1,\ snd_{101}),\ \ldots),\ (e_2\ \rightarrow\ (\ldots),\ \ldots))))\\
(e_1\ \rightarrow\ ((e_0\ \rightarrow\ ((0,\ snd_{010}),\ (1,\ snd_{011}),\ \ldots),\ (e_2\ \rightarrow\ (\ldots),\ \ldots))))\\
 \dots\\
(e_n\ \rightarrow\ ((e_0\ \rightarrow\ ((0,\ snd_{0n0}),\ (1,\ snd_{0n1}),\ \ldots),\ (e_1\ \rightarrow\ (\ldots),\ \ldots))))\\
\end{array}
\label{equation:snd}
\end{equation}

Also, we keep record of the send commands using the second list in (\ref{equation:snd}) that is uniquely identified by the destination endpoint $\mathit{e}_x$. Each sublist for the destination endpoint is uniquely identified by the source endpoint $\mathit{e}_y$. The integers $x$ and $y$ in the endpoints represent the number of the destination and source endpoints, respectively. The strings ``dst'' and ``src'' indicate the endpoint is either a destination or a source, respectively. Similarly, the integer in the first field of each pair represents the index of the send command. We use $I_s$ to denote the index. Note that $I_s$ is ordered within each sublist. The send command $snd_{xxx}$ in the second field of the list is defined as a record $S$ in equation \ref{equation:record} of the previous section. The number $xxx$ represents the command number.

Observe that the sends defined with an identical destination endpoint and an identical source endpoint are processed in a FIFO way in the program runtime. Also, the receive ordered first should be served first compared with those from an identical endpoint. Because of the fact of FIFO processing, a list of receives in (\ref{equation:rcv}) and a sublist of sends in (\ref{equation:snd}) with an identical endpoint can be determined how many matches there are from the sends to the receives by applying the following criteria:

For each receive command $\mathtt{rcv}$ in the list of (\ref{equation:rcv}) with index $I_r$ and each send command $\mathtt{snd}$ in the sublist of (\ref{equation:snd}) with index $I_s$, if $\mathtt{rcv}$ is matched with $\mathtt{snd}$, we have,
\begin{itemize}
\item[1.] the destination endpoint of $\mathtt{snd}$ is identical to the endpoint of $\mathtt{rcv}$;
\item[2.] $I_r \geq I_s$;
\item[3.] and $I_r \leq I_s + (N_s - n_s)$.
\end{itemize}
where $N_s$ is the number of the sends in the program, and $n_s$ is the number of the sends in the sublist where $\mathtt{snd}$ is resident.

We apply the criteria to our algorithm discussed above in such a way that each ``bogus" match pair should be pruned if at least one of the rules is not satisfied. By setting the over-approximated set of match pairs as input to our solution, we then validate satisfying assignments from the SMT solver to see if they use only feasible match pairs. Such validation is accomplished by creating an ``oracle" - a model of the MCAPI library with full operational semantics. The model is able to detect bad match pairs in a given program trace. The operational semantics of the model are presented in the long version of paperwork at (url??????????). The bad match pairs can be omitted from the SMT encoding and the SMT solver re-run to see if another solution exists. The framework provides a \textit{CEGAR} loop for MCAPI trace verification.
