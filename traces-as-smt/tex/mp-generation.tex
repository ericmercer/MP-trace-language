
\newsavebox{\boxalgorithm}
\begin{lrbox}{\boxalgorithm}
\begin{minipage}[c]{1.4\linewidth}
\begin{alltt}
// initialization
input an MCAPI program
initialize list_r
initialize list_s

// check each receive and send with the same endpoint
for r in list_r
  for s in list_s
    let dest = destination endpoint(s)
    let src = source endpoint(s)
    // check matching criteria for r and s
    if
      1. endpoint(r) = dest
      2. index(r) >= index(s)
      3. index(r) =< (index(s) 
                     + count(sends(dest=dest))
                     - count(sends(src=src, dest=dest)))
    then
      add pair (r, s) to match_set
    else
      continue
    end if
  end for
end for

output match_set;
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxtaskzero}
\begin{lrbox}{\boxtaskzero}
\begin{minipage}[t]{0.2\linewidth}
\begin{alltt}
rcvA
rcvB
snd4(1)
rcvC
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxtaskone}
\begin{lrbox}{\boxtaskone}
\begin{minipage}[t]{0.2\linewidth}
\begin{alltt}
snd1(0)
rcvD
snd2(0)
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxtasktwo}
\begin{lrbox}{\boxtasktwo}
\begin{minipage}[t]{0.2\linewidth}
\begin{alltt}
snd3(0)
\end{alltt}
\end{minipage}
\end{lrbox}

\section{Generating Match Pairs} \label{sec:mp-gen}

The exact set of match pairs can be generated by simulating the
program trace and using a depth-first search to enumerate
non-determinism arising from concurrent sends and receives. Such an
effort, however, solves the entire problem at once because if you
simulate the program trace exploring all non-determinism, then you may
as well verify all runtime choices for property violations at the same
time. 

In this section, we present an algorithm that does not require
an exhaustive enumeration of runtime behavior in simulation. Our
algorithm over-approximates the match pairs such that match pairs that
can exist in the runtime are all included and some ``bogus" match
pairs that cannot exist in the runtime may or may not be included.

%With this set of match pairs, our solution provides a $\mathrm{CEGAR}$ loop to solve the SMT encoding for the MCAPI program we are trying to solve. If there is not any bogus match pair in the generated set of match pairs, our solution can capture the true behavior of the system. If there is some bogus match pairs, our solution returns an error trace for the SMT problem. To test if the error is in real execution or not, our solution provides an ``oracle'' that takes this trace as input and simulates it. If the ``oracle'' can simulate the trace, we stop the $\mathrm{CEGAR}$ loop and guarantee of finding an error. If it is impossible for the ``oracle'' to simulate the trace, we prune the bogus match pairs founded by the ``oracle'', generate a new SMT problem with a new set of match pairs, and repeat the $\mathrm{CEGAR}$ loop.
 %We then input this over-approximated set of match pair to a CEGAR loop for further verification. Either error is found during one iteration and the process stops, or the current set of match pair is prune to a more precise one for the next iteration.

The algorithm generates the over-approximated match pair set by
matching each pair of the send and receive commands at common
endpoints and then pruning obvious matches that cannot exist in any
runtime implementation of the specification.

\begin{figure}[h]
\setlength{\tabcolsep}{20pt}
\begin{center}
\scalebox{0.7}{\usebox{\boxalgorithm}}\\
\end{center}
\caption{Pseudocode for generating over-approximated match pairs}
\label{fig:pseudocode}
\end{figure}

\figref{fig:pseudocode} presents the major steps of the algorithm. The algorithm proceeds by first linearly traversing each task of the program storing each receive and send command into two distinct structured lists. The receive list, $\mathtt{list\_r}$, is structured as in (\ref{equation:rcv}) and the send list, $\mathtt{list\_s}$, is structured as in (\ref{equation:snd}).
\begin{equation}
\footnotesize \begin{array}{l}
(\mathtt{e_0}\ \rightarrow\ ((0,\ \mathtt{R_{0,1}}),\ (1,\ \mathtt{R_{0,2}}),\ \ldots))\\
(\mathtt{e_1}\ \rightarrow\ ((0,\ \mathtt{R_{1,1}}),\ (1,\ \mathtt{R_{1,2}}),\ \ldots))\\
\ldots \\
(\mathtt{e_n}\ \rightarrow\ ((0,\ \mathtt{R_{n,1}}),\ (1,\ \mathtt{R_{n,2}}),\ \ldots))\\
\end{array}
\label{equation:rcv}
\end{equation}
The list \texttt{list\_r} groups receives by the issuing endpoint. The
integer field merely records the order in which the receives are
issued and increases by one on each receive. Similarly, the
list \texttt{list\_s} groups sends first by the destination endpoint
and then by the source endpoint. Like \texttt{list\_r}, an index
increases by one to track the issue order. As the input is a
program execution trace, any sends or receives in loops already have
unique identifiers.
\begin{equation}
\footnotesize \begin{array}{l}
 ``dest" \;\;\;\; ``src" \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; ``src"\\
(\mathtt{e_0}\ \rightarrow\ ((\mathtt{e_1}\ \rightarrow\ ((0,\ \mathtt{S_{1,1}}),\ (1,\ \mathtt{S_{1,2}}),\ \ldots),\ (\mathtt{e_2}\ \rightarrow\ (\ldots),\\ \ldots))))\\
(\mathtt{e_1}\ \rightarrow\ ((\mathtt{e_0}\ \rightarrow\ ((0,\ \mathtt{S_{0,1}}),\ (1,\ \mathtt{S_{0,2}}),\ \ldots),\ (\mathtt{e_2}\ \rightarrow\ (\ldots),\\ \ldots))))\\
 \dots\\
(\mathtt{e_n}\ \rightarrow\ ((\mathtt{e_0}\ \rightarrow\ ((0,\ \mathtt{S_{0,3}}),\ (1,\ \mathtt{S_{0,4}}),\ \ldots),\ (\mathtt{e_1}\ \rightarrow\ (\ldots),\\ \ldots))))\\
\end{array}
\label{equation:snd}
\end{equation}

\begin{figure}
\begin{center}
\setlength{\tabcolsep}{2pt}
\begin{tabular}[c]{l|l|l}
Task 0 & Task 1 & Task 2 \\
\hline
$\mathtt{R_{0,1}(*,\&h1)}$ & $\mathtt{S_{1,1}(0,\&h5)}$ & $\mathtt{S_{2,1}(0,\&h8)}$\\
$\mathtt{W(\&h1)}$&$\mathtt{W(\&h5)}$&$\mathtt{W(\&h8)}$\\
$\mathtt{R_{0,2}(*,\&h2)}$ & $\mathtt{R_{1,2}(*,\&h6)}$ & \\
$\mathtt{W(\&h2)}$&$\mathtt{W(\&h6)}$&\\
$\mathtt{S_{0,3}(1,\&h3)}$ & $\mathtt{S_{1,3}(0,\&h7)}$ & \\
$\mathtt{W(\&h3)}$&$\mathtt{W(\&h7)}$&\\
$\mathtt{R_{0,4}(*,\&h4)}$ & & \\
$\mathtt{W(\&h4)}$&&\\

%\scalebox{1}{\usebox{\boxtaskzero}} &
%\scalebox{1}{\usebox{\boxtaskone}} &
%\scalebox{1}{\usebox{\boxtasktwo}}\\
%\hspace{\stretch{5}}\texttt{rcvA} \hspace{\stretch{5}} & \hspace{\stretch{5}} \texttt{snd1(0)} \hspace{\stretch{5}} & \hspace{\stretch{5}}\texttt{snd3(0)}\hspace{\stretch{5}} \\
%\hspace{\stretch{5}}\texttt{rcvB}\hspace{\stretch{5}} & \hspace{\stretch{5}}\texttt{rcvD}\hspace{\stretch{5}} & \\
%\hspace{\stretch{10}}\texttt{snd4(1)} \hspace{\stretch{5}}& \hspace{\stretch{5}}\texttt{snd2(0)}\hspace{\stretch{5}} &\\
%\hspace{\stretch{5}}\texttt{rcvC}\hspace{\stretch{5}} & \hspace{\stretch{10}} &

\end{tabular}
\end{center}
\caption{Another MCAPI concurrent program}
\label{fig:mcapi1}
\end{figure}

Consider the program in \figref{fig:mcapi1}. The lists \texttt{list\_r} and \texttt{list\_s} for the program are
\begin{equation}
\footnotesize \begin{array}{l}
(0\ \rightarrow\ ((0,\ \mathtt{R_{0,1}}),\ (1,\ \mathtt{R_{0,2}}),\ (2,\ \mathtt{R_{0,4}})))\\
(1\ \rightarrow\ ((0,\ \mathtt{R_{1,2}})))\\
\end{array}
\label{equation:rcv_e}
\end{equation}
\begin{equation}
\footnotesize \begin{array}{l}
(0\ \rightarrow\ ((1\ \rightarrow\ ((0,\ \mathtt{S_{1,1}}),\ (1,\ \mathtt{S_{1,3}})),\ (2\ \rightarrow\ ((0,\ \mathtt{S_{2,1}}))))))\\
(1\ \rightarrow\ ((0\ \rightarrow\ ((0,\ \mathtt{S_{0,3}})))))\\
\end{array}
\label{equation:snd_e}
\end{equation}
The sends $\mathtt{S_{1,1}}$, $\mathtt{S_{1,3}}$, and
$\mathtt{S_{2,1}}$ have Task 0 as an identical destination
endpoint. The send $\mathtt{S_{0,3}}$ has Task 1 as the destination
endpoint. The list \texttt{list\_s} in (\ref{equation:snd_e}) reflects
this partition.  Receive $\mathtt{R_{0,1}}$ is the first receive
operation in endpoint 0. This fact is again reflected
in \texttt{list\_r} in (\ref{equation:rcv_e}).

The algorithm traverses the two lists in a nested loop to generate
match pairs between send and receive commands. The
function \texttt{index(r)} takes the endpoint of the receive and
returns the issue order of that receive in the \texttt{list\_r}
structure. Similarly, the function \texttt{index(s)} takes the
destination and source endpoints in the send and returns the issue
order of that send in the \texttt{list\_s} structure. These indexes
essentially capture message non-overtaking.

The criteria to generate a match pair first requires the send and
receive to be compatible (check 1), consistent with message
non-overtaking (check 2), and that message non-overtaking does not preclude the
match (check 3). A match is precluded by message non-overtaking when a
receive cannot possibly match a send because by the time the program
issues the receive, the send must have already been matched somewhere
else. The function \texttt{count} gives the number of sends to a
specific destination or the number of sends to a specific source and
destination.  As long as a receive is issued early enough to still
match the send given the message non-overtaking rule, then the match
is possible.

In our concrete example, $\mathtt{R_{0,1}}$ is matched with
$\mathtt{S_{1,1}}$ or $\mathtt{S_{2,1}}$, but it cannot be matched
with $\mathtt{S_{1,3}}$ since the second rule is not satisfied such
that the order of $\mathtt{R_{0,1}}$ is less than the order of
$\mathtt{S_{1,3}}$ (i.e., $\mathtt{S_{1,3}}$ would have to overtake
$\mathtt{S_{1,1}}$ to satisfy the rule). The match between
$\mathtt{R_{0,4}}$ and $\mathtt{S_{1,1}}$ is also precluded by check 3
as $\mathtt{S_{1,1}}$ must have already matched an earlier receive by
message non-overtaking.

The generated set of match pairs for our example
in \figref{fig:mcapi1} is over-approximated by the algorithm because
it includes pairs that cannot exist in any feasible execution. For
example, the match pair $(\mathtt{S_{2,1}}\ \mathtt{R_{0,4}})$ is not
feasible because it is not possible to order $\mathtt{S_{1,3}}$ before
$\mathtt{R_{0,2}}$ since $\mathtt{R_{1,2}}$ can only match with
$\mathtt{S_{0,3}}$ that must occur after
$\mathtt{R_{0,2}}$. Fortunately, a satisfying solution is only
possible using feasible match pairs. Non-feasible match-pairs
merely result in extra clauses in the encoding and potentially slow
down the SMT solver.

The complexity of the algorithm is quadratic. Traversing
the tasks to initialize the lists is $O(N)$, where $N$ is the total
lines of code of the program. Traversing the list of receives and the
list of sends takes $O(mn)$ to complete, where $m$ is the total number
of sends and $n$ is the total number of receives. As $m + n \le N$,
the algorithm takes $O(N + mn) \leq O(N + N^2) \approx O(N^2)$ to
complete.

%As discussed in the previous section, an over-approximated match set can give the same solution as a complete set does. As our match pair generation algorithm over-approximates the true set of match pairs allowed by the runtime for an MCAPI program trace, when used with our SMT encoding it cannot result in false positives (i.e.,  errors arising from match pairs that cannot happen in any implementation of the MCAPI specification).
