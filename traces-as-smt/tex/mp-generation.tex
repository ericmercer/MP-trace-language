
\newsavebox{\boxalgorithm}
\begin{lrbox}{\boxalgorithm}
\begin{minipage}[c]{1.4\linewidth}
\begin{alltt}
// initialization
input an MCAPI program
initialize list_r
initialize list_s

// check each receive and send with the same endpoint
for r in list_r
  for s in list_s
    // check matching criteria for r and s
    if
      1. endpoint(r) = destination endpoint(s)
      2. index(r) >= index(s)
      3. index(r) =< index(s) 
                     + count(sends(dest=s))
                     - count(sends(src=s, dest=s))
    then
      add pair (r, s) to match_set
    else
      continue
    end if
  end for
end for

output match_set;
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxtaskzero}
\begin{lrbox}{\boxtaskzero}
\begin{minipage}[t]{0.2\linewidth}
\begin{alltt}
rcvA
rcvB
snd4(1)
rcvC
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxtaskone}
\begin{lrbox}{\boxtaskone}
\begin{minipage}[t]{0.2\linewidth}
\begin{alltt}
snd1(0)
rcvD
snd2(0)
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxtasktwo}
\begin{lrbox}{\boxtasktwo}
\begin{minipage}[t]{0.2\linewidth}
\begin{alltt}
snd3(0)
\end{alltt}
\end{minipage}
\end{lrbox}

\section{Generating Match Pairs} \label{sec:mp-gen}

The exact set of match pairs can be generated by simulating the program trace and using a depth-first search to enumerate non-determinism arising from concurrent sends and receives. Such an effort, however, solves the entire problem at once because if you simulate the program trace exploring all non-determinism, then you may as well verify all runtime choices for property violations at the same time. In this section, we present an algorithm that does not require an exhaustive enumeration of runtime behavior in simulation. Our algorithm over-approximates the match pairs such that match pairs that can exist in the runtime are all included and some ``bogus" match pairs that cannot exist in the runtime may or may not be included. %With this set of match pairs, our solution provides a $\mathrm{CEGAR}$ loop to solve the SMT encoding for the MCAPI program we are trying to solve. If there is not any bogus match pair in the generated set of match pairs, our solution can capture the true behavior of the system. If there is some bogus match pairs, our solution returns an error trace for the SMT problem. To test if the error is in real execution or not, our solution provides an ``oracle'' that takes this trace as input and simulates it. If the ``oracle'' can simulate the trace, we stop the $\mathrm{CEGAR}$ loop and guarantee of finding an error. If it is impossible for the ``oracle'' to simulate the trace, we prune the bogus match pairs founded by the ``oracle'', generate a new SMT problem with a new set of match pairs, and repeat the $\mathrm{CEGAR}$ loop.
 %We then input this over-approximated set of match pair to a CEGAR loop for further verification. Either error is found during one iteration and the process stops, or the current set of match pair is prune to a more precise one for the next iteration.

The algorithm generates the over-approximated match pair set by
matching each pair of the send and receive commands at common
endpoints and then pruning obvious matches that cannot exist in any
runtime implementation of the specification.

\begin{figure}[h]
\setlength{\tabcolsep}{20pt}
\begin{center}
\scalebox{0.7}{\usebox{\boxalgorithm}}\\
\end{center}
\caption{Pseudocode for generating over-approximated match pairs}
\label{fig:pseudocode}
\end{figure}

\figref{fig:pseudocode} presents the major steps of the algorithm. The algorithm proceeds by first linearly traversing each task of the program storing each receive and send command into two distinct structured lists. The receive list $\mathtt{list\_r}$ is structured as in (\ref{equation:rcv}) and the send list $\mathtt{list\_s}$ is structured as in (\ref{equation:snd}).
\begin{equation}
\footnotesize \begin{array}{l}
(\mathtt{e_0}\ \rightarrow\ ((0,\ \mathtt{R_{0,1}}),\ (1,\ \mathtt{R_{0,2}}),\ \ldots))\\
(\mathtt{e_1}\ \rightarrow\ ((0,\ \mathtt{R_{1,1}}),\ (1,\ \mathtt{R_{1,2}}),\ \ldots))\\
\ldots \\
(\mathtt{e_n}\ \rightarrow\ ((0,\ \mathtt{R_{n,1}}),\ (1,\ \mathtt{R_{n,2}}),\ \ldots))\\
\end{array}
\label{equation:rcv}
\end{equation}
The list in (\ref{equation:rcv}) keeps record of the receive commands uniquely identified by the endpoint $\mathit{e}_x$, where $x$ is the number of the endpoint. The integer in the first field of each pair indicates the program order of the receive commands within each task on the specified endpoint. The receive command with lower program order should be served first in the program runtime. The receive command in the second field of the list is defined as a record $\mathtt{R}$ in \defref{def:rcv} of the previous section. The notations $\mathtt{R_{0,1}}$, $\mathtt{R_{0,2}}$, etc. represent the unique identifiers for the receives. As we operate on a program trace, there are no loops and all instances of send and receive operations are uniquely identified.
\begin{equation}
\footnotesize \begin{array}{l}
 ``dst" \;\;\;\; ``src" \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; ``src"\\
(\mathtt{e_0}\ \rightarrow\ ((\mathtt{e_1}\ \rightarrow\ ((0,\ \mathtt{S_{1,1}}),\ (1,\ \mathtt{S_{1,2}}),\ \ldots),\ (\mathtt{e_2}\ \rightarrow\ (\ldots),\\ \ldots))))\\
(\mathtt{e_1}\ \rightarrow\ ((\mathtt{e_0}\ \rightarrow\ ((0,\ \mathtt{S_{0,1}}),\ (1,\ \mathtt{S_{0,2}}),\ \ldots),\ (\mathtt{e_2}\ \rightarrow\ (\ldots),\\ \ldots))))\\
 \dots\\
(\mathtt{e_n}\ \rightarrow\ ((\mathtt{e_0}\ \rightarrow\ ((0,\ \mathtt{S_{0,3}}),\ (1,\ \mathtt{S_{0,4}}),\ \ldots),\ (\mathtt{e_1}\ \rightarrow\ (\ldots),\\ \ldots))))\\
\end{array}
\label{equation:snd}
\end{equation}
Also, we keep record of the send commands using the second list in (\ref{equation:snd}) that is uniquely identified by the destination endpoint $\mathit{e}_x$. Each sublist for the destination endpoint is uniquely identified by the source endpoint $\mathit{e}_y$. Similarly, the integer in the first field of each pair indicates the program order of the send command within the same task from a common source and to a common endpoint. The send command in the second field of the list is defined as a record $S$ in \defref{def:snd} of the previous section. The notations $\mathtt{S_{1,1}}$, $\mathtt{S_{1,2}}$, etc. represent the unique identifiers for the sends.

\begin{figure}
\begin{center}
\setlength{\tabcolsep}{2pt}
\begin{tabular}[c]{l|l|l}
Task 0 & Task 1 & Task 2 \\
\hline
$\mathtt{R_{0,1}(*,\&h1)}$ & $\mathtt{S_{1,1}(0,\&h5)}$ & $\mathtt{S_{2,1}(0,\&h8)}$\\
$\mathtt{W(\&h1)}$&$\mathtt{W(\&h5)}$&$\mathtt{W(\&h8)}$\\
$\mathtt{R_{0,2}(*,\&h2)}$ & $\mathtt{R_{1,2}(*,\&h6)}$ & \\
$\mathtt{W(\&h2)}$&$\mathtt{W(\&h6)}$&\\
$\mathtt{S_{0,3}(1,\&h3)}$ & $\mathtt{S_{1,3}(0,\&h7)}$ & \\
$\mathtt{W(\&h3)}$&$\mathtt{W(\&h7)}$&\\
$\mathtt{R_{0,4}(*,\&h4)}$ & & \\
$\mathtt{W(\&h4)}$&&\\

%\scalebox{1}{\usebox{\boxtaskzero}} &
%\scalebox{1}{\usebox{\boxtaskone}} &
%\scalebox{1}{\usebox{\boxtasktwo}}\\
%\hspace{\stretch{5}}\texttt{rcvA} \hspace{\stretch{5}} & \hspace{\stretch{5}} \texttt{snd1(0)} \hspace{\stretch{5}} & \hspace{\stretch{5}}\texttt{snd3(0)}\hspace{\stretch{5}} \\
%\hspace{\stretch{5}}\texttt{rcvB}\hspace{\stretch{5}} & \hspace{\stretch{5}}\texttt{rcvD}\hspace{\stretch{5}} & \\
%\hspace{\stretch{10}}\texttt{snd4(1)} \hspace{\stretch{5}}& \hspace{\stretch{5}}\texttt{snd2(0)}\hspace{\stretch{5}} &\\
%\hspace{\stretch{5}}\texttt{rcvC}\hspace{\stretch{5}} & \hspace{\stretch{10}} &

\end{tabular}
\end{center}
\caption{Another MCAPI concurrent program}
\label{fig:mcapi1}
\end{figure}

\figref{fig:mcapi1} is an example program in our shorthand notation to present our algorithm. The sends $\mathtt{S_{1,1}}$ ,$\mathtt{S_{1,3}}$ and $\mathtt{S_{2,1}}$ have Task 0 as an identical destination endpoint. The send $\mathtt{S_{0,3}}$ has Task 1 as the destination endpoint. In our running example in \figref{fig:mcapi1}, we generate our receive list and send list in equation (\ref{equation:rcv_e}) and (\ref{equation:snd_e}), respectively.
\begin{equation}
\footnotesize \begin{array}{l}
(0\ \rightarrow\ ((0,\ \mathtt{R_{0,1}}),\ (1,\ \mathtt{R_{0,2}}),\ (2,\ \mathtt{R_{0,4}})))\\
(1\ \rightarrow\ ((0,\ \mathtt{R_{1,2}})))\\
\end{array}
\label{equation:rcv_e}
\end{equation}
\begin{equation}
\footnotesize \begin{array}{l}
(0\ \rightarrow\ ((1\ \rightarrow\ ((0,\ \mathtt{S_{1,1}}),\ (1,\ \mathtt{S_{1,3}})),\ (2\ \rightarrow\ ((0,\ \mathtt{S_{2,1}}))))))\\
(1\ \rightarrow\ ((0\ \rightarrow\ ((0,\ \mathtt{S_{0,3}})))))\\
\end{array}
\label{equation:snd_e}
\end{equation}
Receive $\mathtt{R_{0,1}}$ is the first receive operation in endpoint 0, and $\mathtt{S_{2,1}}$ is the first send from the source endpoint 2 to the destination endpoint 0.

The second step for our algorithm is to linearly traverse both lists to generate match pairs between send and receive commands. Observe that the sends defined with an identical destination endpoint and an identical source endpoint are processed in a FIFO order according to the MCAPI runtime specification. The same is true of receives on a common endpoint in a common task. The FIFO ordering, sometimes referred to as message non-overtaking, lets us prune match pairs that obviously cannot be generated in any valid implementation of the MCAPI runtime.

Let $I_r$ and $I_s$ be the program order indication in the lists of (\ref{equation:rcv}) and (\ref{equation:snd}) respectively and similarly \texttt{R} and \texttt{S} be the corresponding actions. The values of $I_r$ and $I_s$ are increased by 1 for two consecutive receives or sends, respectively. Further, $n_s(*,\mathit{dst})$ is the number of send actions from any source to $\mathit{dst}$ and $n_s(\mathit{src},\mathit{dst})$ is the number of sends from $\mathit{src}$ to $\mathit{dst}$, where $\mathit{src}$ and $\mathit{dst}$ represent the source and destination endpoints, respectively. A send and receive can be matched if and only if
\begin{itemize}
\item[1.] the destination endpoint of $\mathtt{S}$ is identical to the endpoint of $\mathtt{R}$;
\item[2.] $I_r \geq I_s$;
\item[3.] and $I_r \leq I_s + (n_s(*,\mathit{dst}) - n_s(\mathit{src},\mathit{dst}))$.
\end{itemize}
If all rules of the criteria are satisfied for a send and a receive, we build a match pair for the send and the receive in the result set $\mathtt{match\_set}$. In our concrete example, $\mathtt{R_{0,1}}$ is matched with $\mathtt{S_{1,1}}$ or $\mathtt{S_{2,1}}$, but it cannot be matched with $\mathtt{S_{1,3}}$ since the second rule is not satisfied such that the order of $\mathtt{R_{0,1}}$ is less than the order of $\mathtt{S_{1,3}}$. We repeatedly apply the criteria to match sends and receives until we completely traverse the lists in (\ref{equation:rcv}) and (\ref{equation:snd}). The generated set of match pairs for our example in \figref{fig:mcapi1} is imprecise such that some extra match pairs, which we call ``bogus", that cannot exist in the real execution trace are included. In particular, the match pair $(\mathtt{S_{2,1}}\ \mathtt{R_{0,4}})$ is a ``bogus" match pair because it is not possible to order $\mathtt{S_{1,3}}$ before $\mathtt{R_{0,2}}$ since $\mathtt{R_{1,2}}$ can only match with $\mathtt{S_{0,3}}$ that must occur after $\mathtt{R_{0,2}}$. Fortunately, the encoding in this paper is strong enough to preclude that bad match pair in any satisfying solution.


Now let us analyze the time complexity of the algorithm. Traversing the tasks linearly takes $O(N)$ to complete, where $N$ is the total lines of code of the program. Traversing the list of receives and the list of sends takes $O(mn)$ to complete, where $m$ is the total number of sends and $n$ is the total number of receives. As $m + n \le N$, the algorithm takes $O(N + mn) \leq O(N + N^2) \approx O(N^2)$ to complete.

%As discussed in the previous section, an over-approximated match set can give the same solution as a complete set does. As our match pair generation algorithm over-approximates the true set of match pairs allowed by the runtime for an MCAPI program trace, when used with our SMT encoding it cannot result in false positives (i.e.,  errors arising from match pairs that cannot happen in any implementation of the MCAPI specification).
