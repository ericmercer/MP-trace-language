
\newsavebox{\boxtaskzero}
\begin{lrbox}{\boxtaskzero}
\begin{minipage}[t]{0.2\linewidth}
\begin{alltt}
rcvA
rcvB
snd4(1)
rcvC
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxtaskone}
\begin{lrbox}{\boxtaskone}
\begin{minipage}[t]{0.2\linewidth}
\begin{alltt}
snd1(0)
rcvD
snd2(0)
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxtasktwo}
\begin{lrbox}{\boxtasktwo}
\begin{minipage}[t]{0.2\linewidth}
\begin{alltt}
snd3(0)
\end{alltt}
\end{minipage}
\end{lrbox}

\section{Generating Match Pairs}


The exact set of match pairs can be generated by simulating the program trace and using a depth-first search to enumerate non-determinism arising from concurrent sends and receives. Such an effort, however, solves the very problem we are trying to solve because if you simulate the program trace exploring all non-determinism, then you can also verify all runtime choices for property violations. In this section, we present an algorithm that does not require an exhaustive enumeration of runtime behavior in simulation. Our algorithm over-approximates the match pairs such that match pairs that can exist in the runtime are all included and some bogus match pairs that can not exist in the runtime may or may not be included. %With this set of match pairs, our solution provides a $\mathrm{CEGAR}$ loop to solve the SMT encoding for the MCAPI program we are trying to solve. If there is not any bogus match pair in the generated set of match pairs, our solution can capture the true behavior of the system. If there is some bogus match pairs, our solution returns an error trace for the SMT problem. To test if the error is in real execution or not, our solution provides an ``oracle'' that takes this trace as input and simulates it. If the ``oracle'' can simulate the trace, we stop the $\mathrm{CEGAR}$ loop and guarantee of finding an error. If it is impossible for the ``oracle'' to simulate the trace, we prune the bogus match pairs founded by the ``oracle'', generate a new SMT problem with a new set of match pairs, and repeat the $\mathrm{CEGAR}$ loop.
 %We then input this over-approximated set of match pair to a CEGAR loop for further verification. Either error is found during one iteration and the process stops, or the current set of match pair is prune to a more precise one for the next iteration.

\begin{figure*}
\begin{center}
\setlength{\tabcolsep}{2pt}
\begin{tabular}[c]{c|c|c}
Task 0 \hspace{\stretch{15}}& \hspace{\stretch{15}}Task 1\hspace{\stretch{15}} & \hspace{\stretch{15}}Task 2\hspace{\stretch{15}} \\
\hline
$\mathtt{R_{0,1}(*,\&h1)}$ \hspace{\stretch{15}}& $\mathtt{S_{1,1}(0,\&h5)}$ \hspace{\stretch{15}}& $\mathtt{S_{2,1}(0,\&h8)}$\hspace{\stretch{15}}\\
$\mathtt{R_{0,2}(*,\&h2)}$ \hspace{\stretch{15}}& $\mathtt{R_{1,2}(*,\&h6)}$ \hspace{\stretch{15}}& \\
$\mathtt{S_{0,3}(1,\&h3)}$ \hspace{\stretch{15}}& $\mathtt{S_{1,3}(0,\&h7)}$ \hspace{\stretch{15}}& \\
$\mathtt{R_{0,4}(*,\&h4)}$ \hspace{\stretch{15}}& & \\

%\scalebox{1}{\usebox{\boxtaskzero}} &
%\scalebox{1}{\usebox{\boxtaskone}} &
%\scalebox{1}{\usebox{\boxtasktwo}}\\
%\hspace{\stretch{5}}\texttt{rcvA} \hspace{\stretch{5}} & \hspace{\stretch{5}} \texttt{snd1(0)} \hspace{\stretch{5}} & \hspace{\stretch{5}}\texttt{snd3(0)}\hspace{\stretch{5}} \\
%\hspace{\stretch{5}}\texttt{rcvB}\hspace{\stretch{5}} & \hspace{\stretch{5}}\texttt{rcvD}\hspace{\stretch{5}} & \\
%\hspace{\stretch{10}}\texttt{snd4(1)} \hspace{\stretch{5}}& \hspace{\stretch{5}}\texttt{snd2(0)}\hspace{\stretch{5}} &\\
%\hspace{\stretch{5}}\texttt{rcvC}\hspace{\stretch{5}} & \hspace{\stretch{10}} &

\end{tabular}
\end{center}
\caption{Another MCAPI concurrent program}
\label{fig:mcapi1}
\end{figure*}

The algorithm generates the over-approximated match pair set by matching each pair of the send and receive commands at common endpoints and then pruning obvious matches that can not exist in any runtime implementation of the specification. \figref{fig:mcapi1} is an example program in our shorthand notation to present our algorithm. The sends $\mathtt{S_{1,1}}$ ,$\mathtt{S_{1,3}}$ and $\mathtt{S_{2,1}}$ have Task 0 as an identical destination endpoint. The send $\mathtt{S_{0,3}}$ has Task 1 as the destination endpoint.
Algorithm proceeds by first linearly traversing each task of the program storing each receive and send command into two distinct structured lists. Sends are structured as in (\ref{equation:snd}) and receives are structured as in (\ref{equation:rcv}).
\begin{equation}
\footnotesize \begin{array}{l}
(\mathtt{e_0}\ \rightarrow\ ((0,\ \mathtt{R_{0,1}}),\ (1,\ \mathtt{R_{0,2}}),\ \ldots))\\
(\mathtt{e_1}\ \rightarrow\ ((0,\ \mathtt{R_{1,1}}),\ (1,\ \mathtt{R_{1,2}}),\ \ldots))\\
\ldots \\
(\mathtt{e_n}\ \rightarrow\ ((0,\ \mathtt{R_{n,1}}),\ (1,\ \mathtt{R_{n,2}}),\ \ldots))\\
\end{array}
\label{equation:rcv}
\end{equation}
The list in (\ref{equation:rcv}) keeps record of the receive commands uniquely identified by the endpoint $\mathit{e}_x$, where $x$ is the number of the endpoint. The integer in the first field of each pair indicates the program order of the receive commands within each task on the specified endpoint. Note that the receive command with lower program order should be served first in the program runtime. The receive command in the second field of the list is defined as a record $R$ in equation \ref{equation:record} of the previous section. The notations $\mathtt{R_{0,1}}$, $\mathtt{R_{0,2}}$, etc. represent the unique identifiers for the receives. Recall that we operate on a program trace so there are no loops and all instances of send and receive operations are uniquely identified.
\begin{equation}
\footnotesize \begin{array}{l}
 ``dst" \;\;\;\; ``src" \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; ``src"\\
(\mathtt{e_0}\ \rightarrow\ ((\mathtt{e_1}\ \rightarrow\ ((0,\ \mathtt{S_{1,1}}),\ (1,\ \mathtt{S_{1,2}}),\ \ldots),\ (\mathtt{e_2}\ \rightarrow\ (\ldots),\ \ldots))))\\
(\mathtt{e_1}\ \rightarrow\ ((\mathtt{e_0}\ \rightarrow\ ((0,\ \mathtt{S_{0,1}}),\ (1,\ \mathtt{S_{0,2}}),\ \ldots),\ (\mathtt{e_2}\ \rightarrow\ (\ldots),\ \ldots))))\\
 \dots\\
(\mathtt{e_n}\ \rightarrow\ ((\mathtt{e_0}\ \rightarrow\ ((0,\ \mathtt{S_{0,3}}),\ (1,\ \mathtt{S_{0,4}}),\ \ldots),\ (\mathtt{e_1}\ \rightarrow\ (\ldots),\ \ldots))))\\
\end{array}
\label{equation:snd}
\end{equation}
Also, we keep record of the send commands using the second list in (\ref{equation:snd}) that is uniquely identified by the destination endpoint $\mathit{e}_x$. Each sublist for the destination endpoint is uniquely identified by the source endpoint $\mathit{e}_y$. Similarly, the integer in the first field of each pair indicates the program order of the send command within the same task from a common source and to a common endpoint. The send command in the second field of the list is defined as a record $S$ in equation \ref{equation:record} of the previous section. The notations $\mathtt{S_{1,1}}$, $\mathtt{S_{1,2}}$, etc. represent the unique identifiers for the sends.

In our running example in \figref{fig:mcapi1}, we generate our receive list and send list in equation (\ref{equation:rcv_e}) and (\ref{equation:snd_e}), respectively.
\begin{equation}
\footnotesize \begin{array}{l}
(0\ \rightarrow\ ((0,\ \mathtt{R_{0,1}}),\ (1,\ \mathtt{R_{0,2}}),\ (2,\ \mathtt{R_{0,4}})))\\
(1\ \rightarrow\ ((0,\ \mathtt{R_{1,2}})))\\
\end{array}
\label{equation:rcv_e}
\end{equation}
\begin{equation}
\footnotesize \begin{array}{l}
(0\ \rightarrow\ ((1\ \rightarrow\ ((0,\ \mathtt{S_{1,1}}),\ (1,\ \mathtt{S_{1,3}})),\ (2\ \rightarrow\ ((0,\ \mathtt{S_{2,1}}))))))\\
(1\ \rightarrow\ ((0\ \rightarrow\ ((0,\ \mathtt{S_{0,3}})))))\\
\end{array}
\label{equation:snd_e}
\end{equation}
Note that $\mathtt{R_{0,1}}$ is the first receive operation in endpoint 0, and $\mathtt{S_{2,1}}$ is the first send from the source endpoint 2 to the destination endpoint 0.

The second step for our algorithm is to linearly traverse both lists to generate match pairs between send and receive commands. Observe that the sends defined with an identical destination endpoint and an identical source endpoint are processed in a FIFO order according to the MCAPI runtime specification. The same is true of receives on a common endpoint in a common task. The FIFO ordering, sometimes referred to as message non-overtaking, lets us prune match pairs that obviously can not be generated in any valid implementation of the MCAPI runtime.

Let $I_r$ and $I_s$ be the program order indication in the lists of (\ref{equation:rcv}) and (\ref{equation:snd}) respectively and similarly \texttt{R} and \texttt{S} be the corresponding actions. Note that $I_r$ and $I_s$ are increased by 1 for two consecutive receives or sends, respectively. Further, $N_s$ is the number of send actions in the program and $n_s(\mathit{src},\mathit{dst})$ be the number of sends from $\mathit{src}$ to $\mathit{dst}$, where $\mathit{src}$ and $\mathit{dst}$ represent the source and destination endpoints, respectively. A send and received can be matched if and only if
\begin{itemize}
\item[1.] the destination endpoint of $\mathtt{S}$ is identical to the endpoint of $\mathtt{R}$;
\item[2.] $I_r \geq I_s$;
\item[3.] and $I_r \leq I_s + (N_s - n_s(\mathit{src},\mathit{dst}))$.
\end{itemize}
If all rules of the criteria are satisfied for a send and a receive, we build a match pair for the send and the receive in the result set. In our concrete example, $\mathtt{R_{0,1}}$ is matched with $\mathtt{S_{1,1}}$ or $\mathtt{S_{2,1}}$, but it can not be matched with $\mathtt{S_{1,3}}$ since the second rule is not satisfied such that the order for $\mathtt{R_{0,1}}$ is less than the order of $\mathtt{S_{1,3}}$. We repeatedly apply the criteria to match sends and receives until we completely traverse the lists in (\ref{equation:rcv}) and (\ref{equation:snd}). The generated set of match pairs for our example in \figref{fig:mcapi1} is imprecise such that some extra match pair, we call ``bogus", that can not exist in the real execution of program are included. In particular, the match pair $(\mathtt{S_{2,1}}\ \mathtt{R_{0,4}})$ is a ``bogus" match pair because it is not possible to order $\mathtt{S_{1,3}}$ before $\mathtt{R_{0,2}}$ since $\mathtt{R_{1,2}}$ can only match with $\mathtt{S_{0,3}}$ that must occur after $\mathtt{R_{0,2}}$. Fortunately, the encoding in this paper is strong enough to preclude that bad match pair in any satisfying solution.


Now let us analyze the time complexity of the algorithm. Traversing the tasks linearly takes $O(N)$ to complete, where $N$ is the total lines of code of the program. Traversing the list of receives and the list of sends takes $O(mn)$ to complete, where $m$ is the total number of sends and $n$ is the total number of receives. Note that $m + n \le N$. Totally, the algorithm takes $O(N + mn) \leq O(N + N^2) \approx O(N^2)$ to complete.

As our match pair generation algorithm over-approximates the true set of match pairs allowed by the runtime for an MCAPI program trace, when used with our SMT encoding it may result in false positives (i.e.,  errors arising from match pairs that cannot happen in any implementation of the MCAPI specification). To resolve such false positives, the witness trace from any SMT problem that is satisfiable is given to an oracle to validate if the trace is feasible. If it is, then the error is a true error. If it is not feasible in a valid MCAPI runtime, then the bad match pair is pruned and a new SMT encoding is generated. In this way, the encoding and match-pair generation algorithm can be used in a CEGAR loop. The oracle to detect infeasible match pairs come from formal model of the MCAPI runtime. The details are found in \cite{morse:vmcai12} and long version of our paper at (\url{``http://students.cs.byu.edu/~yhuang2/downloads/paper.pdf''}).
