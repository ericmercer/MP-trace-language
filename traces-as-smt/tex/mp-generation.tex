

\section{ Over-approximated Match Pairs Generation}


The exact set of match pairs can be generated by simulating program execution and using a depth-first search to enumerate non-determinism arising from concurrent sends and receives. Such an effort, however, solves the very problem we are trying to solve because if you simulate the entire program exploring all non-determinism, then you can also verify all program executions for property violations. In this section, we present an algorithm that does not require an exhaustive enumeration of program behavior in simulation. Our algorithm over-approximates the set of match pair, such that match pairs that can exist in the real execution are all included, and some bogus match pairs that can not exist in the execution may or may not be included. %With this set of match pairs, our solution provides a $\mathrm{CEGAR}$ loop to solve the SMT encoding for the MCAPI program we are trying to solve. If there is not any bogus match pair in the generated set of match pairs, our solution can capture the true behavior of the system. If there is some bogus match pairs, our solution returns an error trace for the SMT problem. To test if the error is in real execution or not, our solution provides an ``oracle'' that takes this trace as input and simulates it. If the ``oracle'' can simulate the trace, we stop the $\mathrm{CEGAR}$ loop and guarantee of finding an error. If it is impossible for the ``oracle'' to simulate the trace, we prune the bogus match pairs founded by the ``oracle'', generate a new SMT problem with a new set of match pairs, and repeat the $\mathrm{CEGAR}$ loop.
 %We then input this over-approximated set of match pair to a CEGAR loop for further verification. Either error is found during one iteration and the process stops, or the current set of match pair is prune to a more precise one for the next iteration.

Other than simulating all possible executions of the program, the algorithm that generates the over-approximated match pairs is basically a strategy of matching each pair of the send and receive commands with common endpoint and pruning some bogus matches that can not exist in the real executions. Our algorithm uses two lists that keeps record for all send and receive commands.

\begin{equation}
\footnotesize \begin{array}{l}
(e_0\ \rightarrow\ ((0,\ rcv_{00}),\ (1,\ rcv_{01}),\ \ldots))\\
(e_1\ \rightarrow\ ((0,\ rcv_{10}),\ (1,\ rcv_{11}),\ \ldots))\\
\ldots \\
(e_n\ \rightarrow\ ((0,\ rcv_{n0}),\ (1,\ rcv_{n1}),\ \ldots))\\
\end{array}
\label{equation:rcv}
\end{equation}

The list in (\ref{equation:rcv}) keeps record of the receive commands uniquely identified by the endpoint $\mathit{e}_x$, where $x$ is the number of the endpoint. The integer in the first field of each pair represents the index of the receive command for each endpoint. We use $I_r$ to denote the index. Note that the receive command with smaller $I_r$ should be served first in the program runtime. The receive command $rcv_{xxx}$ in the second field of the list is defined as a record $R$ in equation \ref{equation:record} of the previous section. The number $xxx$ represents the command number.

\begin{equation}
\footnotesize \begin{array}{l}
 ``dst" \;\;\;\; ``src" \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; ``src"\\
(e_0\ \rightarrow\ ((e_1\ \rightarrow\ ((0,\ snd_{100}),\ (1,\ snd_{101}),\ \ldots),\ (e_2\ \rightarrow\ (\ldots),\ \ldots))))\\
(e_1\ \rightarrow\ ((e_0\ \rightarrow\ ((0,\ snd_{010}),\ (1,\ snd_{011}),\ \ldots),\ (e_2\ \rightarrow\ (\ldots),\ \ldots))))\\
 \dots\\
(e_n\ \rightarrow\ ((e_0\ \rightarrow\ ((0,\ snd_{0n0}),\ (1,\ snd_{0n1}),\ \ldots),\ (e_1\ \rightarrow\ (\ldots),\ \ldots))))\\
\end{array}
\label{equation:snd}
\end{equation}

Also, we keep record of the send commands using the list in (\ref{equation:snd}) that is uniquely identified by the destination endpoint $\mathit{e}_x$. Each sublist for the destination endpoint is uniquely identified by the source endpoint $\mathit{e}_y$. The integers $x$ and $y$ in the endpoints represent the number of the destination and source endpoints, respectively. The strings ``dst'' and ``src'' indicate the endpoint is either a destination or a source, respectively. Similarly, the integer in the first field of each pair represents the index of the send command. We use $I_s$ to denote the index. Note that $I_s$ is ordered within each sublist. The send command $snd_{xxx}$ in the second field of the list is defined as a record $S$ in equation \ref{equation:record} of the previous section. The number $xxx$ represents the command number.

Observe that the sends defined with an identical destination endpoint and an identical source endpoint are processed in a FIFO way in the program runtime. Also, the receive ordered first should be served first compared with those from an identical endpoint. Because of the fact of FIFO processing, a list of receives in (\ref{equation:rcv}) and a sublist of sends in (\ref{equation:snd}) with an identical endpoint can be determined how many matches there are from the sends to the receives by applying the following criteria:

For each receive command $\mathtt{rcv}$ in the list of (\ref{equation:rcv}) with index $I_r$ and each send command $\mathtt{snd}$ in the sublist of (\ref{equation:snd}) with index $I_s$, if $\mathtt{rcv}$ is matched with $\mathtt{snd}$, we have,
\begin{itemize}
\item[1.] the destination endpoint of $\mathtt{snd}$ is identical to the endpoint of $\mathtt{rcv}$;
\item[2.] $I_r \geq I_s$;
\item[3.] and $I_r \leq I_s + (N_s - n_s)$.
\end{itemize} 
where $N_s$ is the number of the sends in the program, and $n_s$ is the number of the sends in the sublist where $\mathtt{snd}$ is resident. 

After given the criteria above, we can now provide our algorithm and analyze the time complexity. Intuitively, we use the criteria above to prune each ``bogus" match pair from a send to a receive if at least one of the rules is not satisfied. Our method works as follows. First, we linearly traverse each task of the program and store each receive and send command to the lists in (\ref{equation:rcv}) and (\ref{equation:snd}), respectively. This step takes $O(N)$ to complete, where $N$ is the number of commands in the program. Second, we pick up each list of receives in (\ref{equation:rcv}) and each sublist in (\ref{equation:snd}), and then apply the criteria above to each send command $\mathtt{snd}$ and receive command $\mathtt{rcv}$. If all rules of the criteria are satisfied for $\mathtt{snd}$ and $\mathtt{rcv}$, we build a match pair $(\mathtt{snd},\mathtt{rcv})$ in the result set. This step takes $O(N^2)$ to complete since each pair of a send and a receive should be determined by the criteria. Once step 2 is completed, we build a set of match pairs, where all match pairs that can exist in the program runtime are included, and those can not exist in the real execution may or may not be included. Totally, the algorithm takes $O(N + N^2) \approx O(N^2)$ to complete.


By setting the over-approximated set of match pairs as input to our solution, we then validate satisfying assignments from the SMT solver to see if they use only feasible match pairs. Such validation is accomplished by creating an ``oracle" - a model of the MCAPI library with full operational semantics. The model is able to detect bad match pairs in a given program trace. The operational semantics of the model are presented in the long version of paperwork at (url??????????). The bad match pairs can be omitted from the SMT encoding and the SMT solver re-run to see if another solution exists. The framework provides a \textit{CEGAR} loop for MCAPI trace verification.
