
\newsavebox{\boxtaskzero}
\begin{lrbox}{\boxtaskzero}
\begin{minipage}[c]{0.2\linewidth}
\begin{alltt}
    rcvA
    rcvB
    snd4
    rcvC
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxtaskone}
\begin{lrbox}{\boxtaskone}
\begin{minipage}[c]{0.2\linewidth}
\begin{alltt}
    snd1
    rcvD
    snd2
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxtasktwo}
\begin{lrbox}{\boxtasktwo}
\begin{minipage}[c]{0.2\linewidth}
\begin{alltt}
    snd3
\end{alltt}
\end{minipage}
\end{lrbox}

\section{ Over-approximated Match Pairs Generation}


The exact set of match pairs can be generated by simulating program execution and using a depth-first search to enumerate non-determinism arising from concurrent sends and receives. Such an effort, however, solves the very problem we are trying to solve because if you simulate the entire program exploring all non-determinism, then you can also verify all program executions for property violations. In this section, we present an algorithm that does not require an exhaustive enumeration of program behavior in simulation. Our algorithm over-approximates the set of match pair, such that match pairs that can exist in the real execution are all included, and some bogus match pairs that can not exist in the execution may or may not be included. %With this set of match pairs, our solution provides a $\mathrm{CEGAR}$ loop to solve the SMT encoding for the MCAPI program we are trying to solve. If there is not any bogus match pair in the generated set of match pairs, our solution can capture the true behavior of the system. If there is some bogus match pairs, our solution returns an error trace for the SMT problem. To test if the error is in real execution or not, our solution provides an ``oracle'' that takes this trace as input and simulates it. If the ``oracle'' can simulate the trace, we stop the $\mathrm{CEGAR}$ loop and guarantee of finding an error. If it is impossible for the ``oracle'' to simulate the trace, we prune the bogus match pairs founded by the ``oracle'', generate a new SMT problem with a new set of match pairs, and repeat the $\mathrm{CEGAR}$ loop.
 %We then input this over-approximated set of match pair to a CEGAR loop for further verification. Either error is found during one iteration and the process stops, or the current set of match pair is prune to a more precise one for the next iteration.

\begin{figure*}
\begin{center}
\setlength{\tabcolsep}{2pt}
\begin{tabular}[t]{c|c|c}
Task 0 & Task 1 & Task 2 \\
\hline
\scalebox{1}{\usebox{\boxtaskzero}}&
\scalebox{1}{\usebox{\boxtaskone}} &
\scalebox{1}{\usebox{\boxtasktwo}}\\
%& & \\
%\hline
%\scalebox{0.5}{\usebox{\boxATZero}} &
%\scalebox{0.5}{\usebox{\boxATOne}}  &
%\scalebox{0.5}{\usebox{\boxATTwo}}
\end{tabular}
\end{center}
\caption{Another MCAPI concurrent program}
\label{fig:mcapi1}
\end{figure*}

Other than simulating all possible executions of the program, the algorithm that generates the over-approximated match pairs is basically a strategy of matching each pair of the send and receive commands with common endpoint and pruning some bogus matches that can not exist in the real executions. We use the MCAPI program in \figref{fig:mcapi1} as an example to present our algorithm steps. Omitted are the definitions of $\mathtt{snd1}$, $\mathtt{rcvA}$, etc., and the shorthand is used for describing our problem. The sends $\mathtt{snd1}$ ,$\mathtt{snd2}$ and $\mathtt{snd3}$ have Task 0 as an identical destination endpoint. The send $\mathtt{snd4}$ has Task 1 as the destination endpoint.
First, we linearly traverse each task of the program and store each receive and send command to two lists. The general format of the two lists are presented in (\ref{equation:rcv}) and (\ref{equation:snd}), respectively.
\begin{equation}
\footnotesize \begin{array}{l}
(e_0\ \rightarrow\ ((0,\ rcv_{0}),\ (1,\ rcv_{1}),\ \ldots))\\
(e_1\ \rightarrow\ ((0,\ rcv_{2}),\ (1,\ rcv_{3}),\ \ldots))\\
\ldots \\
(e_n\ \rightarrow\ ((0,\ rcv_{4}),\ (1,\ rcv_{5}),\ \ldots))\\
\end{array}
\label{equation:rcv}
\end{equation}
The list in (\ref{equation:rcv}) keeps record of the receive commands uniquely identified by the endpoint $\mathit{e}_x$, where $x$ is the number of the endpoint. The integer in the first field of each pair represents the order of the receive command in which it appears for each endpoint. We use $I_r$ to denote the order. Note that the receive command with smaller $I_r$ should be served first in the program runtime. The receive command in the second field of the list is defined as a record $R$ in equation \ref{equation:record} of the previous section. The notations $\mathtt{rcv_{0}}$, $\mathtt{rcv_{1}}$, etc. represent the unique identifiers for the receives. For the sends in loops of the program, we can give them each unique identifies since we are looking at a complete program execution.
\begin{equation}
\footnotesize \begin{array}{l}
 ``dst" \;\;\;\; ``src" \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; ``src"\\
(e_0\ \rightarrow\ ((e_1\ \rightarrow\ ((0,\ snd_{0}),\ (1,\ snd_{1}),\ \ldots),\ (e_2\ \rightarrow\ (\ldots),\ \ldots))))\\
(e_1\ \rightarrow\ ((e_0\ \rightarrow\ ((0,\ snd_{2}),\ (1,\ snd_{3}),\ \ldots),\ (e_2\ \rightarrow\ (\ldots),\ \ldots))))\\
 \dots\\
(e_n\ \rightarrow\ ((e_0\ \rightarrow\ ((0,\ snd_{4}),\ (1,\ snd_{5}),\ \ldots),\ (e_1\ \rightarrow\ (\ldots),\ \ldots))))\\
\end{array}
\label{equation:snd}
\end{equation}
Also, we keep record of the send commands using the second list in (\ref{equation:snd}) that is uniquely identified by the destination endpoint $\mathit{e}_x$. Each sublist for the destination endpoint is uniquely identified by the source endpoint $\mathit{e}_y$. Similarly, the integer in the first field of each pair represents the order of the send command in the same task sending to an identical endpoint. We use $I_s$ to denote the order. Note that $I_s$ is ordered within each sublist. The send command in the second field of the list is defined as a record $S$ in equation \ref{equation:record} of the previous section. The notations $\mathtt{snd_{0}}$, $\mathtt{snd_{1}}$, etc. represent the unique identifiers for the sends. Also, the receives in loops are given unique identifies.

In our running example in \figref{fig:mcapi1}, we generate our receive list and send list in equation (\ref{equation:rcv_e}) and (\ref{equation:snd_e}), respectively.
\begin{equation}
\footnotesize \begin{array}{l}
(0\ \rightarrow\ ((0,\ rcvA),\ (1,\ rcvB),\ (2,\ rcvC)))\\
(1\ \rightarrow\ ((0,\ rcvD)))\\
\end{array}
\label{equation:rcv_e}
\end{equation}
\begin{equation}
\footnotesize \begin{array}{l}
(0\ \rightarrow\ ((1\ \rightarrow\ ((0,\ snd1),\ (1,\ snd2)),\ (2\ \rightarrow\ ((0,\ snd3))))))\\
(1\ \rightarrow\ ((0\ \rightarrow\ ((0,\ snd4)))))\\
\end{array}
\label{equation:snd_e}
\end{equation}
Note that \texttt{rcvA} is the first receive operation in endpoint 0, and \texttt{snd3} is the first send from the source endpoint 2 to the destination endpoint 0.

The second step for our algorithm is to linearly traverse both lists, and then apply the criteria below to each send command and receive command. Observe that the sends defined with an identical destination endpoint and an identical source endpoint are processed in a FIFO way in the program runtime. Also, the receive ordered first should be served first compared with those from an identical endpoint. Because of the fact of FIFO processing, a list of receives in the format of (\ref{equation:rcv}) and a sublist of sends in the format of (\ref{equation:snd}) with an identical endpoint can be determined how many matches there are from the sends to the receives by applying the following criteria:

For each receive command $\mathtt{rcv}$ in the list of (\ref{equation:rcv}) with order $I_r$ and each send command $\mathtt{snd}$ in the sublist of (\ref{equation:snd}) with order $I_s$, if $\mathtt{rcv}$ is matched with $\mathtt{snd}$, we have,
\begin{itemize}
\item[1.] the destination endpoint of $\mathtt{snd}$ is identical to the endpoint of $\mathtt{rcv}$;
\item[2.] $I_r \geq I_s$;
\item[3.] and $I_r \leq I_s + (N_s - n_s)$.
\end{itemize}
where $N_s$ is the number of the sends in the program, and $n_s$ is the number of the sends in the sublist where $\mathtt{snd}$ is resident. If all rules of the criteria are satisfied for a send and a receive, we build a match pair for the send and the receive in the result set. In our concrete example, \texttt{rcvA} is matched with \texttt{snd1} or \texttt{snd3}, but it can not be matched with \texttt{snd2} since the second rule is not satisfied such that the order for \texttt{rcvA} is less than the order of \texttt{snd2}. We repeat the step until we traverse all sends and receives. The generated set of match pairs for our example in \figref{fig:mcapi1} is imprecise such that some extra match pair, we call ``bogus", that can not exist in the real execution of program are included. In particular, the match pair $(\mathtt{snd3}\ \mathtt{rcvC})$ is a ``bogus" match pair. If we add this match pair, however, there is no way to order $\mathtt{snd2}$ happening before $\mathtt{rcvB}$ since $\mathtt{rcvD}$ should be matched with $\mathtt{snd4}$ which is ``blocked" by $\mathtt{rcvB}$. Fortunately, our encoding is strong enough to not consider that bad match pair in any satisfying solution.


Now let us analyze the time complexity to complete the algorithm. Traversing the tasks linearly takes $O(N)$ to complete, where $N$ is the total lines of code of the program. Traversing the list of receives and the list of sends takes $O(mn)$ to complete, where $m$ is the total number of sends and $n$ is the total number of receives. Note that $m + n < N$. Totally, the algorithm takes $O(N + mn) \approx O(N^2)$ to complete.

We apply the criteria to our algorithm discussed above in such a way that each ``bogus" match pair should be pruned if at least one of the rules is not satisfied. By setting the over-approximated set of match pairs as input to our solution, we then validate satisfying assignments from the SMT solver to see if they use only feasible match pairs. Such validation is accomplished by creating an ``oracle" - a model of the MCAPI library with full operational semantics. The model will reject a given trace that relies on bad match pairs, the operational semantics of which are presented in the long version of paperwork at (url??????????). The bad match pairs can then be omitted from the SMT encoding and the SMT solver re-run to see if another solution exists. The framework provides a \textit{CEGAR} loop for MCAPI trace verification.
