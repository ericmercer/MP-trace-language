\section{Result}
%In Section 4, we know that a well defined SMT problem can encode all possible execution traces for a CTP given a precise set of match pair. A precise set of match pair contains all possible match pairs that can exist in the real execution, and all match pairs that can not exist in the execution are not included. In other words, every hidden error can be found if it exists in some trace.
To evaluate the reliability and efficiency of our system, we compare our encoding with the work presented in \cite{elwakil:padtad10}.
The encoding in \cite{elwakil:padtad10} is not correct and misses valid program executions allowed by the MCAPI runtime. For example, it only finds one of the two possible traces from the example program used in this paper because the encoding does not allow an non-blocking send operations from different end points to be reordered. As such, the comparison in this paper is not exactly valid. Nevertheless, the encoding in this paper not only captures all non-deterministic behavior in the runtime, it is also a more efficient encoding.

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
    \hline
     & Program Order & Matches & Assume$\&$Assert & Extra Clauses\\
    \hline
    Our Encoding  & 11 & 4 & 2 & 0\\
    Encoding in \cite{elwakil:padtad10} & 22 & 13 & 3 & 8\\
    \hline
\end{tabular}
\end{center}
\caption{Comparison of two encodings for the MCAPI program in \figref{fig:mcapi}.}
\label{table:program}
\end{table}

For the program in \figref{fig:mcapi}, we encodes 17 clauses for modeling the problem, omitting the definition of variables at the beginning of the encoding. Based on the encoding rules in \cite{elwakil:padtad10}, however, there are 47 clauses for the same program, omitting the definitions as well. \tableref{table:program} shows the clause number for four parts of each encoding for the MCAPI program in \figref{fig:mcapi}. In particular, the program order covers most parts of each encoding. The program order and matches of the encoding in \cite{elwakil:padtad10} are 2-4 times larger than those in our encoding. Besides, the encoding in \cite{elwakil:padtad10} needs some extra clauses, including the variable assignments and assertion integration, that expand the entire encoding.

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
		\hline
         & Example in \figref{fig:mcapi} & small1	 &	small2 & small3 \\ \hline
        Our Encoding& 17 & 8 & 4 & 11 \\
        Encoding in \cite{elwakil:padtad10}& 46 & 33 & 18 & 44\\ \hline	
		\end{tabular}
\end{center}
\caption{Comparison of two encodings for four different MCAPI programs with clause number.}
\label{table:comparison}
\end{table}

Other than the program in \figref{fig:mcapi}, we manually generate three programs and provide the experimental result in \tableref{table:comparison}. Small1 is a program with two tasks, where two sends are in the first task, and two receives are in the second task. Small2 is a program with only one task, where one send and one receive are in this task. Small3 is a program with three tasks, where three sends are in the first task, two receives are in the second task, and one receive is in the third task. The number of clauses follows the performance of the SMT solver with fewer clauses leading to better runtime. The result in \tableref{table:comparison} is impressive because the number of our encoding is only $1/5~\sim~1/3$ of that of the encoding in \cite{elwakil:padtad10}. From those experimental results, an SMT solver can give a more efficient solution with our encoding for an identical MCAPI program.
%Elwakil et al. defined a similar order-based SMT encoding for the same problem.
%\begin{equation}
%F_R = F_{order}\wedge F_{asgn}\wedge F_{recv}\wedge F_{prp}
%\end{equation}
%The formula in Equation (5) represents the main construction of their encoding. Four sub-formulas mimic the transition relations of the CTP, where $F_{order}$ ensures the ordering of events, $F_{asgn}$ encodes the assignment actions, $F_{recv}$ ensures the matching of receive and send actions, and $F_{prp}$ encodes the assertion actions. Each sub-formula has some similar clause of our encoding. For example, $F_{order}$ in \cite{elwakil:padtad10} works like HB function in our encoding. At the mean time, however, their encoding is different from ours on some parts. For example, They keep a history of values of local variables while we do not.





 %To count the clause number of our encoding, we have the following rules: 1) there are $N-M$ HB clauses where $N$ is the total number of actions and $M$ is the number of thread; 2) there are $R+1$ MATCH clauses (some of them is a disjunction of several match pairs), where $R$ is the number of receive actions; 3) there are $A$ assignment and assertion clauses, where $A$ is the total number of assignment and assertion in the program. Compared with those in \cite{elwakil:padtad10}, our encoding has few clauses, and their encoding has more free variables and rules.







