\section{Result}
%In Section 4, we know that a well defined SMT problem can encode all possible execution traces for a CTP given a precise set of match pair. A precise set of match pair contains all possible match pairs that can exist in the real execution, and all match pairs that can not exist in the execution are not included. In other words, every hidden error can be found if it exists in some trace.
To evaluate the reliability and efficiency of our system, we compare our encoding with the work presented in \cite{elwakil:padtad10}.
The encoding in \cite{elwakil:padtad10} can handle most regular scenarios of CTP and some errors can be found if such traces are modeled. However, It can not always guarantee of finding all hidden errors since the modeling is sometimes incorrect for a specific CTP. By applying the technique in \cite{elwakil:padtad10} to the program in \figref{fig:mcapi}, not both execution traces that we have done in \figref{fig:smts} can be modeled. Actually, the encoding in \cite{elwakil:padtad10} can only model a single trace that matches $snd1$ with $rcvA$, followed by matching $send2$ with $rcvC$, etc. The main reason for the incorrectly encoding is that the encoding technique in \cite{elwakil:padtad10} requires $snd1$ to happen before $rcvB$ and no other candidate send operations for $rcvB$ to happen after $snd1$. For our encoding technique, however, we make it flexible that a non-blocking send operation can match a receive action even if some other sends happen before the receive action. As a result, our encoding can correctly model non-deterministic behavior of a concurrent program.
%Elwakil et al. defined a similar order-based SMT encoding for the same problem.
%\begin{equation}
%F_R = F_{order}\wedge F_{asgn}\wedge F_{recv}\wedge F_{prp}
%\end{equation}
%The formula in Equation (5) represents the main construction of their encoding. Four sub-formulas mimic the transition relations of the CTP, where $F_{order}$ ensures the ordering of events, $F_{asgn}$ encodes the assignment actions, $F_{recv}$ ensures the matching of receive and send actions, and $F_{prp}$ encodes the assertion actions. Each sub-formula has some similar clause of our encoding. For example, $F_{order}$ in \cite{elwakil:padtad10} works like HB function in our encoding. At the mean time, however, their encoding is different from ours on some parts. For example, They keep a history of values of local variables while we do not.

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
		\hline
        CTP & Example in \figref{fig:mcapi} & small1	 &	small2 & small3 \\ \hline
        Our Encoding& 17 & 8 & 4 & 11 \\
        Encoding in \cite{elwakil:padtad10}& 47 & 33 & 18 & 44\\ \hline	
		\end{tabular}
\end{center}
\caption{Comparison of two encodings}
\label{table:comparison}
\end{table}

Despite the correctness of our encoding, our encoding is more efficient by comparing the number of the clauses of the encoding itself. %To count the clause number of our encoding, we have the following rules: 1) there are $N-M$ HB clauses where $N$ is the total number of actions and $M$ is the number of thread; 2) there are $R+1$ MATCH clauses (some of them is a disjunction of several match pairs), where $R$ is the number of receive actions; 3) there are $A$ assignment and assertion clauses, where $A$ is the total number of assignment and assertion in the program. Compared with those in \cite{elwakil:padtad10}, our encoding has few clauses, and their encoding has more free variables and rules. 
For the program in \figref{fig:mcapi}, we encodes 17 clauses for modeling the problem, omitting the definition of variables at the beginning of the encoding. Based on the encoding rules in \cite{elwakil:padtad10}, however, there are 47 clauses for the same program, omitting the definitions as well. Other than the program in \figref{fig:mcapi}, we manually generate three programs and provide the experimental result in \tableref{table:comparison}. Reducing the clause number means a large improvement of efficiency. The result in \tableref{table:comparison} is impressive because the number of our encoding is only $1/5~\sim~1/3$ of that of the encoding in \cite{elwakil:padtad10}. Thus, we encode more efficient SMT problem for an identical concurrent program.






