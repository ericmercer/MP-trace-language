\section{Experiments and Results}
%In Section 4, we know that a well defined SMT problem can encode all possible execution traces for a CTP given a precise set of match pair. A precise set of match pair contains all possible match pairs that can exist in the real execution, and all match pairs that can not exist in the execution are not included. In other words, every hidden error can be found if it exists in some trace.
We used the MCA provided reference solution to generate MCAPI program traces. The reference solution uses the \textit{PThread} library to create multiple MCAPI tasks. Our tool takes the trace as input, computes the match-pair set, and outputs the trace encoding. We use the Z3 SMT solver \cite{demoura:tacas08} to check the satisfiability of the generated SMT encoding. In all tests, the correctness properties are numerical assertions over variables. The experiments are conducted on a PC with a 2.40 GHz Intel Quad Core processor and 8 GB memory running Ubuntu 14.

We launched two series of experiments under \textit{infinite-buffer} semantics. In the first series of experiments, we compare the performance of a program with different sizes of match pairs. We manually generate an MCAPI program where a receiver(Task 0) and fifty senders(Task 1 to Task 50) are created. Each sender sends a message to the receiver. The receiver finally issues an assert that the message from Task 50 is sent to the buffer of the last receive operation of Task 0. Under this scenario, the set of match pairs consists of every combination of a send in task 1 to task 50 and a receive in task 0. We call this precise set of match pairs under this scenario the \textit{Worst-Case} of fifty-message program, which provides a huge sum of non-deterministic behaviors of program executions. Given the \textit{Worst-Case}, we then reduce the size of match pairs gradually only ensuring that the match pair of the send in Task 50 and the last receive in Task 0 exists so that the assert can be checked. As such, we can further discuss how the size of match pairs change the performance of a program.

\begin{table}
\begin{center}
\scriptsize
\begin{tabular}{|c|c|c|}
		\hline
         \multicolumn{1}{|c|}{Test Programs} & \multicolumn{2}{|c|}{Performance} \\ \hline
          Choices &  Time(s) & Memory(MB) \\ \hline
          2! &  0.040 & 4.87 \\
          10! &  0.090 & 7.82 \\
          16! &  0.160 & 9.96 \\
          17! &  24.650 & 30.44 \\
          18! &  27.110 & 28.40 \\
         20! &  41.800 & 34.20 \\
         28! &  138.130 & 54.74 \\
         32! &  211.270 & 65.57 \\
          40! &  504.960 & 83.19 \\
          50! &  947.160 & 105.29 \\
         \hline
		\end{tabular}
\end{center}
\caption{Comparison of the encodings for an MCAPI program with different settings of match pairs}
\label{table:first}
\end{table}

\tableref{table:first} shows the comparison of our encodings for a specific example with different settings of match pairs. The first column presents the number of runtime choices to resolve the non-determinism. The next two columns show the performance of each encoding, including the running time and the memory usage to solve the encoding. Observe that the running time and the memory usage are increased with the number of match pairs. Also, we can see from the second column that Z3 handles 800 match pairs much better than 850 match pairs by evaluating the running time. From the results above, it is obvious that the size of match pairs is extremely important for the performance of an encoding. Note that the \textit{Worst-Case} in the last row hardly exists in practice. Thus, a soundly precise set of match pairs leads to better performance. This conclusion also attracts our attention on developing a more efficient method of generating match pairs in future work.


\begin{table}
\begin{center}
\scriptsize
\begin{tabular}{|l|c|c||c|c|c|c|}
		\hline
         \multicolumn{3}{|c||}{Test Programs} & \multicolumn{4}{|c|}{Performance} \\ \hline
         Name & \# Mesg & Choices & EG(s) & MG(s) & Time(s) & Memory(MB) \\ \hline
         \textit{LE} & 220 &  & 0.390 & 0.016 &  &  \\
         \textit{Router} &  &  &  &  &  &  \\
         \textit{Multi} & 100 &  & 0.632 & 0.436 &  1006.49 & 135.19  \\
         \textit{pktuse} & 512 & 45056(?) & 10.190 & 9.088 & 7569.840 & 1539.90 \\
         \hline
		\end{tabular}
\end{center}
\caption{Comparison of the encodings for four examples}
\label{table:second}
\end{table}
We launch the second series of experiments in order to evaluate our encoding strategy for verifying problems in message passing applications. The first program, we call ``Leader Election", basically elects a leader from several candidates by message passing. The second program implements a simple router algorithm that each node sends multiple messages to the previous and the next node respectively for updating its routing table. This process does not end until all the routing tables are updated. The third program extends the example in \figref{fig:mcapi1} such that extra iterations are added to the original program execution to generate longer execution trace. The last program \textit{Pktuse} is from the benchmark \cite{mpptest_benchmark} that each of the five tasks randomly sends several messages to other tasks.

\tableref{table:second} shows the results of running our encodings. Other than the metrics used in \tableref{table:first}, we add the time of generating the encoding and the match pairs in the third and fourth column respectively. Note that the time shown in the third column includes the time in the fourth column. It is noticeable that the program \textit{OSU\_bw}, \textit{OSU\_latency} and \textit{MPP\_cluster} have very small cost of generating the match pairs. This is because their size of match pairs are equivalent to their number of messages, which implies less non-deterministic behaviors. In contrast, the program \textit{MPP\_pktuse} uses most time to generate the match pairs. As a result, more non-deterministic behaviors are distributed leading to extremely long running time and large memory usage of solving the encoding, even though the number of messages is smaller than those of other examples.

By comparing the performance of diverse encodings on two series of experiments shown above, our encoding is demonstrated that the size of match pairs determines the ``complexity" of a program execution. Also, our encoding scales well for programs with large messages if the number of match pairs is acceptable.

