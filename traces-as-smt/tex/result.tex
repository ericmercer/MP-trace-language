\section{Result} 
In Section 4, we know that a well defined SMT problem can encode all possible execution traces for a CTP given a precise set of match pair. A precise set of match pair contains all possible match pairs that can exist in the real execution, and all match pairs that can not exist in the execution are not included. In other words, every hidden error can be found if it exists in some trace. To evaluate the reliability and efficiency of our system, we compare our encoding with the work presented in \cite{elwakil:padtad10}.

Elwakil et al. defined a similar order-based SMT encoding for the same problem.
\begin{equation}
F_R = F_{order}\wedge F_{asgn}\wedge F_{recv}\wedge F_{prp}
\end{equation}
The formula in Equation (5) represents the main construction of their encoding. Four sub-formulas mimic the transition relations of the CTP, where $F_{order}$ ensures the ordering of events, $F_{asgn}$ encodes the assignment actions, $F_{recv}$ ensures the matching of receive and send actions, and $F_{prp}$ encodes the assertion actions. Each sub-formula has some similar clause of our encoding. For example, $F_{order}$ in \cite{elwakil:padtad10} works like HB function in our encoding. At the mean time, however, their encoding is different from ours on some parts. For example, They keep a history of values of local variables while we do not.

Their encoding can handle most regular scenarios of CTP and some errors can be found if such traces are modeled. However, It can not always guarantee of finding all hidden errors since the modeling is sometimes incorrect for a specific CTP. We have presented an example in the previous section. By applying the technique in \cite{elwakil:padtad10} to this example, we can not model two execution traces that we have done so in the previous section. Actually, we can only model a trace that assigns ``4" to ``a". The other trace can not be modeled, since the encoding in \cite{elwakil:padtad10} requires $snd1$ happening before $rcvB$ and no other candidate send operations for $rcvB$ happens after $snd1$. If we change the assertion in line $13$ of the CTP to $(assert\ (=\ a\ ``Go"))$, we can not find the error in the second trace. In our encoding, however, we have made it flexible that a non-blocking send operation can match a receive action even if some other sends happen before the receive action. So, our encoding can correctly model different traces.

An important measurement of efficiency for solving an SMT problem is to measure the ``size" of the SMT encoding, one way of which is to count the numbers of the clauses that construct the encoding. To count the clause number of our encoding, we have the following rules: 1) there are $N-M$ HB clauses where $N$ is the total number of actions and $M$ is the number of thread; 2) there are $R+1$ MATCH clauses (some of them is a disjunction of several match pairs), where $R$ is the number of receive actions; 3) there are $A$ assignment and assertion clauses, where $A$ is the total number of assignment and assertion in the program. Compared with those in \cite{elwakil:padtad10}, our encoding has few clauses, and their encoding has more free variables and rules.

For the example in the previous section, we encodes 17 clauses for modeling the problem, omitting the definition of variables at the beginning of the encoding. Based on their encoding rules, however, there are 47 clauses for the same problem, omitting the definitions as well. Reducing the clause number means a large improvement of efficiency. Thus, our encoding can be executed faster given an SMT solver.
