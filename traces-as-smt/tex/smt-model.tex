\newcommand{\epsnd}{\textit{Pnd\_s}}
\newcommand{\eprcv}{\textit{Pnd\_r}}
\newcommand{\qset}{\textit{Q\_s}}
\newcommand{\snd}{\textit{snd}}
\newcommand{\rcv}{\textit{rcv}}
\newcommand{\q}{\textit{q}}
\newcommand{\frm}{\textit{frm}}
\newcommand{\vbot}{\textit{v$-\bot$}}
\newcommand{\status}{\textit{s}}
\newcommand{\last}{\textit{l}}
\newcommand{\error}{\ensuremath{\mathbf{error}}}
\newcommand{\aidmap}{\textit{A}}
\newcommand{\thread}{\ensuremath{\mathit{t}}}
\newcommand{\aid}{\ensuremath{\mathit{a}}}
\newcommand{\ploc}{\ensuremath{\rho}}
\newcommand{\loc}{\ensuremath{\mathit{l}}}
\newcommand{\cmd}{\ensuremath{\mathit{c}}}
\newcommand{\op}{\ensuremath{\mathit{op}}}
\newcommand{\applyop}{\ensuremath{\mathrm{op}}}
\newcommand{\wait}{\ensuremath{\mathbf{wait}}}
\newcommand{\sendi}{\ensuremath{\mathbf{sndi}}}
\newcommand{\recvi}{\ensuremath{\mathbf{rcvi}}}
\newcommand{\traceentry}{\ensuremath{\sigma}}
\newcommand{\movelist}{\ensuremath{\delta}}
\newcommand{\assume}{\ensuremath{\mathit{assume}}}
\newcommand{\checkassume}{\ensuremath{\mathrm{assume}}}
\newcommand{\assert}{\ensuremath{\mathit{assert}}}
\newcommand{\checkassert}{\ensuremath{\mathrm{assert}}}
\newcommand{\ep}{\ensuremath{\mathbf{\gamma}}}
\newcommand{\src}{\ensuremath{\alpha}}
\newcommand{\dst}{\ensuremath{\beta}}
\newcommand{\true}{\ensuremath{\mathbf{true}}}
\newcommand{\false}{\ensuremath{\mathbf{false}}}
\newcommand{\match}{\ensuremath{\mathrm{m}}}
\newcommand{\matchl}{\ensuremath{\mathrm{match}}}
\newcommand{\findrecv}{\ensuremath{\mathrm{search_r}}}
\newcommand{\smt}{\ensuremath{\mathit{smt}}}


\newcommand{\addsend}{\ensuremath{\mathrm{addsend}}}
\newcommand{\getsend}{\ensuremath{\mathrm{getsend}}}
\newcommand{\removesend}{\ensuremath{\mathrm{removesend}}}
\newcommand{\addrecv}{\ensuremath{\mathrm{addrecv}}}
\newcommand{\getrecv}{\ensuremath{\mathrm{getrecv}}}
\newcommand{\removerecv}{\ensuremath{\mathrm{removefrecv}}}
\newcommand{\hextend}{\ensuremath{\mathrm{hextend}}}
\newcommand{\hlookup}{\ensuremath{\mathrm{hlookup}}}
\newcommand{\etalookup}{\ensuremath{\mathrm{etalookup}}}
\newcommand{\checkmatch}{\ensuremath{\mathrm{checkmatch}}}
\newcommand{\getep}{\ensuremath{\mathrm{getEP}}}
\newcommand{\getmarkremove}{\ensuremath{\mathrm{getMarkRemove}}}
\newcommand{\getlastsendreplace}{\ensuremath{\mathrm{getlastsend/replace}}}
\newcommand{\statuschange}{\left\{ \begin{array}{ll}  \status &\ \mathrm{if}\ |\epsnd(\dst)(\src)|>0\\
   \mathit{error} &\  \mathrm{otherwise}\end{array}\right .}

\newcommand{\reduce}[1]{\ensuremath{\rightarrow_{#1}}}
% Multiple reductions
\newcommand{\reduceK}[1]{\ensuremath{\rightarrow_{#1}^{*}}}
% Non-deterministic reductions
\newcommand{\reduceN}[1]{\ensuremath{\dashrightarrow_{#1}}}
\newcommand{\reduceNK}[1]{\ensuremath{\dashrightarrow_{#1}^{*}}}
\newcommand{\mt}{\ensuremath{\emptyset}}
\newcommand{\trace}{\ensuremath{\mathit{trace}}}
\newcommand{\movebot}{\ensuremath{\mathit{m}}}
\newcommand{\ret}{\ensuremath{\mathbf{ret}}}

\newcommand{\defs}{\ensuremath{\mathrm{defs}}}
\newcommand{\any}{\ensuremath{\mathrm{any}}}
\newcommand{\negate}{\ensuremath{\mathrm{not}}}
\newcommand{\define}{\ensuremath{\mathrm{define}}}
\newcommand{\andd}{\ensuremath{\mathrm{and}}}
\newcommand{\select}{\ensuremath{\mathrm{select}}}
\newcommand{\HB}{\ensuremath{\mathrm{HB}}}
\newcommand{\getlast}{\ensuremath{\mathrm{last}}}
\newcommand{\MATCH}{\ensuremath{\mathrm{MATCH}}}
\newcommand{\ml}{\ensuremath{\mathit{ML}}}
\newcommand{\matchpair}{\ensuremath{\mathrm{MP}}}
\newcommand{\recv}{\ensuremath{\mathrm{\mu}}}
\newcommand{\send}{\ensuremath{\mathrm{\nu}}}



\newsavebox{\boxSMTa}
\begin{lrbox}{\boxSMTa}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 (HB $\mathtt{R_{0,2}}$.event $\mathtt{W(\&h1)}$.event)}\\
\texttt{01 (HB $\mathtt{W(\&h1)}$.event $\mathtt{R_{0,5}}$.event)}\\
\texttt{02 (HB $\mathtt{R_{0,5}}$.event $\mathtt{W(\&h2)}$.event)}\\
\texttt{03 (HB $\mathtt{W(\&h2)}$.event assume.event)}\\
\texttt{04 (HB assume.event assert.event)}\\
\texttt{05 (HB $\mathtt{R_{1,3}}$.event $\mathtt{W(\&h3)}$.event)}\\
\texttt{06 (HB $\mathtt{W(\&h3)}$.event $\mathtt{S_{1,5}}$.event)}\\
\texttt{07 (HB $\mathtt{S_{1,5}}$.event $\mathtt{W(\&h4)}$.event)}\\
\texttt{08 (HB $\mathtt{S_{2,4}}$.event $\mathtt{W(\&h5)}$.event)}\\
\texttt{09 (HB $\mathtt{W(\&h5)}$.event $\mathtt{S_{2,7}}$.event)}\\
\texttt{10 (HB $\mathtt{S_{2,7}}$.event $\mathtt{W(\&h6)}$.event)}\\
\texttt{11 (assert (> b 0))}\\
\texttt{12 (assert (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{13 (MATCH $\mathtt{R_{0,2}}$ $\mathtt{S_{2,4}}$)}\\
\texttt{14 (MATCH $\mathtt{R_{0,5}}$ $\mathtt{S_{1,5}}$)}\\
\texttt{15 (MATCH $\mathtt{R_{1,3}}$ $\mathtt{S_{2,7}}$)}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTb}
\begin{lrbox}{\boxSMTb}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 (HB $\mathtt{R_{0,2}}$.event $\mathtt{W(\&h1)}$.event)}\\
\texttt{01 (HB $\mathtt{W(\&h1)}$.event $\mathtt{R_{0,5}}$.event)}\\
\texttt{02 (HB $\mathtt{R_{0,5}}$.event $\mathtt{W(\&h2)}$.event)}\\
\texttt{03 (HB $\mathtt{W(\&h2)}$.event assume.event)}\\
\texttt{04 (HB assume.event assert.event)}\\
\texttt{05 (HB $\mathtt{R_{1,3}}$.event $\mathtt{W(\&h3)}$.event)}\\
\texttt{06 (HB $\mathtt{W(\&h3)}$.event $\mathtt{S_{1,5}}$.event)}\\
\texttt{07 (HB $\mathtt{S_{1,5}}$.event $\mathtt{W(\&h4)}$.event)}\\
\texttt{08 (HB $\mathtt{S_{2,4}}$.event $\mathtt{W(\&h5)}$.event)}\\
\texttt{09 (HB $\mathtt{W(\&h5)}$.event $\mathtt{S_{2,7}}$.event)}\\
\texttt{10 (HB $\mathtt{S_{2,7}}$.event $\mathtt{W(\&h6)}$.event)}\\
\texttt{11 (assert (> b 0))}\\
\texttt{12 (assert (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{13 (MATCH $\mathtt{R_{0,2}}$ $\mathtt{S_{1,5}}$)}\\
\texttt{14 (MATCH $\mathtt{R_{0,5}}$ $\mathtt{S_{2,4}}$)}\\
\texttt{15 (MATCH $\mathtt{R_{1,3}}$ $\mathtt{S_{2,7}}$)}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTc}
\begin{lrbox}{\boxSMTc}
\normalsize
\begin{tabular}[t]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 (HB $\mathtt{R_{0,2}}$.event $\mathtt{W(\&h1)}$.event)}\\
\texttt{01 (HB $\mathtt{W(\&h1)}$.event $\mathtt{R_{0,5}}$.event)}\\
\texttt{02 (HB $\mathtt{R_{0,5}}$.event $\mathtt{W(\&h2)}$.event)}\\
\texttt{03 (HB $\mathtt{W(\&h2)}$.event assume.event)}\\
\texttt{04 (HB assume.event assert.event)}\\
\texttt{05 (HB $\mathtt{R_{1,3}}$.event $\mathtt{W(\&h3)}$.event)}\\
\texttt{06 (HB $\mathtt{W(\&h3)}$.event $\mathtt{S_{1,5}}$.event)}\\
\texttt{07 (HB $\mathtt{S_{1,5}}$.event $\mathtt{W(\&h4)}$.event)}\\
\texttt{08 (HB $\mathtt{S_{2,4}}$.event $\mathtt{W(\&h5)}$.event)}\\
\texttt{09 (HB $\mathtt{W(\&h5)}$.event $\mathtt{S_{2,7}}$.event)}\\
\texttt{10 (HB $\mathtt{S_{2,7}}$.event $\mathtt{W(\&h6)}$.event)}\\
\texttt{11 (assert (> b 0))}\\
\texttt{12 (assert (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{13} (\texttt{or} (\texttt{MATCH} $\mathtt{R_{0,2}}$ $\mathtt{S_{2,4}}$)\\
\texttt{14}     (\texttt{MATCH} $\mathtt{R_{0,2}}$ $\mathtt{S_{1,5}}$))\\
\texttt{15} (\texttt{or} (\texttt{MATCH} $\mathtt{R_{0,5}}$ $\mathtt{S_{2,4}}$)\\
\texttt{16}     (\texttt{MATCH} $\mathtt{R_{0,5}}$ $\mathtt{S_{1,5}}$))\\
\texttt{17} (\texttt{MATCH} $\mathtt{R_{1,3}}$ $\mathtt{S_{2,7}}$)\\
\texttt{18} (\texttt{NE} $\mathtt{R_{0,2}}$ $\mathtt{R_{0,5}}$)\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxMP}
\begin{lrbox}{\boxMP}
\normalsize
\begin{tabular}[t]{l}
\\\\\\\\\\\\\\\\\\
($\mathtt{R_{0,2}}$ $\mathtt{S_{2,4}}$)\\
($\mathtt{R_{0,2}}$ $\mathtt{S_{1,5}}$)\\
\\
($\mathtt{R_{0,5}}$ $\mathtt{S_{2,4}}$)\\
($\mathtt{R_{0,5}}$ $\mathtt{S_{1,5}}$)\\
\\
($\mathtt{R_{1,3}}$ $\mathtt{S_{2,7}}$)\\
\end{tabular}
\end{lrbox}




\section{SMT Model}\label{sec:smt}

%The next step, after formally defining the operational semantics of our trace
%language, is to formally define a translation from the trace language into an
%SMT problem that can correctly models the original execution trace.

The novelty of the SMT encoding in this paper is its use of match pairs rather than the state-based or order-based encoding of prior work~\cite{elwakil:padtad10,elwakil:atva10}. The algorithm to create the encoding takes as input a set of possible match pairs and a trace through an MCAPI program with the appropriate assumes and asserts as shown in \figref{fig:trace}. A match pair is the coupling of a receive to a particular send. \figref{fig:smt}(a) is the set of possible match pairs for the program in \figref{fig:mcapi} using our shorthand notation defined in \figref{fig:trace}. The set admits, for example, that $\mathtt{R_{0,2}}$ can be matched with either $\mathtt{S_{1,5}}$ or $\mathtt{S_{2,4}}$. The SMT encoding in this paper asks the SMT solver to resolve the match pairs for the system in such a way that the final values of program variables meet the assumption on control flow but violate some assertion.

Before presenting our SMT encoding for a specific example, we need to explain auxiliary data structures and support functions in detail. We give the definitions in the Yices \cite{dutertre:CAV06} input language.

% (define HB::(-> a::int b::int (subtype (c::bool) (ite (< a b) (= c true) (= c false)))))
\begin{equation}
\begin{array}{l}
(\cfgt{define}\ \mathtt{HB}::(\rightarrow\ \cfgnt{a::int}\ \cfgnt{b::int}\\
\ \ \ (\cfgt{subtype}\ \cfgnt{(c::bool)}\ (\mathrm{ite}\ (<\ \mathit{a}\ \mathit{b})\ (=\ \mathit{c}\ \mathrm{true})\ (=\ \mathit{c}\ \mathrm{false})))))
\end{array}
\label{equation:hb}
\end{equation}

%\begin{equation}
%\mathrm{HB}(a,b) \equiv \left\{ \begin{array}{rl}
%  \mathit{true} & \mathrm{if}\ a < b \\
%  \mathit{false} & \mathrm{otherwise}\
%\end{array}
%\right .
%\end{equation}

The \texttt{HB} function in equation (\ref{equation:hb}) creates a happens-before relationship between two events. The notation $``\mathrm{ite}"$ refers to a condition statement such that if the condition is satisfied, then the first subclause is true; otherwise, the second subclause is true. The function takes two events $a$ and $b$ as parameters, such that $a,b \in \mathbb{N}$, where $\mathbb{N}$ is the set of natural numbers. In our SMT encoding, every location in an execution trace is assigned an event, and the \texttt{HB} function orders those locations (i.e., program order, etc.). This function creates a constraint such that the first event must be less than the second event, indicating that the first event occurs before the second event. For example, action $a$ happens before $b$ if and only if $\mathit{event}_a$ for $a$ is greater than $\mathit{event}_b$ for $b$. This function is not only used to assert the program order of statements within the same thread, but also to assert, for any matched pair, that the send operation
occurs before the receive.

\begin{equation}
\begin{array}{l}
%(define-type recv (record match::int e::int var::int event::int))
(\cfgt{define-type}\ \texttt{R}\ (\cfgt{record}\ \cfgnt{M::int}\ \cfgnt{e::int}\ \cfgnt{value::int}\ \cfgnt{event::int})) \\
%(define-type send (record match_po::int id::int e::int value::int event::int))
(\cfgt{define-type}\ \texttt{S}\ (\cfgt{record}\ \cfgnt{O::int}\ \cfgnt{ID::int}\ \cfgnt{e::int}\ \cfgnt{value::int}\ \cfgnt{event::int}))
\end{array}
\label{equation:record}
\end{equation}
%\[R = (M\ \ep_r\ x\ \ploc_r)\]
%\[S = (\mathit{MP}\ \mathit{ID}\ \ep_s\ e\ \ploc_s)\]

We define two records in equation (\ref{equation:record}) that are essential to encoding our SMT problem. The first record \texttt{R} defined above represents a receive action such that $\mathit{M}$, $\mathit{e}$, $\mathit{value}$, $\mathit{event} \in \mathbb{N}$. $\mathit{M}$ represents a variable that is assigned the $\mathit{event}$ field of the matched record \texttt{S}. $\mathit{e}$ is the endpoint of the receive action \texttt{R}, $\mathit{value}$ represents a value received by the receive operation, and $\mathit{event}$ is the event term which indicates the program order of the receive action \texttt{R}. The second record \texttt{S} defined above is a send action such that $\mathit{O}$, $\mathit{ID}$, $\mathit{e}$, $\mathit{value}$, $\mathit{event} \in \mathbb{N}$. The fields $\mathit{e}$ and $\mathit{event}$, as those in tuple \texttt{R}, are the destination endpoint and event term, respectively. The field $\mathit{value}$ is the value being sent. $\mathit{O}$ is a variable used for match pairs, and it is assigned an event term of a receive operation if the receive operation is to be matched to the send operation. $\mathit{ID}$ is a unique number that identifies each send operation. Note that the integer value assigned to $\mathit{event}$ indicates the program order. Also, we use two match variables, $M$ and $\mathit{O}$, for different purposes. $M$ is used for preventing two receive operations from being matched with the same send operation. $\mathit{O}$ is used for ordering two receive operations with respect to the program order of two matched send operations. The SMT solver must assign the $\mathit{M}$ and $\mathit{event}$ fields of the send tuple, and it must assign the $\mathit{event}$, $\mathit{M}$, and $\mathit{value}$ fields of the receive tuple in a way that is consistent with all the constraints in the encoding.

%(define MATCH::(-> r::recv s::send (subtype (c::bool) (ite
 % (and (= (select r ep) (select s ep))
 %      (= (select r var) (select s value))
  %     (HB (select s event) (select r event))
   %    (= (select r match) (select s id))
%       (= (select s match_po) (select r event)))%
% (= c true)
% (= c false)))))

\begin{equation}
\begin{array}{l}
(\cfgt{define}\ \mathtt{MATCH}::(\rightarrow\ \cfgnt{r::}\texttt{R}\ \cfgnt{s::}\texttt{S}\ (\cfgt{subtype}\ \cfgnt{(c::bool)}\ (\cfgnt{ite} \\
\ \ \ (\mathrm{and}\ (=\ (\mathrm{select}\ \mathit{r}\ \mathit{e})\ (\mathrm{select}\ \mathit{s}\ \mathit{e})) \\
\ \ \ \ \     (=\ (\mathrm{select}\ \mathit{r}\ \mathit{value})\ (\mathrm{select}\ \mathit{s}\ \mathit{value})) \\
\ \ \ \ \    (\mathrm{HB}\ (\mathrm{select}\ \mathit{s}\ \mathit{event})\ (\mathrm{select}\ \mathit{r}\ \mathit{event})) \\
\ \ \ \ \    (=\ (\mathrm{select}\ \mathit{r}\ \mathit{M})\ (\mathrm{select}\ \mathit{s}\ \mathit{ID})) \\
\ \ \ \ \    (=\ (\mathrm{select}\ \mathit{s}\ \mathit{O})\ (\mathrm{select}\ \mathit{r}\ \mathit{event}))) \\
\ \ \  (=\ \mathit{c}\ \mathrm{true}) \\
\ \ \  (=\ \mathit{c}\ \mathrm{false})))))
\end{array}
\label{equation:match}
\end{equation}
%\begin{equation}
%\mathrm{MATCH}(R,S) \equiv \left\{
%\begin{array}{ll}
%  \mathit{true} & \mathrm{if}\ M = \mathit{ID}~\wedge \\
%  & \ep_r = \ep_s~\wedge \\
%  & x = e~\wedge \\
%  & \mathrm{HB}(\ploc_s,\ploc_r)~\wedge \\
%  & \mathit{MP}_r = \ep_r \\
%  \mathit{false} & \mathrm{otherwise}\
%\end{array}
%\right . \\
%\end{equation}

The $\mathtt{MATCH}$ function in equation (\ref{equation:match}) takes tuples \texttt{R} and \texttt{S} as parameters. Each $``\mathrm{select}"$ statement selects a field of tuple \texttt{R} or \texttt{S}. The function creates a number of constraints that represent the pairing
of the specified send and receive operations. This function asserts that the
destination endpoint of the send operation is the same as the endpoint used by
the receive operation, that the value sent by the send operation is the same
value received by the receive operation, that the send operation occurs before
the receive operation, that the ``match'' value ($\cfgnt{M}$) in the receive tuple is
equal to the ``$\cfgnt{ID}$'' value in the send tuple, and that the ``$\cfgnt{O}$" value in the send tuple is equal to the ``$\cfgnt{event}$" value in the receive tuple. Note that the encoding is going to use the ``$\cfgnt{O}$"  value in conjunction with the \texttt{HB} function to enforce message non-overtaking when messages are sent from the same endpoint. Consider a simple example below that sends two messages from a Task 0 to Task 1,
\[
\begin{array}{l|l}
\;\;\;\;\;\;\;\;\mathtt{Task\ 0}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{Task\ 1}\;\;\;\;\;\;\;\; \\
\hline
\;\;\;\;\;\;\;\;\mathtt{S_{0,1}(1,\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,1}(*,\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{S_{0,2}(1,\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,2}(*,\&h4)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h4)}\;\;\;\;\;\;\;\; \\
\end{array}
\]
The ``$\cfgnt{O}$" values in the send records will be assigned to the order tracking events for $\mathtt{R_{1,1}}$ and $\mathtt{R_{1,2}}$ in the final encoding. Message non-overtaking from transactions on common endpoints is encoded by forcing the send events to be received in program order using the \texttt{HB} function as below in our simple example:
\[(\mathtt{HB}\ (\cfgnt{select}\ \mathtt{S_{0,1}}\ \cfgnt{O})\ (\cfgnt{select}\ \mathtt{S_{0,2}}\ \cfgnt{O}))\]


\begin{equation}
\begin{array}{l}
(\cfgt{define}\ \mathtt{NE}::(\rightarrow\ \cfgnt{r1::}\texttt{R}\ \cfgnt{r2::}\texttt{R}\ (\cfgt{subtype}\ \cfgnt{(c::bool)}\ (\cfgnt{ite} \\
\ \ (=\ (\mathrm{select}\ \mathit{r1}\ \mathit{M})\ (\mathrm{select}\ \mathit{r2}\ \mathit{M})) \\
\ \ (=\ \mathit{c}\ \mathrm{false}) \\
\ \ (=\ \mathit{c}\ \mathrm{true})))))
\end{array}
\label{equation:ne}
\end{equation}

%\begin{equation}
%\mathrm{ne}(a,b) \equiv \left\{ \begin{array}{rl}
%  \mathit{true} & \mathrm{if}\ M_a \not = M_b \\
%  \mathit{false} & \mathrm{otherwise}\
%\end{array}
%\right .
%\end{equation}

The $\mathtt{NE}$ function in equation (\ref{equation:ne}) is used to assert that no two receive operations are matched
with the same send operation. The parameters for this function are two receive
tuples. An assertion is made that the values of their ``match'' fields, $\cfgnt{M}$,
are not equal. This shows that they are paired with two different send
operations.

Prior SMT models of MCAPI program executions implicitly compute
match pairs by adding possible happens-before relations on sends and
receives with the conditions under which those orderings are
valid. The SMT solver is then asked to resolve the happens-before
relation by choosing specific orders of sends and receives. Match pair
encoding, as presented in this work, though it has the same
computational complexity as order based encoding (you still need to
figure out match pairs on endpoints), is simpler to reason about
directly rather than implicitly through orders, results in
significantly fewer terms in the SMT problem, and does not restrict out possible matches that exist under infinite-buffer semantics.

The presentation of the SMT encoding is structured as
\[\mathit{smt}\ =\ (\mathit{defs}\ \mathit{constraints}\ \mathit{match})\]
where the field $\mathit{defs}$ represents all definitions of the send, receive operations and the variables; The field $\mathit{constraints}$ represents all constraint clauses, including the assert clauses and the clauses built by the \texttt{HB} functions; and the field $\mathit{match}$ represents the clauses built by the \texttt{MATCH} function on a set of match pairs and the \texttt{NE} function. %We use $\mathit{match}.\mathit{input}$ to represent the input set of match pairs.

The input for generating the SMT encoding is an execution trace of an MCAPI program together with a set of match pairs. The first trace in \figref{fig:trace} with the set of match pairs in \figref{fig:smt}(a) is such an example. Given an input, the algorithm for generating our encoding is enumerated as follows. For convenience, we use the notation ``\texttt{.event}" following each command to represent the \textit{event} field in our encoding.
\begin{enumerate}
\item create event variables for every location in the execution trace. Further create send and receive records for all appropriate locations in the trace. Put these in the $\mathit{def}$ section;
\item for each assume, add a statement to $\mathit{constraints}$, and for each assert, add a negated assert to $\mathit{constraints}$;
\item add \texttt{HB} relations in \textit{constraints} to assert program order in each thread in the  event variables;
\item in the \textit{match} section, add \texttt{MATCH} clauses for the input send and receive pairs. If a receive can match on multiple sends, then inclose each possible match for that receive in a disjunct.
\item for two sends $\mathtt{S_{i,j}}$ and $\mathtt{S_{i,k}}$ in the same task \texttt{i} sent to an identical endpoint such that $\mathtt{i} < \mathtt{k}$, if the relation $(\mathtt{HB}$ $\mathtt{S_{i,j}.event}$ $\mathtt{S_{i,k}.event})$ is defined in $\mathit{constraints}$, add the clause $(\mathtt{HB}$ $(\mathtt{select}$ $\mathtt{S_{i,j}}\ \mathtt{O})$ $(\mathtt{select}$ $\mathtt{S_{i,k}}$ $\mathtt{O}))$ to $\mathit{constraints}$.
\item and collect into a $\mathtt{NE}$ relation for all receives that are matched with any identical send and add it to $\mathit{match}$.
\end{enumerate}

\begin{figure}
\begin{center}
\setlength{\tabcolsep}{20pt}
\begin{tabular}[t]{cc}
\scalebox{0.7}{\usebox{\boxMP}} &
%\scalebox{0.6}{\usebox{\boxSMTa}} &
%\scalebox{0.6}{\usebox{\boxSMTb}} &
\scalebox{0.7}{\usebox{\boxSMTc}} \\\\
(a) & (b)
\end{tabular}
\end{center}
\caption{A match pair set and SMT encoding of the system in \figref{fig:mcapi}.
(a) The match pairs based on endpoints. (b) The SMT encoding where \texttt{HB} creates a
happens-before constraint, \texttt{MATCH} creates a match pair constraint, and \texttt{NE} creates a constraint to preclude the use of conflicting match pairs.}
\label{fig:smt}
\end{figure}

We use our execution trace in \figref{fig:trace} (left side) with the set of match pairs in \figref{fig:smt}(a) as input to go through the algorithm above for generating an SMT encoding shown in \figref{fig:smt}(b). Note that we use the wait command with handler in \figref{fig:trace} to denote the wait command for a send or receive. First, we use step 1 of the algorithm above to generate the $\mathit{defs}$ ``area" that is not shown because the definitions are not novel to our solution. Second, we use step 2 to generate the asserts shown on lines \texttt{11} and \texttt{12} for the assume and assert commands of the original execution trace in \figref{fig:trace}. The first assert on line \texttt{11} works as the assume (line \texttt{14} at trace 1) in \figref{fig:trace}, such that it prevents the SMT solver from finding solutions that are not consistent with control flow which requires ``$b \ge 0$". The second assert on line \texttt{12} is negated as the goal is to find schedules that violate the property. Third, we use step 3 to generate lines \texttt{00} - \texttt{10}, which asserts program order within each thread. Finally, we use steps 4 and 6 to generate the $\mathit{match}$ ``area" of the SMT encoding. In particular, we send the set of match pairs in \figref{fig:smt}(a) to the algorithm and use step 4 to generate a $\mathtt{MATCH}$ statement for each match pair and collect those on the same receive into a disjunction on line \texttt{13} - \texttt{17}; and finally add the \texttt{NE} relation by step 6 that precludes $\mathtt{R_{0,2}}$ and $\mathtt{R_{0,5}}$ from matching to the same send on line \texttt{18}.

Other than the basic structure of the SMT encoding, we use the function
\[\mathrm{ANS}(\mathit{smt}) \mapsto \{\mathrm{\cfgt{SAT}},\mathrm{\cfgt{UNSAT}}\} \]
to return the solution of an SMT problem, such that $\mathrm{\cfgt{SAT}}$ represents a satisfiable solution that finds a trace of the MCAPI program execution that violates the user defined correctness property, and $\mathrm{\cfgt{UNSAT}}$ represents an unsatisfiable solution indicating that all possible execution traces either meet the correctness property in the same control flow, or follow a different control flow. Note that $\mathrm{\cfgt{UNSAT}}$ and $\mathrm{\cfgt{SAT}}$ are ordered such that $\mathrm{\cfgt{UNSAT}} < \mathrm{\cfgt{SAT}}$.

The SMT encoding defined above is used to capture the non-deterministic behavior of an MCAPI program execution by giving a complete set of match pairs. As we discussed in the previous section, the MCAPI program in \figref{fig:mcapi} contains two outcomes of execution as defined in the MCAPI specification under the infinite-buffer semantics. The SMT encoding we present in \figref{fig:smt}(b) captures both execution traces, since the set of match pairs in \figref{fig:smt}(a) is a complete set where all matches that can occur in the real execution for our running example in \figref{fig:mcapi} are included, and all matches that cannot occur in the real execution are not included. Further, the following theorem states that we can over-approximate the true set of match pairs and still prove correctness. If there is no error with the over-approximated set, then there is no error arising from non-determinism in the runtime on that program execution. If there is an error from the over-approximated set, that error is also guaranteed to be a real error in the program runtime. Note that two SMT problems $\smt_{\alpha}$ and $\smt_{\beta}$ in the following theorem have identical $\mathit{defs}$ and $\mathit{constraints}$ sets, and the match set of $\smt_{\alpha}$ is the subset of that of $\smt_{\beta}$ so that $smt_{\beta}$ represents an over-approximation of $smt_{\alpha}$.
\\
\\
\textbf{Theorem 1.}
The relation for the solutions of two SMT problems $\smt_{\alpha}$ $= (\mathit{defs}$ $\mathit{constraints}$ $\mathit{match}_{\alpha})$ and $\smt_{\beta}$ $= (\mathit{defs}$ $\mathit{constraints}$ $\mathit{match_{\beta}})$ is,
\[\mathrm{ANS}(\smt_{\alpha}) \leq \mathrm{ANS}(\smt_{\beta})\]
where $\mathit{set(match_{\alpha})} \subseteq \mathit{set(match_{\beta})}$. Note that $\mathit{set(match)}$ represents the input set of match pairs for the $\mathtt{MATCH}$ clauses in the $\mathit{match}$ field.
\label{thm:1}
\begin{figure}
\begin{center}
\setlength{\tabcolsep}{3pt}
\begin{tabular}[c]{cc}
%\scalebox{0.7}{\usebox{\boxMP}} &
\scalebox{0.7}{\usebox{\boxSMTa}} &
\scalebox{0.7}{\usebox{\boxSMTb}} \\\\
%\scalebox{0.7}{\usebox{\boxSMTc}} \\
(a) & (b)
\end{tabular}
\end{center}
\caption{Two SMT encodings of the system in \figref{fig:mcapi}.
(a) The SMT encoding for Trace 1 in \figref{fig:trace}. (b) The SMT encoding for Trace 2 in \figref{fig:trace}.}
\label{fig:smt_trace}
\end{figure}
\\
\textbf{Proof Sketch.}
Consider the MCAPI program in \figref{fig:mcapi} as an example.
\figref{fig:smt_trace}(a) and (b) are two different SMT encodings for our running
example in \figref{fig:mcapi} generated from different sets of possible match pairs, such that \figref{fig:smt_trace}(a) encodes trace 1 in \figref{fig:trace} and \figref{fig:smt_trace}(b) encodes trace 2 in \figref{fig:trace}. By solving the encodings in \figref{fig:smt_trace}(a) and (b) for trace 1 and 2 in \figref{fig:trace} respectively, we get an unsatisfiable solution for \figref{fig:smt_trace}(a), and a satisfiable solution for \figref{fig:smt_trace}(b). As we discussed in Section 2, trace 1 is an execution trace without failure of the assertion, and trace 2 is the one that fails the assertion. %We can see that the encodings in \figref{fig:smt_trace} (a) and (b) correctly encodes trace 1 and 2 in \figref{fig:trace}, respectively.
Compare both encodings with that in \figref{fig:smt}(b), we find that the fields $\mathit{defs}$ and $\mathit{constraints}$ are identical except for the \texttt{MATCH} clauses. In particular, the input set of match pairs of either \figref{fig:smt_trace}(a) or (b) is the subset of that in \figref{fig:smt}(b). As discussed above, the encoding in \figref{fig:smt}(b) captures the non-deterministic behavior of our running program in \figref{fig:mcapi}, which encodes trace 1 and 2 in \figref{fig:trace} into one single SMT problem. Thus, an SMT solver will return a satisfiable solution for the encoding in \figref{fig:smt}(b). Thus, $\mathrm{ANS}$ on the encoding in \figref{fig:smt}(b) is greater than or equal to the $\mathrm{ANS}$ on the encoding in either \figref{fig:smt_trace}(a) or (b). In other words, adding more match pairs can only move the $\mathrm{ANS}$ from $\mathrm{\cfgt{UNSAT}}$ to $\mathrm{\cfgt{SAT}}$.

The formal proof of Theorem 1 is in the long version of our paper at (``http://students.cs.byu.edu/$\sim$yhuang2 /downloads/paper.pdf"). The proof defines a formal operational semantics given by a term rewriting system using a \textit{CESK}\footnote{The \textit{CESK} machine state is represented with a \textbf{C}ontrol string, \textbf{E}nvironment, \textbf{S}tore, and \textbf{K}ontinuation.} style machine only the machine is augmented to include additional structure for modeling message passing. The operational framework defines how to execute a program, following the specified trace, and defines when that execution is a
success (causes no assertion violation), a failure (causes an assertion violation), infeasible (causes an assume to not hold), or an error (execution is not allowed by the MCAPI semantics.). Further, the machine generates the terms of the SMT encoding as it rewrites the machine states. The proof defines a combination operator and shows that several SMT encodings can be combined such that the combined SMT encoding returns ``SAT" if one of those encodings has a satisfiable solution.  As such, Theorem 1 is formally proved by applying the combination operator for $\smt_{\alpha}$ and $\smt_{\beta}$.

Given $\mathit{set(match_{\alpha})}$ and $\mathit{set(match_{\beta})}$ in the theorem above a complete set of match pairs and an over-approximated set, respectively, we can further prove that $\mathrm{ANS}(\smt_{\alpha})$ $ = $ $\mathrm{ANS}(\smt_{\beta})$ by giving the following theorem. Note that a match pair $(R, S) \in \mathit{set(match_{\beta})}/\mathit{set(match_{\alpha})}$ is called ``bogus", since it cannot exist in a real execution of the program.
\\
\\
\textbf{Theorem 2.}
Any match pair $(R, S)$ used in a satisfying assignment of an SMT encoding $\smt$ is a valid match pair and reflects an actual possible MCAPI program execution.
\\
\textbf{Proof.}
Proof by contradiction. Assume that $(R, S)$ is a ``bogus" match pair that causes $\mathrm{ANS}(\smt) = \cfgt{SAT}$. Since $(R, S)$ is not a valid match pair, match $R$ and $S$ requires program order, message non-overtaking, or no-multiple match to be violated. In other words, the $\mathtt{HB}$ constraints encoded in $\smt$ are not satisfied. Based on the fact above, the answer of $\smt$ is $\cfgt{UNSAT}$ and it contradicts the previous hypothesis. Thus, $(R, S)$ is a valid match pair in $\smt$ and reflects an actual possible MCAPI program execution. $\Box$


By proving Theorem 2, we infer that a ``bogus" match pair can only cause an unsatisfying assignment of an SMT problem. Further, given that $\mathit{set(match_{\alpha})}$ and $\mathit{set(match_{\beta})}$ reflect a complete set and a over-approximated set respectively, the answers of $\smt_{\alpha}$ and $\smt_{\beta}$ discussed above are equal since any ``bogus" match pair involved in $\smt_{\beta}$ is only used in unsatisfying assignments.

It is possible to use our encoding for \textit{zero-buffer} semantics as well. For \textit{zero-buffer} semantics, reorganize the encoding as follows: For each match pair that cannot exist in the program runtime under the \textit{zero-buffer} setting, add extra \texttt{HB} clauses in the SMT encoding to prevent incorrect behavior. For example in \figref{fig:mcapi}, to prevent $\mathtt{R_{1,3}}$ from being matched with $\mathtt{S_{2,6}}$ before $\mathtt{R_{0,2}}$ is matched with $\mathtt{S_{2,4}}$ as prohibited by the \textit{zero-buffer} semantics, an \texttt{HB} relation is added such that the wait command $\mathtt{W(\&h1)}$ for $\mathtt{R_{0,2}}$ happens before $\mathtt{S_{2,6}}$.













