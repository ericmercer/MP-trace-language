\newcommand{\epsnd}{\textit{Pnd\_s}}
\newcommand{\eprcv}{\textit{Pnd\_r}}
\newcommand{\qset}{\textit{Q\_s}}
\newcommand{\snd}{\textit{snd}}
\newcommand{\rcv}{\textit{rcv}}
\newcommand{\q}{\textit{q}}
\newcommand{\frm}{\textit{frm}}
\newcommand{\vbot}{\textit{v$-\bot$}}
\newcommand{\status}{\textit{s}}
\newcommand{\last}{\textit{l}}
\newcommand{\error}{\ensuremath{\mathbf{error}}}
\newcommand{\aidmap}{\textit{A}}
\newcommand{\thread}{\ensuremath{\mathit{t}}}
\newcommand{\aid}{\ensuremath{\mathit{a}}}
\newcommand{\ploc}{\ensuremath{\rho}}
\newcommand{\loc}{\ensuremath{\mathit{l}}}
\newcommand{\cmd}{\ensuremath{\mathit{c}}}
\newcommand{\op}{\ensuremath{\mathit{op}}}
\newcommand{\applyop}{\ensuremath{\mathrm{op}}}
\newcommand{\wait}{\ensuremath{\mathbf{wait}}}
\newcommand{\sendi}{\ensuremath{\mathbf{sndi}}}
\newcommand{\recvi}{\ensuremath{\mathbf{rcvi}}}
\newcommand{\traceentry}{\ensuremath{\sigma}}
\newcommand{\movelist}{\ensuremath{\delta}}
\newcommand{\assume}{\ensuremath{\mathit{assume}}}
\newcommand{\checkassume}{\ensuremath{\mathrm{assume}}}
\newcommand{\assert}{\ensuremath{\mathit{assert}}}
\newcommand{\checkassert}{\ensuremath{\mathrm{assert}}}
\newcommand{\ep}{\ensuremath{\mathbf{\gamma}}}
\newcommand{\src}{\ensuremath{\alpha}}
\newcommand{\dst}{\ensuremath{\beta}}
\newcommand{\true}{\ensuremath{\mathbf{true}}}
\newcommand{\false}{\ensuremath{\mathbf{false}}}
\newcommand{\match}{\ensuremath{\mathrm{m}}}
\newcommand{\matchl}{\ensuremath{\mathrm{match}}}
\newcommand{\findrecv}{\ensuremath{\mathrm{search_r}}}
\newcommand{\smt}{\ensuremath{\mathit{smt}}}


\newcommand{\addsend}{\ensuremath{\mathrm{addsend}}}
\newcommand{\getsend}{\ensuremath{\mathrm{getsend}}}
\newcommand{\removesend}{\ensuremath{\mathrm{removesend}}}
\newcommand{\addrecv}{\ensuremath{\mathrm{addrecv}}}
\newcommand{\getrecv}{\ensuremath{\mathrm{getrecv}}}
\newcommand{\removerecv}{\ensuremath{\mathrm{removefrecv}}}
\newcommand{\hextend}{\ensuremath{\mathrm{hextend}}}
\newcommand{\hlookup}{\ensuremath{\mathrm{hlookup}}}
\newcommand{\etalookup}{\ensuremath{\mathrm{etalookup}}}
\newcommand{\checkmatch}{\ensuremath{\mathrm{checkmatch}}}
\newcommand{\getep}{\ensuremath{\mathrm{getEP}}}
\newcommand{\getmarkremove}{\ensuremath{\mathrm{getMarkRemove}}}
\newcommand{\getlastsendreplace}{\ensuremath{\mathrm{getlastsend/replace}}}
\newcommand{\statuschange}{\left\{ \begin{array}{ll}  \status &\ \mathrm{if}\ |\epsnd(\dst)(\src)|>0\\
   \mathit{error} &\  \mathrm{otherwise}\end{array}\right .}

\newcommand{\reduce}[1]{\ensuremath{\rightarrow_{#1}}}
% Multiple reductions
\newcommand{\reduceK}[1]{\ensuremath{\rightarrow_{#1}^{*}}}
% Non-deterministic reductions
\newcommand{\reduceN}[1]{\ensuremath{\dashrightarrow_{#1}}}
\newcommand{\reduceNK}[1]{\ensuremath{\dashrightarrow_{#1}^{*}}}
\newcommand{\mt}{\ensuremath{\emptyset}}
\newcommand{\trace}{\ensuremath{\mathit{trace}}}
\newcommand{\movebot}{\ensuremath{\mathit{m}}}
\newcommand{\ret}{\ensuremath{\mathbf{ret}}}

\newcommand{\defs}{\ensuremath{\mathrm{defs}}}
\newcommand{\any}{\ensuremath{\mathrm{any}}}
\newcommand{\negate}{\ensuremath{\mathrm{not}}}
\newcommand{\define}{\ensuremath{\mathrm{define}}}
\newcommand{\andd}{\ensuremath{\mathrm{and}}}
\newcommand{\select}{\ensuremath{\mathrm{select}}}
\newcommand{\HB}{\ensuremath{\mathrm{HB}}}
\newcommand{\getlast}{\ensuremath{\mathrm{last}}}
\newcommand{\MATCH}{\ensuremath{\mathrm{MATCH}}}
\newcommand{\ml}{\ensuremath{\mathit{ML}}}
\newcommand{\matchpair}{\ensuremath{\mathrm{MP}}}
\newcommand{\recv}{\ensuremath{\mathrm{\mu}}}
\newcommand{\send}{\ensuremath{\mathrm{\nu}}}



\newsavebox{\boxSMTa}
\begin{lrbox}{\boxSMTa}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 (HB $\mathtt{R_{0,2}}$.event $\mathtt{W(\&h1)}$.event)}\\
\texttt{01 (HB $\mathtt{W(\&h1)}$.event $\mathtt{R_{0,5}}$.event)}\\
\texttt{02 (HB $\mathtt{R_{0,5}}$.event $\mathtt{W(\&h2)}$.event)}\\
\texttt{03 (HB $\mathtt{W(\&h2)}$.event assume.event)}\\
\texttt{04 (HB assume.event assert.event)}\\
\texttt{05 (HB $\mathtt{R_{1,3}}$.event $\mathtt{W(\&h3)}$.event)}\\
\texttt{06 (HB $\mathtt{W(\&h3)}$.event $\mathtt{S_{1,5}}$.event)}\\
\texttt{07 (HB $\mathtt{S_{1,5}}$.event $\mathtt{W(\&h4)}$.event)}\\
\texttt{08 (HB $\mathtt{S_{2,4}}$.event $\mathtt{W(\&h5)}$.event)}\\
\texttt{09 (HB $\mathtt{W(\&h5)}$.event $\mathtt{S_{2,7}}$.event)}\\
\texttt{10 (HB $\mathtt{S_{2,7}}$.event $\mathtt{W(\&h6)}$.event)}\\
\texttt{11 (assert (> b 0))}\\
\texttt{12 (assert (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{13 (MATCH $\mathtt{R_{0,2}}$ $\mathtt{S_{2,4}}$)}\\
\texttt{14 (MATCH $\mathtt{R_{0,5}}$ $\mathtt{S_{1,5}}$)}\\
\texttt{15 (MATCH $\mathtt{R_{1,3}}$ $\mathtt{S_{2,7}}$)}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTb}
\begin{lrbox}{\boxSMTb}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 (HB $\mathtt{R_{0,2}}$.event $\mathtt{W(\&h1)}$.event)}\\
\texttt{01 (HB $\mathtt{W(\&h1)}$.event $\mathtt{R_{0,5}}$.event)}\\
\texttt{02 (HB $\mathtt{R_{0,5}}$.event $\mathtt{W(\&h2)}$.event)}\\
\texttt{03 (HB $\mathtt{W(\&h2)}$.event assume.event)}\\
\texttt{04 (HB assume.event assert.event)}\\
\texttt{05 (HB $\mathtt{R_{1,3}}$.event $\mathtt{W(\&h3)}$.event)}\\
\texttt{06 (HB $\mathtt{W(\&h3)}$.event $\mathtt{S_{1,5}}$.event)}\\
\texttt{07 (HB $\mathtt{S_{1,5}}$.event $\mathtt{W(\&h4)}$.event)}\\
\texttt{08 (HB $\mathtt{S_{2,4}}$.event $\mathtt{W(\&h5)}$.event)}\\
\texttt{09 (HB $\mathtt{W(\&h5)}$.event $\mathtt{S_{2,7}}$.event)}\\
\texttt{10 (HB $\mathtt{S_{2,7}}$.event $\mathtt{W(\&h6)}$.event)}\\
\texttt{11 (assert (> b 0))}\\
\texttt{12 (assert (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{13 (MATCH $\mathtt{R_{0,2}}$ $\mathtt{S_{1,5}}$)}\\
\texttt{14 (MATCH $\mathtt{R_{0,5}}$ $\mathtt{S_{2,4}}$)}\\
\texttt{15 (MATCH $\mathtt{R_{1,3}}$ $\mathtt{S_{2,7}}$)}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTc}
\begin{lrbox}{\boxSMTc}
\normalsize
\begin{tabular}[t]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 (HB $\mathtt{R_{0,2}}$.event $\mathtt{W(\&h1)}$.event)}\\
\texttt{01 (HB $\mathtt{W(\&h1)}$.event $\mathtt{R_{0,5}}$.event)}\\
\texttt{02 (HB $\mathtt{R_{0,5}}$.event $\mathtt{W(\&h2)}$.event)}\\
\texttt{03 (HB $\mathtt{W(\&h2)}$.event assume.event)}\\
\texttt{04 (HB assume.event assert.event)}\\
\texttt{05 (HB $\mathtt{R_{1,3}}$.event $\mathtt{W(\&h3)}$.event)}\\
\texttt{06 (HB $\mathtt{W(\&h3)}$.event $\mathtt{S_{1,5}}$.event)}\\
\texttt{07 (HB $\mathtt{S_{1,5}}$.event $\mathtt{W(\&h4)}$.event)}\\
\texttt{08 (HB $\mathtt{S_{2,4}}$.event $\mathtt{W(\&h5)}$.event)}\\
\texttt{09 (HB $\mathtt{W(\&h5)}$.event $\mathtt{S_{2,7}}$.event)}\\
\texttt{10 (HB $\mathtt{S_{2,7}}$.event $\mathtt{W(\&h6)}$.event)}\\
\texttt{11 (assert (> b 0))}\\
\texttt{12 (assert (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{13} (\texttt{or} (\texttt{MATCH} $\mathtt{R_{0,2}}$ $\mathtt{S_{2,4}}$)\\
\texttt{14}     (\texttt{MATCH} $\mathtt{R_{0,2}}$ $\mathtt{S_{1,5}}$))\\
\texttt{15} (\texttt{or} (\texttt{MATCH} $\mathtt{R_{0,5}}$ $\mathtt{S_{2,4}}$)\\
\texttt{16}     (\texttt{MATCH} $\mathtt{R_{0,5}}$ $\mathtt{S_{1,5}}$))\\
\texttt{17} (\texttt{MATCH} $\mathtt{R_{1,3}}$ $\mathtt{S_{2,7}}$)\\
\texttt{18} (\texttt{NE} $\mathtt{R_{0,2}}$ $\mathtt{R_{0,5}}$)\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxMP}
\begin{lrbox}{\boxMP}
\normalsize
\begin{tabular}[t]{l}
\\\\\\\\\\\\\\\\\\
($\mathtt{R_{0,2}}$ $\mathtt{S_{2,4}}$)\\
($\mathtt{R_{0,2}}$ $\mathtt{S_{1,5}}$)\\
\\
($\mathtt{R_{0,5}}$ $\mathtt{S_{2,4}}$)\\
($\mathtt{R_{0,5}}$ $\mathtt{S_{1,5}}$)\\
\\
($\mathtt{R_{1,3}}$ $\mathtt{S_{2,7}}$)\\
\end{tabular}
\end{lrbox}




\section{SMT Model}\label{sec:smt}

%The next step, after formally defining the operational semantics of our trace
%language, is to formally define a translation from the trace language into an
%SMT problem that can correctly models the original execution trace.

The novelty of the SMT encoding in this paper is its use of match pairs rather than the state-based or order-based encoding of prior work~\cite{elwakil:padtad10,elwakil:atva10}. The algorithm to create the encoding takes as input a set of possible match pairs and a trace through an MCAPI program with the appropriate assumes and asserts as shown in \figref{fig:trace}. A match pair is the coupling of a receive to a particular send. \figref{fig:smt}(a) is the set of possible match pairs for the program in \figref{fig:mcapi} using our shorthand notation defined in \figref{fig:trace}. The set admits, for example, that $\mathtt{R_{0,2}}$ can be matched with either $\mathtt{S_{1,5}}$ or $\mathtt{S_{2,4}}$. The SMT encoding in this paper asks the SMT solver to resolve the match pairs for the system in such a way that the final values of program variables meet the assumption on control flow but violate some assertion.

Before presenting our SMT encoding for a specific example, we need to explain auxiliary data structures and support functions in detail. We give the definitions in the Yices \cite{dutertre:CAV06} input language.

% (define HB::(-> a::int b::int (subtype (c::bool) (ite (< a b) (= c true) (= c false)))))
\begin{equation}
\begin{array}{l}
(\cfgt{define}\ \mathrm{HB}::(\rightarrow\ \cfgnt{a::int}\ \cfgnt{b::int}\\
\ \ \ (\cfgt{subtype}\ \cfgnt{(c::bool)}\ (\mathrm{ite}\ (<\ \mathit{a}\ \mathit{b})\ (=\ \mathit{c}\ \mathrm{true})\ (=\ \mathit{c}\ \mathrm{false})))))
\end{array}
\label{equation:hb}
\end{equation}

%\begin{equation}
%\mathrm{HB}(a,b) \equiv \left\{ \begin{array}{rl}
%  \mathit{true} & \mathrm{if}\ a < b \\
%  \mathit{false} & \mathrm{otherwise}\
%\end{array}
%\right .
%\end{equation}

The HB function in equation (\ref{equation:hb}) creates a happens-before relationship between two events. The notation $``\mathrm{ite}"$ refers to a condition statement such that if the condition is satisfied, then the first subclause is true; otherwise, the second subclause is true. The function takes two events $a$ and $b$ as parameters, such that $a,b \in \mathbb{N}$, where $\mathbb{N}$ is the set of natural numbers. In our SMT encoding, every location is assigned an event, and HB orders those locations (i.e., program order, etc.). This function creates a constraint such that the first event must be less than the second event, indicating that the first event occurs before the second event. For example, action $a$ happens before $b$ if and only if $\mathit{event}_a$ for $a$ is greater than $\mathit{event}_b$ for $b$. This function is not only used to assert the program order of statements within the same thread, but also to assert, for any matched pair, that the send operation
occurs before the receive.

\begin{equation}
\begin{array}{l}
%(define-type recv (record match::int e::int var::int event::int))
(\cfgt{define-type}\ R\ (\cfgt{record}\ \cfgnt{M::int}\ \cfgnt{e::int}\ \cfgnt{value::int}\ \cfgnt{event::int})) \\
%(define-type send (record match_po::int id::int e::int value::int event::int))
(\cfgt{define-type}\ S\ (\cfgt{record}\ \cfgnt{O::int}\ \cfgnt{ID::int}\ \cfgnt{e::int}\ \cfgnt{value::int}\ \cfgnt{event::int}))
\end{array}
\label{equation:record}
\end{equation}
%\[R = (M\ \ep_r\ x\ \ploc_r)\]
%\[S = (\mathit{MP}\ \mathit{ID}\ \ep_s\ e\ \ploc_s)\]

We define two records in equation (\ref{equation:record}) that are essential to encoding our SMT problem. The first record $\cfgnt{R}$ defined above represents a receive action such that $\mathit{M}$, $\mathit{e}$, $\mathit{value}$, $\mathit{event} \in \mathbb{N}$. $\mathit{M}$ represents a free variable (notation where substitution may take place) that is assigned the $\mathit{event}$ field of the matched record $S$. $\mathit{e}$ is the endpoint of the receive action $\cfgnt{R}$, $\mathit{value}$ represents a value received by the receive operation, and $\mathit{event}$ is the event term which indicates the program order of the receive action $\cfgnt{R}$. The second record $S$ defined above is a send action such that $\mathit{O}$, $\mathit{ID}$, $\mathit{e}$, $\mathit{value}$, $\mathit{event} \in \mathbb{N}$. The fields $\mathit{e}$ and $\mathit{event}$, as those in tuple $\cfgnt{R}$, are the destination endpoint and event term, respectively. The field $\mathit{value}$ is the value being sent. $\mathit{O}$ is a free variable used for match pairs, and it is assigned an event term of a receive operation if the receive operation is to be matched to the send operation. $\mathit{ID}$ is a unique number that identifies each send operation. Note that the integer value assigned to $\mathit{event}$ indicates the program order. Also, we use two match variables, $M$ and $\mathit{O}$, for different purposes. $M$ is used for preventing two receive operations from being matched with the same send operation. $\mathit{O}$ is used for ordering two receive operations with respect to the program order of two matched send operations. The SMT solver must assign the $\mathit{M}$ and $\mathit{event}$ fields of the send tuple, and it must assign the $\mathit{event}$, $\mathit{M}$, and $\mathit{value}$ fields of the receive tuple in a way that is consistent with all the constraints in the encoding.

%(define MATCH::(-> r::recv s::send (subtype (c::bool) (ite
 % (and (= (select r ep) (select s ep))
 %      (= (select r var) (select s value))
  %     (HB (select s event) (select r event))
   %    (= (select r match) (select s id))
%       (= (select s match_po) (select r event)))%
% (= c true)
% (= c false)))))

\begin{equation}
\begin{array}{l}
(\cfgt{define}\ \mathrm{MATCH}::(\rightarrow\ \cfgnt{r::R}\ \cfgnt{s::S}\ (\cfgt{subtype}\ \cfgnt{(c::bool)}\ (\cfgnt{ite} \\
\ \ \ (\mathrm{and}\ (=\ (\mathrm{select}\ \mathit{r}\ \mathit{e})\ (\mathrm{select}\ \mathit{s}\ \mathit{e})) \\
\ \ \ \ \     (=\ (\mathrm{select}\ \mathit{r}\ \mathit{value})\ (\mathrm{select}\ \mathit{s}\ \mathit{value})) \\
\ \ \ \ \    (\mathrm{HB}\ (\mathrm{select}\ \mathit{s}\ \mathit{event})\ (\mathrm{select}\ \mathit{r}\ \mathit{event})) \\
\ \ \ \ \    (=\ (\mathrm{select}\ \mathit{r}\ \mathit{M})\ (\mathrm{select}\ \mathit{s}\ \mathit{ID})) \\
\ \ \ \ \    (=\ (\mathrm{select}\ \mathit{s}\ \mathit{O})\ (\mathrm{select}\ \mathit{r}\ \mathit{event}))) \\
\ \ \  (=\ \mathit{c}\ \mathrm{true}) \\
\ \ \  (=\ \mathit{c}\ \mathrm{false})))))
\end{array}
\label{equation:match}
\end{equation}
%\begin{equation}
%\mathrm{MATCH}(R,S) \equiv \left\{
%\begin{array}{ll}
%  \mathit{true} & \mathrm{if}\ M = \mathit{ID}~\wedge \\
%  & \ep_r = \ep_s~\wedge \\
%  & x = e~\wedge \\
%  & \mathrm{HB}(\ploc_s,\ploc_r)~\wedge \\
%  & \mathit{MP}_r = \ep_r \\
%  \mathit{false} & \mathrm{otherwise}\
%\end{array}
%\right . \\
%\end{equation}

The $\mathrm{MATCH}$ function in equation (\ref{equation:match}) takes tuples $R$ and $S$ as parameters. Each $``\mathrm{select}"$ statement selects a field of tuple $R$ or $S$. The function creates a number of constraints that represent the pairing
of the specified send and receive operations. This function asserts that the
destination endpoint of the send operation is the same as the endpoint used by
the receive operation, that the value sent by the send operation is the same
value received by the receive operation, that the send operation occurs before
the receive operation, that the ``match'' value (M) in the receive tuple is
equal to the ``ID'' value in the send tuple, and that the ``O" value in the send tuple is equal to the ``event" value in the receive tuple. Note that the encoding is going to use the ``O"  value in conjunction with the HB function to enforce message non-overtaking when messages are sent from the same endpoint. Consider a simple example below that sends two messages from a Task 0 to Task 1,
\[
\begin{array}{l|l}
\;\;\;\;\;\;\;\;\mathtt{Task\ 0}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{Task\ 1}\;\;\;\;\;\;\;\; \\
\hline
\;\;\;\;\;\;\;\;\mathtt{S_{0,1}(1,\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,1}(*,\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{S_{0,2}(1,\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,2}(*,\&h4)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h4)}\;\;\;\;\;\;\;\; \\
\end{array}
\]
The ``O" values in the send records will be assigned to the order tracking events for $\mathtt{R_{1,1}}$ and $\mathtt{R_{1,2}}$ in the final encoding. Message non-overtaking from transactions on common endpoints is encoded by forcing the send events to be received in program order using the HB function as below in our simple example:
\[(\mathrm{HB}\ (\mathrm{select}\ \mathtt{S_{0,1}}\ \mathrm{O})\ (\mathrm{select}\ \mathtt{S_{0,2}}\ \mathrm{O}))\]


\begin{equation}
\begin{array}{l}
(\cfgt{define}\ \mathrm{NE}::(\rightarrow\ \cfgnt{r1::R}\ \cfgnt{r2::R}\ (\cfgt{subtype}\ \cfgnt{(c::bool)}\ (\cfgnt{ite} \\
\ \ (=\ (\mathrm{select}\ \mathit{r1}\ \mathit{M})\ (\mathrm{select}\ \mathit{r2}\ \mathit{M})) \\
\ \ (=\ \mathit{c}\ \mathrm{false}) \\
\ \ (=\ \mathit{c}\ \mathrm{true})))))
\end{array}
\label{equation:ne}
\end{equation}

%\begin{equation}
%\mathrm{ne}(a,b) \equiv \left\{ \begin{array}{rl}
%  \mathit{true} & \mathrm{if}\ M_a \not = M_b \\
%  \mathit{false} & \mathrm{otherwise}\
%\end{array}
%\right .
%\end{equation}

The $\mathrm{NE}$ function in equation (\ref{equation:ne}) is used to assert that no two receive operations are matched
with the same send operation. The parameters for this function are two receive
tuples. An assertion is made that the values of their ``match'' fields, $M$,
are not equal. This shows that they are paired with two different send
operations.

Prior SMT models of MCAPI program executions implicitly compute
match pairs by adding possible happens-before relations on sends and
receives with the conditions under which those orderings are
valid. The SMT solver is then asked to resolve the happens-before
relation by choosing specific orders of sends and receives. Match pair
encoding, as presented in this work, though it has the same
computational complexity as order based encoding (you still need to
figure out match pairs on endpoints), is simpler to reason about
directly rather than implicitly through orders, results in
significantly fewer terms in the SMT problem, and does not restrict out possible matches allowed by the MCAPI specification of the runtime as do existing encodings.

The presentation of the SMT encoding is structured as
\[\mathit{smt}\ =\ (\mathit{defs}\ \mathit{constraints}\ \mathit{match})\]
where the field $\mathit{defs}$ represents all definitions of the send, receive operations and the free variables; The field $\mathit{constraints}$ represents all constraint clauses, including the assert clauses and the clauses built by the \texttt{HB} functions; and the field $\mathit{match}$ represents the clauses built by the \texttt{MATCH} function on a set of match pairs and the \texttt{NE} function. %We use $\mathit{match}.\mathit{input}$ to represent the input set of match pairs.

The input for generating the SMT encoding is an MCAPI program together with a set of match pairs. The first trace in \figref{fig:trace} with the set of match pairs in \figref{fig:smt}(a) is such an example. Given an input, the algorithm for generating our encoding is enumerated as follows. For convenience, we use the notation ``.event" following each command to represent the event field in our encoding.
\begin{enumerate}
\item Define variable ``.event" for the program order of each assume or assert command in the field $\mathit{defs}$;
\item for each assume, add a statement to $\mathit{constraints}$, and for each assert, add a negated assert to $\mathit{constraints}$ in order to obtain an execution trace with assertion failure from an SMT solver;
\item for each send or receive in the trace, create an $S$ or $R$ definition and create an associated ``.event" variable for program order and add these to $\mathit{defs}$;
\item for each program order represented by the field $\mathrm{event}$ in each thread, add an \texttt{HB} relation on the associated event for program order to $\mathit{constraints}$;
\item for each match pair for a send and receive as input, add an $\mathrm{MATCH}$ relation to $\mathit{match}$;
\item for two sends $\mathtt{S_{i,j}}$ and $\mathtt{S_{i,k}}$ in the same task \texttt{i} sent to an identical endpoint such that $\mathtt{i} < \mathtt{k}$, if the relation $(\mathrm{HB}$ $\mathtt{S_{i,j}.event}$ $\mathtt{S_{i,k}.event})$ is defined in $\mathit{constraints}$, add the clause $(\mathrm{HB}$ $(\mathrm{select}$ $\mathtt{S_{i,j}}\ \mathrm{O})$ $(\mathrm{select}$ $\mathtt{S_{i,k}}$ $\mathrm{O}))$ to $\mathit{constraints}$.
\item collect into a disjunction for all possible send matches for any given receive in the field $\mathit{match}$;
\item and collect into a $\mathrm{NE}$ relation for all receives that are matched with any identical send and add it to $\mathit{match}$.
\end{enumerate}

\begin{figure}
\begin{center}
\setlength{\tabcolsep}{20pt}
\begin{tabular}[t]{cc}
\scalebox{0.7}{\usebox{\boxMP}} &
%\scalebox{0.6}{\usebox{\boxSMTa}} &
%\scalebox{0.6}{\usebox{\boxSMTb}} &
\scalebox{0.7}{\usebox{\boxSMTc}} \\\\
(a) & (b)
\end{tabular}
\end{center}
\caption{A match pair set and SMT encoding of the system in \figref{fig:mcapi}.
(a) The match pairs based on endpoints. (b) The SMT encoding where \texttt{HB} creates a
happens-before constraint, \texttt{MATCH} creates a match pair constraint, and \texttt{NE} creates a constraint to preclude the use of conflicting match pairs.}
\label{fig:smt}
\end{figure}

We use our execution trace in \figref{fig:trace} (left side) with the set of match pairs in \figref{fig:smt}(a) as input to go through the algorithm above for generating an SMT encoding shown in \figref{fig:smt}(b). Note that we use the wait command with handler in \figref{fig:trace} to denote the wait command for a send or receive command. First, we use steps 1 and 3 of the algorithm above to generate the $\mathit{defs}$ ``area" that is not shown because the definitions are not novel to our solution. Second, we use step 2 to generate the asserts shown on line \texttt{11} and \texttt{12} for the assume and assert commands of the original execution trace in \figref{fig:trace}. The first assert on line \texttt{11} works as the assume (line \texttt{14} at trace 1) in \figref{fig:trace}, such that it prevents the SMT solver from finding solutions that are not consistent with control flow which requires ``$b \ge 0$". The second assert on line \texttt{12} is negated as the goal is to find schedules that violate the property. Third, we use step 4 to generate line \texttt{00} - \texttt{10}, which represent the HB relationship between the events of commands. By encoding function $\mathrm{HB}$, $\mathtt{R_{0,2}}$ happens before the wait command $\mathtt{W(\&h1)}$ given the ``event'' for each command as parameters on line \texttt{00} in \figref{fig:smt}(b). Note that any assignment to event variables by the SMT solver must comply with program order constraints. Each event in the $\mathrm{HB}$ orderings on line \texttt{00} - \texttt{10} are ordered in a thread of \figref{fig:trace}. Finally, we use steps 5, 7 and 8 to generate the $\mathit{match}$ ``area" of the SMT encoding. In particular, we send the set of match pairs in \figref{fig:smt}(a) to the algorithm and use step 5 to generate an $\mathtt{MATCH}$ statement for each match pair; collect into a disjunction by step 7 so that all possible $\mathtt{MATCH}$ statements are organized on line \texttt{13} - \texttt{17}; add \texttt{NE} relation by step 8 that precludes $\mathtt{R_{0,2}}$ and $\mathtt{R_{0,5}}$ from matching to the same send on line \texttt{18}.

Other than the basic structure of the SMT encoding, we use the function
\[\mathrm{ANS}(\mathit{smt}) \mapsto \{\mathrm{\cfgt{SAT}},\mathrm{\cfgt{UNSAT}}\} \]
to return the solution of an SMT problem, such that $\mathrm{\cfgt{SAT}}$ represents a satisfiable solution that finds an execution of the MCAPI program that violates the user defined correctness property, and $\mathrm{\cfgt{UNSAT}}$ represents an unsatisfiable solution that all possible execution traces either meet the correctness property in the same control flow, or follow a different control flow. Note that $\mathrm{\cfgt{UNSAT}}$ and $\mathrm{\cfgt{SAT}}$ are ordered such that $\mathrm{\cfgt{UNSAT}} < \mathrm{\cfgt{SAT}}$.

The SMT encoding defined above is used to capture the non-deterministic behavior of an MCAPI program by giving a complete set of match pairs. As we discussed in the previous section, the MCAPI program in \figref{fig:mcapi} contains two outcomes of execution as defined in the MCAPI specification. The SMT encoding we present in \figref{fig:smt}(b) captures both executions, since the set of match pairs in \figref{fig:smt}(a) is a complete set where all matches that can occur in the real execution for our running example in \figref{fig:mcapi} are included, and all matches that cannot occur in the real execution are not included. Furthermore, the following theorem states that we can over-approximate the true set of match pairs and still prove correctness. If there is no error with the over-approximated set, then there is no error arising from non-determinism in the runtime on that program execution. If there is an error from the over-approximated set, that error is also guaranteed a real error in the program runtime by giving the second theorem in the following. Note that two SMT problems $\smt_{\alpha}$ and $\smt_{\beta}$ in the following theorem have an identical $\mathit{defs}$ and $\mathit{constraints}$ sets, and the match set of $\smt_{\alpha}$ is the subset of that of $\smt_{\beta}$ so that $smt_{\beta}$ represents an over-approximation of $smt_{\alpha}$.

\subsection{Theorem 1}
For two SMT problems, $\smt_{\alpha} = (\mathit{defs}\ \mathit{constraints}\ \mathit{match}_{\alpha})$ and $\smt_{\beta} = (\mathit{defs}\ \mathit{constraints}\ \mathit{match_{\beta}})$,
if $\mathit{set(match_{\alpha})} \subseteq \mathit{set(match_{\beta})}$,
\[\mathrm{ANS}(\smt_{\alpha}) \leq \mathrm{ANS}(\smt_{\beta})\]
where $\mathit{set(match)}$ represents the input set of match pairs for the $\mathtt{MATCH}$ clauses in the field $\mathit{match}$.
\label{thm:1}
\begin{figure}
\begin{center}
\setlength{\tabcolsep}{3pt}
\begin{tabular}[c]{cc}
%\scalebox{0.7}{\usebox{\boxMP}} &
\scalebox{0.7}{\usebox{\boxSMTa}} &
\scalebox{0.7}{\usebox{\boxSMTb}} \\\\
%\scalebox{0.7}{\usebox{\boxSMTc}} \\
(a) & (b)
\end{tabular}
\end{center}
\caption{Two SMT encodings of the system in \figref{fig:mcapi}.
(a) The SMT encoding for Trace 1 in \figref{fig:trace}. (b) The SMT encoding for Trace 2 in \figref{fig:trace}.}
\label{fig:smt_trace}
\end{figure}
\\
\textbf{Proof Sketch.}
Consider the MCAPI program in \figref{fig:mcapi} as an example.
\figref{fig:smt_trace}(a) and (b) are two different SMT encodings for our running
example in \figref{fig:mcapi} generated from different sets of possible match pairs, such that \figref{fig:smt_trace}(a) encodes trace 1 in \figref{fig:trace} and \figref{fig:smt_trace}(b) encodes trace 2 in \figref{fig:trace}. By solving the encodings in \figref{fig:smt_trace}(a) and (b) for trace 1 and 2 in \figref{fig:trace} respectively, we get an unsatisfiable solution for \figref{fig:smt_trace}(a), and a satisfiable solution for \figref{fig:smt_trace}(b). As we discussed in Section 2, trace 1 is an execution without failure of the assertion, and trace 2 is the one that fails the assertion. %We can see that the encodings in \figref{fig:smt_trace} (a) and (b) correctly encodes trace 1 and 2 in \figref{fig:trace}, respectively.
Compare both encodings with that in \figref{fig:smt}(b), we find that the fields $\mathit{defs}$ and $\mathit{constraints}$ are identical except for the \texttt{MATCH} clauses. In particular, the input set of match pairs of either \figref{fig:smt_trace}(a) or (b) is the subset of that in \figref{fig:smt}(b). As discussed above, the encoding in \figref{fig:smt}(b) captures the non-deterministic behavior of our running program in \figref{fig:mcapi}, which encodes trace 1 and 2 in \figref{fig:trace} into one single SMT problem. Thus, an SMT solver will return a satisfiable solution for the encoding in \figref{fig:smt}(b). Thus, $\mathrm{ANS}$ on the encoding in \figref{fig:smt}(b) is greater than or equal to the $\mathrm{ANS}$ on the encoding in either \figref{fig:smt_trace}(a) or (b). The formal proof is given in a long version of paper at (``http://students.cs.byu.edu/~yhuang2/downloads/paper.pdf'').

Given $\mathit{set(match_{\alpha})}$ and $\mathit{set(match_{\beta})}$ in the theorem above a complete set of match pairs and an over-approximated set for an MCAPI program, respectively, we can further prove that $\mathrm{ANS}(\smt_{\alpha})$ $ = $ $\mathrm{ANS}(\smt_{\beta})$ by giving the following theorem. Note that a match pair $(R, S) \in \mathit{set(match_{\beta})}/\mathit{set(match_{\alpha})}$ is called ``bogus", since it cannot exist in a real execution of the program.

\subsection{Theorem 2}
Any match pair $(R, S)$ used in a satisfying assignment of an SMT encoding $\smt$ is a valid match pair and reflects an actual possible MCAPI program execution.
\\
\textbf{Proof.}
Proof by contradiction. Suppose $(R, S)$ is a ``bogus" match pair that causes $\mathrm{ANS}(\smt) = \cfgt{SAT}$. Since $(R, S)$ is not a valid match pair, it cannot reflect an actual program execution. In other words, the $\mathrm{HB}$ constraints encoded in $\smt$ are not satisfied. Based on the fact above, the answer of $\smt$ is $\cfgt{UNSAT}$ and it contradicts the previous hypothesis. Thus, $(R, S)$ is a valid match pair in $\smt$ and reflects an actual possible MCAPI program execution. $\Box$

By proving Theorem 2, we infer that a ``bogus" match pair can only cause an unsatisfying assignment of an SMT problem. Further, given that $\mathit{set(match_{\alpha})}$ and $\mathit{set(match_{\beta})}$ reflect a complete set and a over-approximated set respectively, the answers of two encodings $\smt_{\alpha}$ and $\smt_{\beta}$ discussed above are equal since any ``bogus" match pair involved in $\smt_{\beta}$ is only used in unsatisfying assignments.

The non-determinism of an MCAPI program discussed above relies on the \textit{infinite-buffer} setting. If the \textit{zero-buffer} setting is used instead, the SMT encoding needs to be reorganized as follows. For each match pair that cannot exist in the program runtime under the \textit{zero-buffer} setting, add extra \texttt{HB} clauses in the SMT encoding to prevent incorrect behavior. For example in \figref{fig:mcapi}, to prevent $\mathtt{R_{1,3}}$ to be matched with $\mathtt{S_{2,6}}$ before $\mathtt{R_{0,2}}$ is matched with $\mathtt{S_{2,4}}$ prohibited by the \textit{zero-buffer}, an \texttt{HB} relation is added such that the wait command $\mathtt{W(\&h1)}$ for $\mathtt{R_{0,2}}$ happens before $\mathtt{S_{2,6}}$.













