\newcommand{\epsnd}{\textit{Pnd\_s}}
\newcommand{\eprcv}{\textit{Pnd\_r}}
\newcommand{\qset}{\textit{Q\_s}}
\newcommand{\snd}{\textit{snd}}
\newcommand{\rcv}{\textit{rcv}}
\newcommand{\q}{\textit{q}}
\newcommand{\frm}{\textit{frm}}
\newcommand{\vbot}{\textit{v$-\bot$}}
\newcommand{\status}{\textit{s}}
\newcommand{\last}{\textit{l}}
\newcommand{\error}{\ensuremath{\mathbf{error}}}
\newcommand{\aidmap}{\textit{A}}
\newcommand{\thread}{\ensuremath{\mathit{t}}}
\newcommand{\aid}{\ensuremath{\mathit{a}}}
\newcommand{\ploc}{\ensuremath{\rho}}
\newcommand{\loc}{\ensuremath{\mathit{l}}}
\newcommand{\cmd}{\ensuremath{\mathit{c}}}
\newcommand{\op}{\ensuremath{\mathit{op}}}
\newcommand{\applyop}{\ensuremath{\mathrm{op}}}
\newcommand{\wait}{\ensuremath{\mathbf{wait}}}
\newcommand{\sendi}{\ensuremath{\mathbf{sndi}}}
\newcommand{\recvi}{\ensuremath{\mathbf{rcvi}}}
\newcommand{\traceentry}{\ensuremath{\sigma}}
\newcommand{\movelist}{\ensuremath{\delta}}
\newcommand{\assume}{\ensuremath{\mathit{assume}}}
\newcommand{\checkassume}{\ensuremath{\mathrm{assume}}}
\newcommand{\assert}{\ensuremath{\mathit{assert}}}
\newcommand{\checkassert}{\ensuremath{\mathrm{assert}}}
\newcommand{\ep}{\ensuremath{\mathbf{\gamma}}}
\newcommand{\src}{\ensuremath{\alpha}}
\newcommand{\dst}{\ensuremath{\beta}}
\newcommand{\true}{\ensuremath{\mathbf{true}}}
\newcommand{\false}{\ensuremath{\mathbf{false}}}
\newcommand{\match}{\ensuremath{\mathrm{m}}}
\newcommand{\matchl}{\ensuremath{\mathrm{match}}}
\newcommand{\findrecv}{\ensuremath{\mathrm{search_r}}}
\newcommand{\smt}{\ensuremath{\mathit{smt}}}


\newcommand{\addsend}{\ensuremath{\mathrm{addsend}}}
\newcommand{\getsend}{\ensuremath{\mathrm{getsend}}}
\newcommand{\removesend}{\ensuremath{\mathrm{removesend}}}
\newcommand{\addrecv}{\ensuremath{\mathrm{addrecv}}}
\newcommand{\getrecv}{\ensuremath{\mathrm{getrecv}}}
\newcommand{\removerecv}{\ensuremath{\mathrm{removefrecv}}}
\newcommand{\hextend}{\ensuremath{\mathrm{hextend}}}
\newcommand{\hlookup}{\ensuremath{\mathrm{hlookup}}}
\newcommand{\etalookup}{\ensuremath{\mathrm{etalookup}}}
\newcommand{\checkmatch}{\ensuremath{\mathrm{checkmatch}}}
\newcommand{\getep}{\ensuremath{\mathrm{getEP}}}
\newcommand{\getmarkremove}{\ensuremath{\mathrm{getMarkRemove}}}
\newcommand{\getlastsendreplace}{\ensuremath{\mathrm{getlastsend/replace}}}
\newcommand{\statuschange}{\left\{ \begin{array}{ll}  \status &\ \mathrm{if}\ |\epsnd(\dst)(\src)|>0\\
   \mathit{error} &\  \mathrm{otherwise}\end{array}\right .}

\newcommand{\reduce}[1]{\ensuremath{\rightarrow_{#1}}}
% Multiple reductions
\newcommand{\reduceK}[1]{\ensuremath{\rightarrow_{#1}^{*}}}
% Non-deterministic reductions
\newcommand{\reduceN}[1]{\ensuremath{\dashrightarrow_{#1}}}
\newcommand{\reduceNK}[1]{\ensuremath{\dashrightarrow_{#1}^{*}}}
\newcommand{\mt}{\ensuremath{\emptyset}}
\newcommand{\trace}{\ensuremath{\mathit{trace}}}
\newcommand{\movebot}{\ensuremath{\mathit{m}}}
\newcommand{\ret}{\ensuremath{\mathbf{ret}}}

\newcommand{\defs}{\ensuremath{\mathrm{defs}}}
\newcommand{\any}{\ensuremath{\mathrm{any}}}
\newcommand{\negate}{\ensuremath{\mathrm{not}}}
\newcommand{\define}{\ensuremath{\mathrm{define}}}
\newcommand{\andd}{\ensuremath{\mathrm{and}}}
\newcommand{\select}{\ensuremath{\mathrm{select}}}
\newcommand{\HB}{\ensuremath{\mathrm{HB}}}
\newcommand{\getlast}{\ensuremath{\mathrm{last}}}
\newcommand{\MATCH}{\ensuremath{\mathrm{MATCH}}}
\newcommand{\ml}{\ensuremath{\mathit{ML}}}
\newcommand{\matchpair}{\ensuremath{\mathrm{MP}}}
\newcommand{\recv}{\ensuremath{\mathrm{\mu}}}
\newcommand{\send}{\ensuremath{\mathrm{\nu}}}

\newsavebox{\boxSMTa}
\begin{lrbox}{\boxSMTa}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h1)}}$}\\
\texttt{01 $\mathit{event_\mathtt{R_{0,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h2)}}$}\\
\texttt{02 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{R_{0,5}}}$}\\
\texttt{03 $\mathit{event_\mathtt{R_{1,3}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h3)}}$}\\
\texttt{04 $\mathit{event_\mathtt{S_{1,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h4)}}$}\\
\texttt{05 $\mathit{event_\mathtt{S_{2,4}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h5)}}$}\\
\texttt{06 $\mathit{event_\mathtt{S_{2,7}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h6)}}$}\\
\texttt{07 ($\mathit{assert}$ (> b 0))}\\
\texttt{08 ($\mathit{assert}$ (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{09 $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{2,4}}\rangle$}\\
\texttt{10 $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{1,5}}\rangle$}\\
\texttt{11 $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTb}
\begin{lrbox}{\boxSMTb}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h1)}}$}\\
\texttt{01 $\mathit{event_\mathtt{R_{0,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h2)}}$}\\
\texttt{02 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{R_{0,5}}}$}\\
\texttt{03 $\mathit{event_\mathtt{R_{1,3}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h3)}}$}\\
\texttt{04 $\mathit{event_\mathtt{S_{1,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h4)}}$}\\
\texttt{05 $\mathit{event_\mathtt{S_{2,4}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h5)}}$}\\
\texttt{06 $\mathit{event_\mathtt{S_{2,7}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h6)}}$}\\
\texttt{07 ($\mathit{assert}$ (> b 0))}\\
\texttt{08 ($\mathit{assert}$ (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{09 $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{1,5}}\rangle$}\\
\texttt{10 $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{2,4}}\rangle$}\\
\texttt{11 $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTc}
\begin{lrbox}{\boxSMTc}
\normalsize
\begin{tabular}[t]{l}
\texttt{..} \\
\texttt{01 $\mathit{order_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{order_\mathtt{W(\&h1)}}$}\\
\texttt{02 $\mathit{order_\mathtt{R_{0,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{order_\mathtt{W(\&h2)}}$}\\
\texttt{03 $\mathit{order_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{order_\mathtt{R_{0,5}}}$}\\
\texttt{04 $\mathit{order_\mathtt{R_{1,3}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{order_\mathtt{W(\&h3)}}$}\\
\texttt{05 $\mathit{order_\mathtt{S_{1,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{order_\mathtt{W(\&h4)}}$}\\
\texttt{06 $\mathit{order_\mathtt{S_{2,4}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{order_\mathtt{W(\&h5)}}$}\\
\texttt{07 $\mathit{order_\mathtt{S_{2,7}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{order_\mathtt{W(\&h6)}}$}\\
\texttt{08} \texttt{($\mathit{assert}$ (> b 0))}\\
\texttt{09} \texttt{($\mathit{assert}$ (not (= a 4)))}\\
\texttt{10} $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{2,4}}\rangle\vee\langle\mathtt{R_{0,2}}$,$\mathtt{S_{1,5}}\rangle$\\
\texttt{11} $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{2,4}}\rangle\vee\langle\mathtt{R_{0,5}}$,$\mathtt{S_{1,5}}\rangle$\\
\texttt{12} $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$
\end{tabular}
\end{lrbox}

\newsavebox{\boxMP}
\begin{lrbox}{\boxMP}
\normalsize
\begin{tabular}[t]{l}
$\langle\mathtt{R_{0,2}}$, $\mathtt{S_{2,4}}\rangle$\\
$\langle\mathtt{R_{0,2}}$, $\mathtt{S_{1,5}}\rangle$\\
\\
$\langle\mathtt{R_{0,5}}$, $\mathtt{S_{2,4}}\rangle$\\
$\langle\mathtt{R_{0,5}}$, $\mathtt{S_{1,5}}\rangle$\\
\\
$\langle\mathtt{R_{1,3}}$, $\mathtt{S_{2,7}}\rangle$\\
\end{tabular}
\end{lrbox}

\section{SMT Encoding}\label{sec:smt}

Our SMT encoding is based on (1) a trace of events during an execution
of an MCAPI program including control-flow assumptions and property
assertions, such as \figref{fig:trace1} and (2) a set of possible
match pairs.

A match pair is the coupling of a receive to a particular
send. \figref{fig:smt}(a) is the set of possible match pairs for the
program in \figref{fig:mcapi} using our shorthand notation. The set
admits, for example, that $\mathtt{R_{0,2}}$ can be matched with
either $\mathtt{S_{1,5}}$ or $\mathtt{S_{2,4}}$.

This match pair-based encoding, rather than state-based or order-based
encoding~\cite{elwakil:padtad10,elwakil:atva10}, is novel.

The purpose of the SMT encoding is to force the SMT solver to resolve
the match pairs for the system in such a way that the final values of
program variables meet the assumptions on control flow but violate
some assertion. In essence, the SMT solver completes a partial order
on events into a total order that determines the final match pair
relationships.

\subsection{Definitions} \label{sec:smt-defns}

The encoding needs to express the partial order imposed by the MCAPI
semantics as SMT constraints. The partial order is based on a
\emph{Happens-Before} relation over events:

\begin{definition}[Happens-Before]
The \emph{Happens-Before} $(\mathtt{HB})$ relation denoted as
$\mathrm{\prec_\mathtt{HB}}$ is a partial order.
\label{def:hb}
\end{definition}

Given two events, $A$ and $B$, if $A$ must complete before $B$ in a
valid program execution, then $A$ $\mathrm{\prec_{\mathtt{HB}}}$ $B$
will be an SMT constraint.

The constraints on this relation are derived from the program source
and match pairs. In order to specify the constraints from the program
source, we must map each operation to a order variable. For example,

\begin{definition}[Wait] \label{def:event}
For a wait operation \texttt{W}, the only relevant information is when
it occurs, so we create a variable $\mathit{order}_\mathtt{W}$.
\end{definition}

However, it is not enough to represent all events as simple numbers
that will be ordered in this way. This would not allow the solver to
discover what values would flow across communication primitives, for
example. Instead, we represent each event in the trace as a set of SMT
variables that record the pertinent information about the event. For
example,

\begin{definition}[Send] \label{def:snd}
For every send operation $\mathtt{S}$, we create four variables:
\begin{compactenum}
\item $M_\mathtt{S}$, the order of the matching receive event;

\item $\mathit{order}_\mathtt{S}$, the order of the send;

\item $e_\mathtt{S}$, the endpoint; and,

\item $\mathit{value}_\mathtt{S}$, the transmitted value.
\end{compactenum}
\end{definition}

The most complex operation in MCAPI is a receive. Since receives are
inherently asynchronous, it is not possible to represent them
atomically. Instead, we need to associate each receive with a wait
where the program expects the operation to be completed by. A single
wait can be associated with many receives due to \emph{the message
  non-overtaking property} required by MCAPI. We refer to this wait as
the \emph{nearest-enclosing wait}.

\begin{definition}[Nearest-Enclosing Wait] \label{def:nw}
A wait that witnesses the completion of a receive by indicating that
the message is delivered and that all the previous receives in the
same task issued earlier are complete as well.
\end{definition}

\begin{figure}[h]
\[
\begin{array}{l|l}
\;\;\;\;\;\;\;\;\mathtt{Task\ 0}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{Task\ 1}\;\;\;\;\;\;\;\; \\
\hline
\;\;\;\;\;\;\;\;\mathtt{R_{0,1}(*,\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{S_{1,1}(0,\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{R_{0,2}(*,\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W{(\&h3)}}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W{(\&h2)}}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{S_{1,2}(0,\&h4)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W{(\&h1)}}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W{(\&h4)}}\;\;\;\;\;\;\;\; \\
\end{array}
\]
\caption{Nearest-enclosing Wait example} \label{fig:nw}
\end{figure}

\figref{fig:nw} shows that the wait $\mathtt{W{(\&h2)}}$
witnesses the completion of the receive $\mathtt{R_{0,1}}$ and
$\mathtt{R_{0,2}}$ in Task 0. Thus, $\mathtt{W{(\&h2)}}$ is their
nearest-enclosing wait.

We assume that every receive operation has a nearest-enclosing
wait. This assumption disallows a few a misbehaving programs, those
that receive but never wait for the operation to complete before
continuing.  (We could use the same assumption for sends, since MCAPI
allows waiting on send operations as well, but we deal with send
buffering differently.)

Given this definition, we can define the pertinent information of a
receive:

\begin{definition}[Receive] \label{def:rcv}
For every receive operation $\mathtt{R}$ we create five variables:
\begin{compactenum}
\item $M_\mathtt{R}$, the order of the matching send event;

\item $\mathit{order}_\mathtt{R}$, the order of the receive;

\item $e_\mathtt{R}$, the endpoint;

\item $\mathit{value}_\mathtt{R}$, the received valued; and,

\item $\mathit{nw}_\mathtt{R}$, the order of the nearest enclosing wait.
\end{compactenum}
\end{definition}

\subsection{Constraints}

These definitions so far merely establish the pertinent information
about each event in the trace as SMT variables. We must also express
the constraints on those variables.

The most trivial kind of constraint are those for control-flow
assumptions.

\begin{definition}[Assumption] \label{def:assm}
For every assumption $\mathtt{A}$, we add it as an SMT assertion.
\end{definition}

It may seem strange to turn \emph{assumptions} into a
\emph{assertions}, but from a constraint perspective, the assumption
that we have already observed some property (during control-flow) is
equivalent to instructing the SMT solver to treat it is inviolate
truth, or assertion.

The next level of constraint complexity comes from property
assertions. These correspond to the invariants of the program. Our
goal is to discover if they can be violated, so we instruct the SMT
solver to seek for a way to satisfy their \emph{negation} given all
the other constraints.

\begin{definition}[Property Assertion] \label{def:assert}
For every property assertion $\mathtt{P}$, we add $\neg \mathtt{P}$ as
an SMT assertion.
\end{definition}

Finally, we must express each match pair as a set of SMT
constraints. Informally, a match pair equates the shared components of
a send and receive and constrains the send to occur before the
nearest-enclosing wait of the receive. Formally:

\begin{definition}[Match Pair] \label{def:match}
A match pair, $\langle\mathtt{R}, \mathtt{S}\rangle$, for a receive
$\mathtt{R}$ and a send $\mathtt{S}$ corresponds to the constraints:
\begin{compactenum}
\item $M_{\mathtt{R}} = \mathit{order}_{\mathtt{S}}$
\item $M_{\mathtt{S}} = \mathit{order}_{\mathtt{R}}$
\item $e_{\mathtt{R}} = e_{\mathtt{S}}$
\item $\mathit{value}_{\mathtt{R}} = \mathit{value}_{\mathtt{S}}$ and
\item $\mathit{order}_{\mathtt{S}}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{nw}_{\mathtt{R}}$
\end{compactenum}
\end{definition}

However, these match pair constraints are not simply unioned. If we
were to do that, then we would be constraining the system such that a
single receive were paired with multiple sends if both were valid
match pairs. Therefore, we combine all the constraints for a receive's
match pairs into a single disjunction:

\begin{definition}[Receive Matches]
For each receive $\mathtt{R}$, if $\langle\mathtt{R},
\mathtt{S}_0\rangle$ through $\langle\mathtt{R}, \mathtt{S}_n\rangle$
are match pairs, then $\bigvee_{i}^{n} \langle\mathtt{R},
\mathtt{S}_i\rangle$ is used as an SMT constraint.
\end{definition}

This encoding of the input ensures that the SMT solver can only use
compatible send/receive pairs and ensures that sends happen ``before''
receives.

\subsection{More \emph{Happens-Before} Constraints}

The encoding is not sufficient, though. We must extend it with
additional constraints on the \emph{Happens-Before} relation, which we
do in four steps. We must ensure that sends to common endpoints occur
in program order in a single task (step 1); similarly for receives
(step 2); receives occur before their nearest-enclosing wait (step 3);
and, that sends are received in the order they are sent (step 4).

\paragraph*{Step 1} For each thread, if there are multiple send
operations, say $\mathtt{S}$ and $\mathtt{S^\prime}$, from that thread
to a common endpoint, $e_\mathtt{S} = e_\mathtt{S^\prime}$, then those
sends must follow program order: $\mathit{order}_\mathtt{S}$
$\prec_\mathtt{HB}$ $\mathit{order}_\mathtt{S^\prime}$.

\paragraph*{Step 2} For each thread, if there are multiple receive
operations, say $\mathtt{R}$ and $\mathtt{R^\prime}$, from that thread
to a common endpoint, $e_\mathtt{S} = e_\mathtt{S^\prime}$, then those
receives must follow program order: $\mathit{order}_\mathtt{R}$
$\prec_\mathtt{HB}$ $\mathit{order}_\mathtt{R^\prime}$.

\paragraph*{Step 3} For every receive \texttt{R} and its nearest
enclosing wait \texttt{W}, $\mathit{order}_\mathtt{R}$
$\prec_\mathtt{HB}$ $\mathit{order}_\mathtt{W}$.

\paragraph*{Step 4} For any pair of sends $\mathtt{S}$ and
$\mathtt{S'}$ on common endpoints, $e_{\mathtt{S}}=e_{\mathtt{S'}}$,
such that
$\mathit{order}_\mathtt{S}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{order}_\mathtt{S'}$,
then those sends must be received in the same order:
$M_{\mathtt{S}}\ \mathrm{\prec_{\mathtt{HB}}}\ M_{\mathtt{S'}}$.

For example, consider two tasks where Task 0 sends two messages to
Task 1 as shown in \figref{fig:step4}.

\begin{figure}[h]
\[
\begin{array}{l|l}
\;\;\;\;\;\;\;\;\mathtt{Task\ 0}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{Task\ 1}\;\;\;\;\;\;\;\; \\
\hline
\;\;\;\;\;\;\;\;\mathtt{S_{0,1}(1,\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,1}(*,\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{S_{0,2}(1,\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,2}(*,\&h4)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h4)}\;\;\;\;\;\;\;\; \\
\end{array}
\]
\caption{Send Ordering Example} \label{fig:step4}
\end{figure}

The \texttt{M} variables from the sends will be assigned to the orders
for $\mathtt{R_{1,1}}$ and $\mathtt{R_{1,2}}$ by the match-pairs
selected by the SMT solver. The constraints added in this step force
the send to be received in program order using the \texttt{HB}
relation which for this example yields
$\cfgnt{M}_\mathtt{S_{0,1}}\ \mathrm{\prec_\mathtt{HB}}\ \cfgnt{M}_\mathtt{S_{0,2}}$.

\subsection{Zero Buffer Semantics}

The constraints presented so far correspond to an infinite-buffer
semantics, because we do not constrain how many messages may be ``in
transit'' at once. We can add additional, orthogonal, constraints to
restrict such behavior and enforce a zero-buffer semantics. There are
two kinds of such constraints.

First, for each thread, if there are two sends $\mathtt{S}$ and
$\mathtt{S'}$ such that
$\mathit{order}_\mathtt{S}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{order}_\mathtt{S'}$,
and $\mathtt{S}$ and $\mathtt{S'}$ can both match a receive
$\mathtt{R}$, then we add the following constraint to the encoding:
$\mathit{order}_{\mathtt{W(\&h)}}\ \mathrm{\prec_{\mathtt{HB}}}\ \mathit{order}_{\mathtt{S'}}$
where $\mathtt{W(\&h)}$ is a wait function that witnesses the
completion of $\mathtt{R}$ in execution.

Second, for each pair of sends $\mathtt{S}$ and $\mathtt{S'}$, if
there is a receive $\mathtt{R}$ such that

\begin{compactenum}
\item $\mathtt{R'}$ is a preceding receive over $\mathtt{S}$ in an
  identical thread; Or

\item there exists a match pair $\langle\mathtt{R''},
  \mathtt{S''}\rangle$ such that $\langle\mathtt{R}, \mathtt{S}\rangle
  \rightarrow \langle\mathtt{R''}, \mathtt{S''}\rangle$ and
  $\langle\mathtt{R''}, \mathtt{S''}\rangle \rightarrow
  \langle\mathtt{R'}, \mathtt{S'}\rangle$.
\end{compactenum}

Then we add the following constraint to the encoding:
$\mathit{order}_{\mathtt{W(\&h)}}\ \mathrm{\prec_{\mathtt{HB}}}\ \mathit{order}_{\mathtt{S'}}$
where $\mathtt{W(\&h)}$ is a wait function that witnesses the
completion of $\mathtt{R}$ in execution.

\subsection{Example}

\begin{figure}[t]
\begin{center}
\usebox{\boxSMTc}
\end{center}
\caption{SMT Encoding} \label{fig:smt-encode}
\end{figure}

\figref{fig:smt-encode} shows the encoding of \figref{fig:mcapi} as an
SMT problem using the match pairs shown in lines \texttt{09} through
\texttt{11}. We elide the basic definition of the variables discussed
in \secref{sec:smt-defns}. The first seven lines reflect the program
order constraints, the eight and ninth lines show the assertions,
while the final three lines show the match pair constraints.

\subsection{Correctness}

Before we can state our correctness theorem, we must define a few
terms.

We define our encoder as a function from programs and match pair sets
to SMT problems:

\begin{definition}[Encoder]
For all programs, $p$, and match pair sets $m$, let $\mathcal{SMT}(p,
m)$ be our encoding as an SMT problem.
\end{definition}

We assume that an SMT solver can be represented as a function that
takes a problem and returns a satisfying assignment of variables or
unsatisfiable flag:

\begin{definition}[SMT Solver]
For all SMT problems, $s$, let $\mathcal{SOL}(s)$ be in $\sigma +
\mathbb{UNSAT}$, where $\sigma$ is a satisfying assignment of
variables to values.
\end{definition}

We assume that from a satisfying assignment to one of our SMT
problems, we can derive an execution trace by observing the values
given to each of the $\textit{order}_{e}$ variables. In other words,
we can view the SMT solver as return traces and not assignments.

We assume a semantics for traces that gives their behavior\footnote{In
  fact, our extended technical report~\cite{extended-version} gives
  such a semantics.} as either having an assertion violation or being
correct:

\begin{definition}[Semantics]
For all programs, $p$, and traces $t$, $\mathcal{SEM}(p, t)$ is either
$\mathbb{BAD}$ or $\mathbb{OK}$.
\end{definition}

Given this framework, our SMT encoding technique is sound if

\begin{theorem}[Soundness]
For all programs, $p$, and match pair sets, $m$,
$\mathcal{SOL}(\mathcal{SMT}(p, m)) = t \Rightarrow \mathcal{SEM}(p, t) =
\mathbb{BAD}$.
\end{theorem}

Our soundness proof relies on the following lemma:

\begin{lemma} \label{lem:bogus}
Any match pair $\langle \mathtt{R}, \mathtt{S}\rangle$ used in a
satisfying assignment of an SMT encoding is a valid match pair and
reflects an actual possible MCAPI program execution.
\end{lemma}
\begin{proof}
We prove this by contradiction. First, assume that $\langle
\mathtt{R}, \mathtt{S}\rangle$ is an invalid match pair (i.e. one that
is not valid in an actual MCAPI execution). Second, assume that the
SMT solver finds a satisfying assignment.

Since $\langle \mathtt{R}, \mathtt{S}\rangle$ is not a valid match
pair, match $\mathtt{R}$ and $\mathtt{S}$ requires program order,
message non-overtaking, or no-multiple match to be violated. In other
words, the \emph{Happens-Before} constraints encoded in the SMT
problem are not satisfied. 

This is a contradiction: either the SMT solver would not return an
assignment or the match pair was actually valid.
\end{proof}

The correctness of our technique also relies on completeness:

\begin{theorem}[Completeness]
For all programs, $p$, and traces, $t$, $\mathcal{SEM}(p, t) =
\mathbb{BAD} \Rightarrow \exists m . \mathcal{SOL}(\mathcal{SMT}(p,
m)) = t$.
\end{theorem}

We prove completeness in our extended version~\cite{extended-version}
by designing our semantics, $\mathcal{SEM}$, such that it simulates
the solving of the SMT problem during its operation to ensure that the
two make identical conclusions.

However, these theorems obscure an important problem: how do we know
which match pair set to use? Soundness assumes we have one, while
completeness merely asserts that one exists. While \secref{sec:mp-gen}
discusses our generation algorithm, we prove here an additional
theorem that asserts that any conservative over-approximation of match
pair sets is safe.

\begin{theorem}[Approximation]
$m \subseteq m' \Rightarrow \mathcal{SOL}(\mathcal{SMT}(p, m))
  \sqsubseteq \mathcal{SOL}(\mathcal{SMT}(p, m'))$, where
  $\mathbb{UNSAT} \sqsubseteq \sigma$.
\end{theorem}

Informally, this is true because larger match pair sets only allow
\emph{more} behavior, which means that the SMT solver has more freedom
to find violations, but that all prior violations are still
present. However, because of soundness, it is not possible that using
a larger match pair set will discover false violations. The formal
proof, in our extended version~\cite{extended-version}, relies on a
match set combination operator that we prove distributes over an
essential part of the semantics.
