\newcommand{\epsnd}{\textit{Pnd\_s}}
\newcommand{\eprcv}{\textit{Pnd\_r}}
\newcommand{\qset}{\textit{Q\_s}}
\newcommand{\snd}{\textit{snd}}
\newcommand{\rcv}{\textit{rcv}}
\newcommand{\q}{\textit{q}}
\newcommand{\frm}{\textit{frm}}
\newcommand{\vbot}{\textit{v$-\bot$}}
\newcommand{\status}{\textit{s}}
\newcommand{\last}{\textit{l}}
\newcommand{\error}{\ensuremath{\mathbf{error}}}
\newcommand{\aidmap}{\textit{A}}
\newcommand{\thread}{\ensuremath{\mathit{t}}}
\newcommand{\aid}{\ensuremath{\mathit{a}}}
\newcommand{\ploc}{\ensuremath{\rho}}
\newcommand{\loc}{\ensuremath{\mathit{l}}}
\newcommand{\cmd}{\ensuremath{\mathit{c}}}
\newcommand{\op}{\ensuremath{\mathit{op}}}
\newcommand{\applyop}{\ensuremath{\mathrm{op}}}
\newcommand{\wait}{\ensuremath{\mathbf{wait}}}
\newcommand{\sendi}{\ensuremath{\mathbf{sndi}}}
\newcommand{\recvi}{\ensuremath{\mathbf{rcvi}}}
\newcommand{\traceentry}{\ensuremath{\sigma}}
\newcommand{\movelist}{\ensuremath{\delta}}
\newcommand{\assume}{\ensuremath{\mathit{assume}}}
\newcommand{\checkassume}{\ensuremath{\mathrm{assume}}}
\newcommand{\assert}{\ensuremath{\mathit{assert}}}
\newcommand{\checkassert}{\ensuremath{\mathrm{assert}}}
\newcommand{\ep}{\ensuremath{\mathbf{\gamma}}}
\newcommand{\src}{\ensuremath{\alpha}}
\newcommand{\dst}{\ensuremath{\beta}}
\newcommand{\true}{\ensuremath{\mathbf{true}}}
\newcommand{\false}{\ensuremath{\mathbf{false}}}
\newcommand{\match}{\ensuremath{\mathrm{m}}}
\newcommand{\matchl}{\ensuremath{\mathrm{match}}}
\newcommand{\findrecv}{\ensuremath{\mathrm{search_r}}}
\newcommand{\smt}{\ensuremath{\mathit{smt}}}


\newcommand{\addsend}{\ensuremath{\mathrm{addsend}}}
\newcommand{\getsend}{\ensuremath{\mathrm{getsend}}}
\newcommand{\removesend}{\ensuremath{\mathrm{removesend}}}
\newcommand{\addrecv}{\ensuremath{\mathrm{addrecv}}}
\newcommand{\getrecv}{\ensuremath{\mathrm{getrecv}}}
\newcommand{\removerecv}{\ensuremath{\mathrm{removefrecv}}}
\newcommand{\hextend}{\ensuremath{\mathrm{hextend}}}
\newcommand{\hlookup}{\ensuremath{\mathrm{hlookup}}}
\newcommand{\etalookup}{\ensuremath{\mathrm{etalookup}}}
\newcommand{\checkmatch}{\ensuremath{\mathrm{checkmatch}}}
\newcommand{\getep}{\ensuremath{\mathrm{getEP}}}
\newcommand{\getmarkremove}{\ensuremath{\mathrm{getMarkRemove}}}
\newcommand{\getlastsendreplace}{\ensuremath{\mathrm{getlastsend/replace}}}
\newcommand{\statuschange}{\left\{ \begin{array}{ll}  \status &\ \mathrm{if}\ |\epsnd(\dst)(\src)|>0\\
   \mathit{error} &\  \mathrm{otherwise}\end{array}\right .}

\newcommand{\reduce}[1]{\ensuremath{\rightarrow_{#1}}}
% Multiple reductions
\newcommand{\reduceK}[1]{\ensuremath{\rightarrow_{#1}^{*}}}
% Non-deterministic reductions
\newcommand{\reduceN}[1]{\ensuremath{\dashrightarrow_{#1}}}
\newcommand{\reduceNK}[1]{\ensuremath{\dashrightarrow_{#1}^{*}}}
\newcommand{\mt}{\ensuremath{\emptyset}}
\newcommand{\trace}{\ensuremath{\mathit{trace}}}
\newcommand{\movebot}{\ensuremath{\mathit{m}}}
\newcommand{\ret}{\ensuremath{\mathbf{ret}}}

\newcommand{\defs}{\ensuremath{\mathrm{defs}}}
\newcommand{\any}{\ensuremath{\mathrm{any}}}
\newcommand{\negate}{\ensuremath{\mathrm{not}}}
\newcommand{\define}{\ensuremath{\mathrm{define}}}
\newcommand{\andd}{\ensuremath{\mathrm{and}}}
\newcommand{\select}{\ensuremath{\mathrm{select}}}
\newcommand{\HB}{\ensuremath{\mathrm{HB}}}
\newcommand{\getlast}{\ensuremath{\mathrm{last}}}
\newcommand{\MATCH}{\ensuremath{\mathrm{MATCH}}}
\newcommand{\ml}{\ensuremath{\mathit{ML}}}
\newcommand{\matchpair}{\ensuremath{\mathrm{MP}}}
\newcommand{\recv}{\ensuremath{\mathrm{\mu}}}
\newcommand{\send}{\ensuremath{\mathrm{\nu}}}

\newsavebox{\boxSMTa}
\begin{lrbox}{\boxSMTa}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h1)}}$}\\
\texttt{01 $\mathit{event_\mathtt{R_{0,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h2)}}$}\\
\texttt{02 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{R_{0,5}}}$}\\
\texttt{03 $\mathit{event_\mathtt{R_{1,3}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h3)}}$}\\
\texttt{04 $\mathit{event_\mathtt{S_{1,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h4)}}$}\\
\texttt{05 $\mathit{event_\mathtt{S_{2,4}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h5)}}$}\\
\texttt{06 $\mathit{event_\mathtt{S_{2,7}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h6)}}$}\\
\texttt{07 ($\mathit{assert}$ (> b 0))}\\
\texttt{08 ($\mathit{assert}$ (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{09 $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{2,4}}\rangle$}\\
\texttt{10 $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{1,5}}\rangle$}\\
\texttt{11 $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTb}
\begin{lrbox}{\boxSMTb}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h1)}}$}\\
\texttt{01 $\mathit{event_\mathtt{R_{0,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h2)}}$}\\
\texttt{02 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{R_{0,5}}}$}\\
\texttt{03 $\mathit{event_\mathtt{R_{1,3}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h3)}}$}\\
\texttt{04 $\mathit{event_\mathtt{S_{1,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h4)}}$}\\
\texttt{05 $\mathit{event_\mathtt{S_{2,4}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h5)}}$}\\
\texttt{06 $\mathit{event_\mathtt{S_{2,7}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h6)}}$}\\
\texttt{07 ($\mathit{assert}$ (> b 0))}\\
\texttt{08 ($\mathit{assert}$ (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{09 $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{1,5}}\rangle$}\\
\texttt{10 $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{2,4}}\rangle$}\\
\texttt{11 $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTc}
\begin{lrbox}{\boxSMTc}
\normalsize
\begin{tabular}[t]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h1)}}$}\\
\texttt{01 $\mathit{event_\mathtt{R_{0,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h2)}}$}\\
\texttt{02 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{R_{0,5}}}$}\\
\texttt{03 $\mathit{event_\mathtt{R_{1,3}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h3)}}$}\\
\texttt{04 $\mathit{event_\mathtt{S_{1,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h4)}}$}\\
\texttt{05 $\mathit{event_\mathtt{S_{2,4}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h5)}}$}\\
\texttt{06 $\mathit{event_\mathtt{S_{2,7}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h6)}}$}\\
\texttt{07 ($\mathit{assert}$ (> b 0))}\\
\texttt{08 ($\mathit{assert}$ (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{09} $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{2,4}}\rangle\vee\langle\mathtt{R_{0,2}}$,$\mathtt{S_{1,5}}\rangle$\\
\texttt{10} $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{2,4}}\rangle\vee\langle\mathtt{R_{0,5}}$,$\mathtt{S_{1,5}}\rangle$\\
\texttt{11} $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxMP}
\begin{lrbox}{\boxMP}
\normalsize
\begin{tabular}[t]{l}
\\\\\\\\\\\\\\\\\\
$\langle\mathtt{R_{0,2}}$, $\mathtt{S_{2,4}}\rangle$\\
$\langle\mathtt{R_{0,2}}$, $\mathtt{S_{1,5}}\rangle$\\
\\
$\langle\mathtt{R_{0,5}}$, $\mathtt{S_{2,4}}\rangle$\\
$\langle\mathtt{R_{0,5}}$, $\mathtt{S_{1,5}}\rangle$\\
\\
$\langle\mathtt{R_{1,3}}$, $\mathtt{S_{2,7}}\rangle$\\
\end{tabular}
\end{lrbox}

\section{SMT Encoding}\label{sec:smt}

The novelty of the SMT encoding in this paper is its use of match
pairs rather than the state-based or order-based encoding of prior
work~\cite{elwakil:padtad10,elwakil:atva10}. The algorithm to create
the encoding takes as input a set of possible match pairs and a trace
through an MCAPI program with the appropriate assumes and asserts as
shown in \figref{fig:trace}.

A match pair is the coupling of a receive to a particular
send. \figref{fig:smt}(a) is the set of possible match pairs for the
program in \figref{fig:mcapi} using our shorthand notation defined in
\figref{fig:trace}. The set admits, for example, that
$\mathtt{R_{0,2}}$ can be matched with either $\mathtt{S_{1,5}}$ or
$\mathtt{S_{2,4}}$.

The SMT encoding in this paper asks the SMT solver to resolve the
match pairs for the system in such a way that the final values of
program variables meet the assumption on control flow but violate some
assertion. This resolution by the SMT solver is accomplished by having
the solver complete a partial order on events into a total order that
determines final match-pair relationships.

\subsection{Definitions}

Our encoder creates a number of SMT terms for each operation in the
trace.

\begin{definition}[Wait]
For a wait operation \texttt{W}, we create a corresponding variable
$\mathit{event}_\mathtt{W} \in \mathbb{N}$, where $\mathbb{N}$ is the
set of natural numbers. This variable will be assigned by the solver
to its location in the total order of the program trace.
\label{def:event}
\end{definition}

\begin{definition}[Send]
For every send operation $\mathtt{S}$ we create a tuple of variables
$(M,\mathit{event}, e,\mathit{value})$ such that $\mathit{M}$,
$\mathit{event}$, $\mathit{e}$, $\mathit{value}$ $ \in
\mathbb{N}$. $M$ and $\mathit{event}$ will eventually be assigned, by
the SMT solver, the point in the total order of the corresponding
matching receive event and the point at which this send appears in the
total order of the same trace. The variables $e$ and $\mathit{value}$
are assigned the endpoint and actual value contained in the send
operation.
\label{def:snd}
\end{definition}

\begin{definition}[Nearest-Enclosing Wait]
The nearest-enclosing wait for a receive witnesses the completion of
the receive indicating that the message is delivered and that all the
previous receives in the same task issued earlier are complete as
well.
\label{def:nw}
\end{definition}

This constraint is required by the message non-overtaking property in
the MCAPI specification. 

The example below shows that the wait $\mathtt{W{(\&h2)}}$ witnesses
the completion of the receive $\mathtt{R_{0,1}}$ and
$\mathtt{R_{0,2}}$ in Task 0. As such, the wait $\mathtt{W{(\&h2)}}$
is their nearest-enclosing wait. Please note that the encoding in this
paper does not utilize the wait for sends as part of how it manages
the different buffering semantics. Further, this paper assumes that
each receive operation has a nearest enclosing wait in the trace.

\[
\begin{array}{l|l}
\;\;\;\;\;\;\;\;\mathtt{Task\ 0}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{Task\ 1}\;\;\;\;\;\;\;\; \\
\hline
\;\;\;\;\;\;\;\;\mathtt{R_{0,1}(*,\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{S_{1,1}(0,\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{R_{0,2}(*,\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W{(\&h3)}}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W{(\&h2)}}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{S_{1,2}(0,\&h4)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W{(\&h1)}}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W{(\&h4)}}\;\;\;\;\;\;\;\; \\
\end{array}
\]

\begin{definition}[Receive]
For every receive operation $\mathtt{R}$ we create a tuple of
variables $(M,\mathit{value},\mathit{event},e,\mathit{NW})$ similar to
send. In the receive case, $M$, $\mathit{value}$ and $\mathit{event}$
will eventually be assigned, by the SMT solver, the point in the total
order of the corresponding send event with its sent value and the
point at which this receive appears in the total order of the same
trace. The variables $e$ and $\mathit{NW}$ are assigned the endpoint
and the corresponding variable representing the point in the total
order of the nearest enclosing wait.
\label{def:rcv}
\end{definition}

For convenience, we use $\mathtt{op} \in \{\mathtt{S}, \mathtt{R},
\mathtt{W}\}$ as a subscript to indicate variables associated with different
operations in the trace such as $\mathit{event}_\mathtt{op}$,
$M_{\mathtt{op}}$, $e_{\mathtt{op}}$, $value_{\mathtt{op}}$,
etc.\footnote{For brevity the presentation omits the subscript and
  parameter details in the \texttt{S}, \texttt{R}, and \texttt{W}
  operations, but these details are used to uniquely identify each
  operation in the figures and examples.}

\begin{definition}[Happens-Before]
The \emph{Happens-Before} $(\mathtt{HB})$ relation denoted as $\mathrm{\prec_\mathtt{HB}}$ is a partial order defined over variables. Given any two variables for event order $event_{\mathtt{op}}$ and $event_{\mathtt{op'}}$, $event_{\mathtt{op}}$ $\mathrm{\prec_{\mathtt{HB}}}$ $event_{\mathtt{op'}}$ if and only if $\mathtt{op}$ must complete before $\mathtt{op'}$ in a valid program execution.
\label{def:hb}
\end{definition}

\begin{definition}[Match Pair]
For a send $\mathtt{S}=(M_\mathtt{S},\mathit{event}_\mathtt{S}, e_\mathtt{S},\mathit{value}_\mathtt{S})$ and a receive $\mathtt{R}=(M_\mathtt{R},\mathit{value}_\mathtt{R}, \mathit{event}_\mathtt{R}, e_\mathtt{R},\mathit{NW}_\mathtt{R})$, a match pair, $\langle\mathtt{R}, \mathtt{S}\rangle$, is created by adding the constraints
\begin{compactenum}
\item $M_{\mathtt{R}} = event_{\mathtt{S}}$
\item $M_{\mathtt{S}} = event_{\mathtt{R}}$
\item $e_{\mathtt{R}} = e_{\mathtt{S}}$
\item $value_{\mathtt{R}} = value_{\mathtt{S}}$ and
\item $event_{\mathtt{S}}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{NW}_{\mathtt{R}}$
\end{compactenum}
\label{def:match}
\end{definition}

A match-pair only allows the SMT solver to use compatible send/receive
pairs, but more critically, the added ordering in the \texttt{HB}
relation ensures that the send completes before the witness to the
receive to enable the infinite-buffer semantics. There are no other
constraints on a send beyond program order and that only when the
sends target a common endpoint. In such a situation, we use the
\texttt{HB} relation between the sends to prevent message overtaking in
any final total order from the SMT solver.

\subsection{Infinite Buffer Semantics}

The infinite-buffer SMT encoding proceeds in several stages given a
trace and potential match-pairs. Intuitively, the \texttt{HB} relation
asserts that sends and receives with common endpoints and in the same
task follow program order (stages 2 and 3); a receive operation must
happen before its nearest-enclosing wait (stage 4); sends must be
received in the same order they are sent (stage 5); control flow is
enforced and assert violations are detected (stages 6 and 7); and
finally, only one match-pair can be resolved for any given receive
(stage 8).

\paragraph*{Step 1} Create all the necessary variables for the sends,
receives, waits, and other program variables in the trace and
initialize the static fields of the send and receive variables.

\paragraph*{Step 2} For each thread, if there are multiple send
operations, say $\mathtt{S}$ and $\mathtt{S^\prime}$, from that thread
to a common endpoint, $e_\mathtt{S} = e_\mathtt{S^\prime}$, then those
sends must follow program order: $\mathit{event}_\mathtt{S}$
$\prec_\mathtt{HB}$ $\mathit{event}_\mathtt{S^\prime}$.

\paragraph*{Step 3} For each thread, if there are multiple receive
operations, say $\mathtt{R}$ and $\mathtt{R^\prime}$, from that thread
to a common endpoint, $e_\mathtt{S} = e_\mathtt{S^\prime}$, then those
receives must follow program order: $\mathit{event}_\mathtt{R}$
$\prec_\mathtt{HB}$ $\mathit{event}_\mathtt{R^\prime}$.

\paragraph*{Step 4} For every receive \texttt{R} and its nearest
enclosing wait \texttt{W}, $\mathit{event}_\mathtt{R}$
$\prec_\mathtt{HB}$ $\mathit{event}_\mathtt{W}$.

\paragraph*{Step 5} For any pair of sends $\mathtt{S}$ and
$\mathtt{S'}$ on common endpoints, $e_{\mathtt{S}}=e_{\mathtt{S'}}$,
such that
$\mathit{event}_\mathtt{S}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{event}_\mathtt{S'}$,
then those sends must be received in the same order:
$M_{\mathtt{S}}\ \mathrm{\prec_{\mathtt{HB}}}\ M_{\mathtt{S'}}$.

Consider a simple example below that sends two messages from a Task 0
to Task 1,

\[
\begin{array}{l|l}
\;\;\;\;\;\;\;\;\mathtt{Task\ 0}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{Task\ 1}\;\;\;\;\;\;\;\; \\
\hline
\;\;\;\;\;\;\;\;\mathtt{S_{0,1}(1,\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,1}(*,\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{S_{0,2}(1,\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,2}(*,\&h4)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h4)}\;\;\;\;\;\;\;\; \\
\end{array}
\]

The \texttt{M} variables in the send tuples will be assigned to the
order tracking events for $\mathtt{R_{1,1}}$ and $\mathtt{R_{1,2}}$ by
the match-pairs selected by the SMT solver. The constraints added in
stage 5 force the send events to be received in program order using
the \texttt{HB} relation which for our simple example yields
$\cfgnt{M}_\mathtt{S_{0,1}}\ \mathrm{\prec_\mathtt{HB}}\ \cfgnt{M}_\mathtt{S_{0,2}}$.

\paragraph*{Step 6} For every assume representing control flow
resolution, add an assert constraint.

\paragraph*{Step 7} For every assert representing a checked property,
add its negated form as a constraint since our goal is to resolve
non-determinism in match-pairs in a way that violates the assertion
while following the same control flow.

\paragraph*{Step 8} For every match pair $\langle\mathtt{R},
\mathtt{S}\rangle$, add the constraints from $\langle\mathtt{R},
\mathtt{S}\rangle$ in \defref{def:match} to the encoding. If a receive
can match to multiple potential sends $\langle\mathtt{R},
\mathtt{S}\rangle$ and $\langle\mathtt{R}, \mathtt{S^\prime}\rangle$,
combine the sets of constraints in a disjunction: $\langle\mathtt{R},
\mathtt{S}\rangle$ $\vee$ $\langle\mathtt{R},
\mathtt{S^\prime}\rangle$.

\subsection{Zero Buffer Semantics}

For zero-buffer semantics, we further constrain the encoding to
preclude orderings that can only occur with buffering.

\begin{definition}[Matching Dependent Relation]
A matching dependent relation denoted as $\rightarrow$ over two match
pairs $\langle\mathtt{R}, \mathtt{S}\rangle$ and $\langle\mathtt{R'},
\mathtt{S'}\rangle$ is satisfied if and only if
\begin{compactenum}
\item $\mathtt{R'}$ is a preceding receive over $\mathtt{S}$ in an
  identical thread; Or
\item there exists a match pair $\langle\mathtt{R''},
  \mathtt{S''}\rangle$ such that $\langle\mathtt{R}, \mathtt{S}\rangle
  \rightarrow \langle\mathtt{R''}, \mathtt{S''}\rangle$ and
  $\langle\mathtt{R''}, \mathtt{S''}\rangle \rightarrow
  \langle\mathtt{R'}, \mathtt{S'}\rangle$.
\end{compactenum}
\end{definition}

The zero-buffer SMT encoding proceeds in two stages given a generated
infinite-buffer SMT encoding:

\paragraph*{Step 9} For each thread, if there are two sends
$\mathtt{S}$ and $\mathtt{S'}$ such that
$\mathit{event}_\mathtt{S}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{event}_\mathtt{S'}$,
and $\mathtt{S}$ and $\mathtt{S'}$ can both match a receive
$\mathtt{R}$, then add the following HB relation to the encoding:
$event_{\mathtt{W(\&h)}}\ \mathrm{\prec_{\mathtt{HB}}}\ event_{\mathtt{S'}}$
where $\mathtt{W(\&h)}$ is a wait function that witnesses the
completion of $\mathtt{R}$ in execution.

\paragraph*{Step 10} For each pair of sends $\mathtt{S}$ and $\mathtt{S'}$, if there
is a receive $\mathtt{R}$ such that $\langle\mathtt{R},
\mathtt{S'}\rangle\rightarrow\langle\mathtt{R}, \mathtt{S}\rangle$,
add the following HB relation to the encoding:
$event_{\mathtt{W(\&h)}}\ \mathrm{\prec_{\mathtt{HB}}}\ event_{\mathtt{S'}}$
where $\mathtt{W(\&h)}$ is a wait function that witnesses the
completion of $\mathtt{R}$ in execution.

\subsection{Example}

As an intuitive example, we revisit the example in
\figref{fig:mcapi}. In order to prevent $\mathtt{R_{1,3}}$ from being matched
with $\mathtt{S_{2,6}}$ before $\mathtt{R_{0,2}}$ is matched with
$\mathtt{S_{2,4}}$, add
$\mathit{event}_\mathtt{W(\&h1)}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{event}_\mathtt{S_{1,5}}$.

\begin{figure}
\begin{center}
\setlength{\tabcolsep}{20pt}
\begin{tabular}[t]{cc}
\scalebox{0.7}{\usebox{\boxMP}} &
\scalebox{0.7}{\usebox{\boxSMTc}} \\\\
(a) & (b)
\end{tabular}
\end{center}
\caption{A match pair set and SMT encoding of the system in \figref{fig:mcapi}.
(a) The match pairs based on endpoints. (b) The SMT encoding where $\mathtt{\prec_\mathtt{HB}}$ creates a
\emph{Happens-Before} constraint, a pair surrounded by $\langle$ and $\rangle$ creates a match pair constraint, and $\mathtt{assume}$ and $\mathtt{assert}$ creates an assume and assert, respectively.}
\label{fig:smt}
\end{figure}

\figref{fig:smt}(b) is the final encoding for the trace which is
explained here. The encoding is divided into three sections:
\textit{SMT = \{defs constraints match\}}. Stage 1 is not shown
because the definitions are not novel to our solution; suffice to say
that variables are created as defined. The constraints section is
created by stages 2-7. Lines \texttt{00} - \texttt{06} reflect program
orders in the trace. Lines \texttt{07} and \texttt{08} for the assume
and assert commands of the original execution trace in
\figref{fig:trace}. The first assert on line \texttt{07} (line
\texttt{14} at trace 1) prevents the SMT solver from finding solutions
that are not consistent with control flow which requires ``$b \ge
0$". The second assert on line \texttt{08} is negated as the goal is
to find schedules that violate the property. Finally, stage 8
generates the $\mathit{match}$ ``area" of the SMT encoding. In
particular, we send the set of match pairs in \figref{fig:smt}(a) to
the algorithm and generate each match pair and collect those on the
same receive into a disjunction on line \texttt{09} - \texttt{11}.

\subsection{Correctness}

Other than the basic structure of the SMT encoding, we use the
function
\[\mathrm{ANS}(\mathit{smt}) \mapsto \{\mathrm{\cfgt{SAT}},\mathrm{\cfgt{UNSAT}}\} \]
to return the solution of an SMT problem, such that
$\mathrm{\cfgt{SAT}}$ represents a satisfiable solution that finds a
trace of the MCAPI program execution that violates the user defined
correctness property, and $\mathrm{\cfgt{UNSAT}}$ represents an
unsatisfiable solution indicating that all possible execution traces
either meet the correctness property in the same control flow, or
follow a different control flow. Note that $\mathrm{\cfgt{UNSAT}}$ and
$\mathrm{\cfgt{SAT}}$ are ordered such that $\mathrm{\cfgt{UNSAT}} <
\mathrm{\cfgt{SAT}}$.

The SMT encoding defined above is used to capture the
non-deterministic behaviors of an MCAPI program execution by giving a
complete set of match pairs. As we discussed in the previous section,
the MCAPI program in \figref{fig:mcapi} contains two outcomes of
execution as defined in the MCAPI specification under the
infinite-buffer semantics. The SMT encoding we present in
\figref{fig:smt}(b) captures both execution traces, since the set of
match pairs in \figref{fig:smt}(a) is a complete set where all matches
that can occur in the real execution for our running example in
\figref{fig:mcapi} are included, and all matches that cannot occur in
the real execution are not included. Further, the following theorem
states that we can over-approximate the true set of match pairs and
still prove correctness. If there is no error with the
over-approximated set, then there is no error arising from
non-determinism in the runtime on that program execution. If there is
an error from the over-approximated set, that error is also guaranteed
to be a real error in the program runtime. Note that two SMT problems
$\smt_{\alpha}$ and $\smt_{\beta}$ in the following theorem have
identical $\mathit{defs}$ and $\mathit{constraints}$ sets, and differ
only by match set.

\begin{theorem}
The relation for the solutions of two SMT problems $\smt_{\alpha}$ $= (\mathit{defs}$ $\mathit{constraints}$ $\mathit{match}_{\alpha})$ and $\smt_{\beta}$ $= (\mathit{defs}$ $\mathit{constraints}$ $\mathit{match_{\beta}})$ is,
\[\mathrm{ANS}(\smt_{\alpha}) \leq \mathrm{ANS}(\smt_{\beta})\]
where $\mathit{set(match_{\alpha})} \subseteq \mathit{set(match_{\beta})}$. Note that $\mathit{set(match)}$ represents the input set of match pairs in the $\mathit{match}$ field.
\label{thm:1}
\end{theorem}

\begin{figure}[h]
\begin{center}
\setlength{\tabcolsep}{3pt}
\begin{tabular}[c]{cc}
%\scalebox{0.7}{\usebox{\boxMP}} &
\scalebox{0.7}{\usebox{\boxSMTa}} &
\scalebox{0.7}{\usebox{\boxSMTb}} \\\\
%\scalebox{0.7}{\usebox{\boxSMTc}} \\
(a) & (b)
\end{tabular}
\end{center}
\caption{Two SMT encodings of the system in \figref{fig:mcapi}.
(a) The SMT encoding for Trace 1 in \figref{fig:trace}. (b) The SMT encoding for Trace 2 in \figref{fig:trace}.}
\label{fig:smt_trace}
\end{figure}

\begin{proof}[Proof Sketch]
Consider the MCAPI program in \figref{fig:mcapi} as an example.
\figref{fig:smt_trace}(a) and (b) are two different SMT encodings for our running
example in \figref{fig:mcapi} generated from different sets of
possible match pairs, such that \figref{fig:smt_trace}(a) encodes
trace 1 in \figref{fig:trace} and \figref{fig:smt_trace}(b) encodes
trace 2 in \figref{fig:trace}. By solving the encodings in
\figref{fig:smt_trace}(a) and (b) for trace 1 and 2 in
\figref{fig:trace} respectively, we get an unsatisfiable solution for
\figref{fig:smt_trace}(a), and a satisfiable solution for
\figref{fig:smt_trace}(b). As we discussed in Section 2, trace 1 is an
execution trace without failure of the assertion, and trace 2 is the
one that fails the assertion.

Compare both encodings with that in \figref{fig:smt}(b), we find that
the fields $\mathit{defs}$ and $\mathit{constraints}$ are identical
except for the set of match pairs. In particular, the input set of
match pairs of either \figref{fig:smt_trace}(a) or (b) is the subset
of that in \figref{fig:smt}(b). As discussed above, the encoding in
\figref{fig:smt}(b) captures the non-deterministic behaviors of our
running program in \figref{fig:mcapi}, which encodes trace 1 and 2 in
\figref{fig:trace} into one single SMT problem. Thus, an SMT solver
will return a satisfiable solution for the encoding in
\figref{fig:smt}(b). Thus, $\mathrm{ANS}$ on the encoding in
\figref{fig:smt}(b) is greater than or equal to the $\mathrm{ANS}$ on
the encoding in either \figref{fig:smt_trace}(a) or (b). In other
words, adding more match pairs can only move the $\mathrm{ANS}$ from
$\mathrm{\cfgt{UNSAT}}$ to $\mathrm{\cfgt{SAT}}$.
\end{proof}

The formal proof of \thmref{thm:1} is in the long version of our
paper\footnote{\texttt{http://students.cs.byu.edu/$\sim$yhuang2/downloads\\/paper.pdf}}. The
proof defines a formal operational semantics given by a term rewriting
system using a \textit{CESK}\footnote{The \textit{CESK} machine state
  is represented with a \textbf{C}ontrol string, \textbf{E}nvironment,
  \textbf{S}tore, and \textbf{K}ontinuation.} style machine only the
machine is augmented to include additional structure for modeling
message passing. The operational framework defines how to execute a
program, following the specified trace, and defines when that
execution is a success (causes no assertion violation), a failure
(causes an assertion violation), infeasible (causes an assume to not
hold), or an error (execution is not allowed by the MCAPI
semantics.). Further, the machine generates the terms of the SMT
encoding as it rewrites the machine states. The proof defines a
combination operator and shows that several SMT encodings can be
combined such that the combined SMT encoding returns
$\mathrm{\cfgt{SAT}}$ if one of those encodings has a satisfiable
solution.  As such, Theorem 1 is formally proved by applying the
combination operator for $\smt_{\alpha}$ and $\smt_{\beta}$.

Assume $\mathit{set(match_{\alpha})}$ and
$\mathit{set(match_{\beta})}$ in the theorem above a complete set of
match pairs and an over-approximated set, respectively, we can further
prove that $\mathrm{ANS}(\smt_{\alpha})$ $ = $
$\mathrm{ANS}(\smt_{\beta})$ by giving the following theorem. Note
that a match pair $\langle \mathtt{R},\mathtt{S}\rangle \in
\mathit{set(match_{\beta})}/\mathit{set(match_{\alpha})}$ is called
``bogus", since it cannot exist in a real execution of the program.

\begin{theorem} \label{thm:two}
Any match pair $\langle \mathtt{R}, \mathtt{S}\rangle$ used in a
satisfying assignment of an SMT encoding $\smt$ is a valid match pair
and reflects an actual possible MCAPI program execution.
\end{theorem}

\begin{proof}
Proof by contradiction. Assume that $\langle \mathtt{R},
\mathtt{S}\rangle$ is a ``bogus" match pair that causes
$\mathrm{ANS}(\smt) = \cfgt{SAT}$. Since $\langle \mathtt{R},
\mathtt{S}\rangle$ is not a valid match pair, match $\mathtt{R}$ and
$\mathtt{S}$ requires program order, message non-overtaking, or
no-multiple match to be violated. In other words, the $\mathtt{HB}$
constraints encoded in $\smt$ are not satisfied. Based on the fact
above, the answer of $\smt$ is $\cfgt{UNSAT}$ and it contradicts the
previous hypothesis. Thus, $\langle \mathtt{R}, \mathtt{S}\rangle$ is
a valid match pair in $\smt$ and reflects an actual possible MCAPI
program execution.
\end{proof}

By proving \thmref{thm:two}, we infer that a ``bogus" match pair can
only cause an unsatisfying assignment of an SMT problem. Further, if
$\mathit{set(match_{\alpha})}$ and $\mathit{set(match_{\beta})}$
reflect a complete set and a over-approximated set respectively, the
answers of $\smt_{\alpha}$ and $\smt_{\beta}$ discussed above are
equal since any ``bogus" match pair involved in $\smt_{\beta}$ is only
used in unsatisfying assignments.

