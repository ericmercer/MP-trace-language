\newcommand{\epsnd}{\textit{Pnd\_s}}
\newcommand{\eprcv}{\textit{Pnd\_r}}
\newcommand{\qset}{\textit{Q\_s}}
\newcommand{\snd}{\textit{snd}}
\newcommand{\rcv}{\textit{rcv}}
\newcommand{\q}{\textit{q}}
\newcommand{\frm}{\textit{frm}}
\newcommand{\vbot}{\textit{v$-\bot$}}
\newcommand{\status}{\textit{s}}
\newcommand{\last}{\textit{l}}
\newcommand{\error}{\ensuremath{\mathbf{error}}}
\newcommand{\aidmap}{\textit{A}}
\newcommand{\thread}{\ensuremath{\mathit{t}}}
\newcommand{\aid}{\ensuremath{\mathit{a}}}
\newcommand{\ploc}{\ensuremath{\rho}}
\newcommand{\loc}{\ensuremath{\mathit{l}}}
\newcommand{\cmd}{\ensuremath{\mathit{c}}}
\newcommand{\op}{\ensuremath{\mathit{op}}}
\newcommand{\applyop}{\ensuremath{\mathrm{op}}}
\newcommand{\wait}{\ensuremath{\mathbf{wait}}}
\newcommand{\sendi}{\ensuremath{\mathbf{sndi}}}
\newcommand{\recvi}{\ensuremath{\mathbf{rcvi}}}
\newcommand{\traceentry}{\ensuremath{\sigma}}
\newcommand{\movelist}{\ensuremath{\delta}}
\newcommand{\assume}{\ensuremath{\mathit{assume}}}
\newcommand{\checkassume}{\ensuremath{\mathrm{assume}}}
\newcommand{\assert}{\ensuremath{\mathit{assert}}}
\newcommand{\checkassert}{\ensuremath{\mathrm{assert}}}
\newcommand{\ep}{\ensuremath{\mathbf{\gamma}}}
\newcommand{\src}{\ensuremath{\alpha}}
\newcommand{\dst}{\ensuremath{\beta}}
\newcommand{\true}{\ensuremath{\mathbf{true}}}
\newcommand{\false}{\ensuremath{\mathbf{false}}}
\newcommand{\match}{\ensuremath{\mathrm{m}}}
\newcommand{\matchl}{\ensuremath{\mathrm{match}}}
\newcommand{\findrecv}{\ensuremath{\mathrm{search_r}}}
\newcommand{\smt}{\ensuremath{\mathit{smt}}}


\newcommand{\addsend}{\ensuremath{\mathrm{addsend}}}
\newcommand{\getsend}{\ensuremath{\mathrm{getsend}}}
\newcommand{\removesend}{\ensuremath{\mathrm{removesend}}}
\newcommand{\addrecv}{\ensuremath{\mathrm{addrecv}}}
\newcommand{\getrecv}{\ensuremath{\mathrm{getrecv}}}
\newcommand{\removerecv}{\ensuremath{\mathrm{removefrecv}}}
\newcommand{\hextend}{\ensuremath{\mathrm{hextend}}}
\newcommand{\hlookup}{\ensuremath{\mathrm{hlookup}}}
\newcommand{\etalookup}{\ensuremath{\mathrm{etalookup}}}
\newcommand{\checkmatch}{\ensuremath{\mathrm{checkmatch}}}
\newcommand{\getep}{\ensuremath{\mathrm{getEP}}}
\newcommand{\getmarkremove}{\ensuremath{\mathrm{getMarkRemove}}}
\newcommand{\getlastsendreplace}{\ensuremath{\mathrm{getlastsend/replace}}}
\newcommand{\statuschange}{\left\{ \begin{array}{ll}  \status &\ \mathrm{if}\ |\epsnd(\dst)(\src)|>0\\
   \mathit{error} &\  \mathrm{otherwise}\end{array}\right .}

\newcommand{\reduce}[1]{\ensuremath{\rightarrow_{#1}}}
% Multiple reductions
\newcommand{\reduceK}[1]{\ensuremath{\rightarrow_{#1}^{*}}}
% Non-deterministic reductions
\newcommand{\reduceN}[1]{\ensuremath{\dashrightarrow_{#1}}}
\newcommand{\reduceNK}[1]{\ensuremath{\dashrightarrow_{#1}^{*}}}
\newcommand{\mt}{\ensuremath{\emptyset}}
\newcommand{\trace}{\ensuremath{\mathit{trace}}}
\newcommand{\movebot}{\ensuremath{\mathit{m}}}
\newcommand{\ret}{\ensuremath{\mathbf{ret}}}

\newcommand{\defs}{\ensuremath{\mathrm{defs}}}
\newcommand{\any}{\ensuremath{\mathrm{any}}}
\newcommand{\negate}{\ensuremath{\mathrm{not}}}
\newcommand{\define}{\ensuremath{\mathrm{define}}}
\newcommand{\andd}{\ensuremath{\mathrm{and}}}
\newcommand{\select}{\ensuremath{\mathrm{select}}}
\newcommand{\HB}{\ensuremath{\mathrm{HB}}}
\newcommand{\getlast}{\ensuremath{\mathrm{last}}}
\newcommand{\MATCH}{\ensuremath{\mathrm{MATCH}}}
\newcommand{\ml}{\ensuremath{\mathit{ML}}}
\newcommand{\matchpair}{\ensuremath{\mathrm{MP}}}
\newcommand{\recv}{\ensuremath{\mathrm{\mu}}}
\newcommand{\send}{\ensuremath{\mathrm{\nu}}}



\newsavebox{\boxSMTa}
\begin{lrbox}{\boxSMTa}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathtt{R_{0,2}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h1)}$.event}\\
\texttt{01 $\mathtt{W(\&h1)}$.event $\mathrm{\prec_{HB}}$ $\mathtt{R_{0,5}}$.event}\\
\texttt{02 $\mathtt{R_{0,5}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h2)}$.event}\\
\texttt{03 $\mathtt{W(\&h2)}$.event $\mathrm{\prec_{HB}}$ assume.event}\\
\texttt{04 assume.event $\mathrm{\prec_{HB}}$ assert.event}\\
\texttt{05 $\mathtt{R_{1,3}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h3)}$.event}\\
\texttt{06 $\mathtt{W(\&h3)}$.event $\mathrm{\prec_{HB}}$ $\mathtt{S_{1,5}}$.event}\\
\texttt{07 $\mathtt{S_{1,5}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h4)}$.event}\\
\texttt{08 $\mathtt{S_{2,4}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h5)}$.event}\\
\texttt{09 $\mathtt{W(\&h5)}$.event $\mathrm{\prec_{HB}}$ $\mathtt{S_{2,7}}$.event}\\
\texttt{10 $\mathtt{S_{2,7}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h6)}$.event}\\
\texttt{11 (assert (> b 0))}\\
\texttt{12 (assert (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{13 $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{2,4}}\rangle$}\\
\texttt{14 $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{1,5}}\rangle$}\\
\texttt{15 $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTb}
\begin{lrbox}{\boxSMTb}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathtt{R_{0,2}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h1)}$.event}\\
\texttt{01 $\mathtt{W(\&h1)}$.event $\mathrm{\prec_{HB}}$ $\mathtt{R_{0,5}}$.event}\\
\texttt{02 $\mathtt{R_{0,5}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h2)}$.event}\\
\texttt{03 $\mathtt{W(\&h2)}$.event $\mathrm{\prec_{HB}}$ assume.event}\\
\texttt{04 assume.event $\mathrm{\prec_{HB}}$ assert.event}\\
\texttt{05 $\mathtt{R_{1,3}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h3)}$.event}\\
\texttt{06 $\mathtt{W(\&h3)}$.event $\mathrm{\prec_{HB}}$ $\mathtt{S_{1,5}}$.event}\\
\texttt{07 $\mathtt{S_{1,5}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h4)}$.event}\\
\texttt{08 $\mathtt{S_{2,4}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h5)}$.event}\\
\texttt{09 $\mathtt{W(\&h5)}$.event $\mathrm{\prec_{HB}}$ $\mathtt{S_{2,7}}$.event}\\
\texttt{10 $\mathtt{S_{2,7}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h6)}$.event}\\
\texttt{11 (assert (> b 0))}\\
\texttt{12 (assert (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{13 $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{1,5}}\rangle$}\\
\texttt{14 $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{2,4}}\rangle$}\\
\texttt{15 $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTc}
\begin{lrbox}{\boxSMTc}
\normalsize
\begin{tabular}[t]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathtt{R_{0,2}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h1)}$.event}\\
\texttt{01 $\mathtt{W(\&h1)}$.event $\mathrm{\prec_{HB}}$ $\mathtt{R_{0,5}}$.event}\\
\texttt{02 $\mathtt{R_{0,5}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h2)}$.event}\\
\texttt{03 $\mathtt{W(\&h2)}$.event $\mathrm{\prec_{HB}}$ assume.event}\\
\texttt{04 assume.event $\mathrm{\prec_{HB}}$ assert.event}\\
\texttt{05 $\mathtt{R_{1,3}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h3)}$.event}\\
\texttt{06 $\mathtt{W(\&h3)}$.event $\mathrm{\prec_{HB}}$ $\mathtt{S_{1,5}}$.event}\\
\texttt{07 $\mathtt{S_{1,5}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h4)}$.event}\\
\texttt{08 $\mathtt{S_{2,4}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h5)}$.event}\\
\texttt{09 $\mathtt{W(\&h5)}$.event $\mathrm{\prec_{HB}}$ $\mathtt{S_{2,7}}$.event}\\
\texttt{10 $\mathtt{S_{2,7}}$.event $\mathrm{\prec_{HB}}$ $\mathtt{W(\&h6)}$.event}\\
\texttt{11 (assert (> b 0))}\\
\texttt{12 (assert (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{13} $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{2,4}}\rangle\vee\langle\mathtt{R_{0,2}}$,$\mathtt{S_{1,5}}\rangle$\\
\texttt{14} $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{2,4}}\rangle\vee\langle\mathtt{R_{0,5}}$,$\mathtt{S_{1,5}}\rangle$\\
\texttt{15} $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxMP}
\begin{lrbox}{\boxMP}
\normalsize
\begin{tabular}[t]{l}
\\\\\\\\\\\\\\\\\\
$\langle\mathtt{R_{0,2}}$, $\mathtt{S_{2,4}}\rangle$\\
$\langle\mathtt{R_{0,2}}$, $\mathtt{S_{1,5}}\rangle$\\
\\
$\langle\mathtt{R_{0,5}}$, $\mathtt{S_{2,4}}\rangle$\\
$\langle\mathtt{R_{0,5}}$, $\mathtt{S_{1,5}}\rangle$\\
\\
$\langle\mathtt{R_{1,3}}$, $\mathtt{S_{2,7}}\rangle$\\
\end{tabular}
\end{lrbox}




\section{SMT Model}\label{sec:smt}

%The next step, after formally defining the operational semantics of our trace
%language, is to formally define a translation from the trace language into an
%SMT problem that can correctly models the original execution trace.

The novelty of the SMT encoding in this paper is its use of match pairs rather than the state-based or order-based encoding of prior work~\cite{elwakil:padtad10,elwakil:atva10}. The algorithm to create the encoding takes as input a set of possible match pairs and a trace through an MCAPI program with the appropriate assumes and asserts as shown in \figref{fig:trace}. A match pair is the coupling of a receive to a particular send. \figref{fig:smt}(a) is the set of possible match pairs for the program in \figref{fig:mcapi} using our shorthand notation defined in \figref{fig:trace}. The set admits, for example, that $\mathtt{R_{0,2}}$ can be matched with either $\mathtt{S_{1,5}}$ or $\mathtt{S_{2,4}}$. The SMT encoding in this paper asks the SMT solver to resolve the match pairs for the system in such a way that the final values of program variables meet the assumption on control flow but violate some assertion.

Before presenting our SMT encoding for a specific example, we need to define auxiliary operators and notations in detail. 

\begin{definition}
The nearest-enclosing wait $\mathrm{NW_R}$ for a receive $\mathrm{R}$ is the nearest following wait operation in an execution trace that witnesses the completion of $\mathrm{R}$.
\end{definition}

The nearest-enclosing wait for a receive asserts that the receive is complete indicating the message has already been in the buffer and that all the previous receives from the same task are complete as well. The intuitive example is shown in \figref{fig:nearest} such that the wait $\mathtt{W{(\&h2)}}$ witnesses the completion of the receive $\mathtt{R_{0,1}}$ and $\mathtt{R_{0,2}}$ in Task 0. As such, the wait $\mathtt{W{(\&h2)}}$ is their nearest-enclosing wait.

\begin{figure}
\begin{center}
\setlength{\tabcolsep}{2pt}
\begin{tabular}[c]{l|l}
Task 0 & Task 1  \\
\hline
$\mathtt{R_{0,1}(*,\&h1)}$ & $\mathtt{S_{1,1}(0,\&h3)}$\\
$\mathtt{R_{0,2}(*,\&h2)}$ & $\mathtt{W{(\&h3)}}$ \\
$\mathtt{W{(\&h2)}}$ & $\mathtt{S_{1,2}(0,\&h4)}$ \\
& $\mathtt{W{(\&h4)}}$\\

\end{tabular}
\end{center}
\caption{Another MCAPI concurrent program}
\label{fig:nearest}
\end{figure}

\begin{definition}
The send operation $\mathtt{S}$ is represented as a tuple $(M,e,value,event)$ such that $\mathit{M}$, $\mathit{e}$, $\mathit{value}$, $\mathit{event}$$ \in \mathbb{N}$ where $\mathbb{N}$ is the set of natural numbers. $M$ represents the event of a matched receive, $e$ represents the endpoint, $value$ is the value being sent and $event$ indicates the program order.
\label{def:snd}
\end{definition}

\begin{definition}
The receive operation $\mathtt{R}$ is represented as a tuple $(M,e,value,event,NW)$ such that $\mathit{M}$, $\mathit{e}$, $\mathit{value}$, $\mathit{event}$, $\mathit{NW}$$ \in \mathbb{N}$ where $\mathbb{N}$ is the set of natural numbers. $M$ represents the event of a matched send, $e$ represents the endpoint, $value$ is the value being received $event$ indicates the program order and $\mathit{NW}$ is the nearest-enclosing wait for the receive.
\label{def:rcv}
\end{definition}

\defref{def:snd} and \defref{def:rcv} are essential to our SMT encoding such that each field must be assigned by the SMT solver in a way that is consistent with all the constraints in the encoding. Such constraints include the \emph{Happens-Before} relation in \defref{def:hb}, the match pair encoding in \defref{def:match} and the message non-overtaking rules.

\begin{definition}
The \emph{Happens-Before}$(\mathtt{HB})$ relation is denoted as $\mathrm{\prec_{HB}}$ that asserts two operations are ordered.
\label{def:hb}
\end{definition}

The \texttt{HB} operator takes two events $a$ and $b$ as operands where $a,b \in \mathbb{N}$ and $\mathbb{N}$ is the set of natural numbers. The statement $a\ \mathrm{\prec_{HB}}\ b$ indicates that the event $a$ happens before $b$ in an execution trace. In our SMT encoding, every location in an execution trace is assigned an event, for example, $\mathit{event}_{op}$ is the event for the operation $\mathit{op}$,  and the \texttt{HB} operator orders those locations (i.e., program order, etc.). Basically, the \texttt{HB} operator asserts that two receives(sends) with common endpoints from the same source are ordered. Given that a send is immediately completed and the completion of a receive must be witnessed  by the nearest-enclosing wait, this operator also asserts, for any matched pair, that the send happens before the nearest-enclosing wait of the matched receive.

\begin{definition}
The match pair of a send $\mathtt{R}$ and a receive $\mathtt{S}$ is a pair $\langle\mathtt{R}, \mathtt{S}\rangle$, where the field $M$, $value$ and $e$ of the record $\mathtt{R}$ and $\mathtt{S}$ must be consistent. Also, the $\mathtt{HB}$ relation $event_{\mathtt{S}}\ \mathrm{\prec_{HB}}\ NW_{\mathtt{R}}$ must be satisfied.
\label{def:match}
\end{definition}

As discussed above, the match pair in \defref{def:match} ensures that a receive is matched with a send by assigning each field a value. It also asserts that no two sends(receives) can match an identical receive(send). Note that the encoding is going to use the ``$\cfgnt{M}$"  value of a send in conjunction with the \texttt{HB} realtion to enforce message non-overtaking when messages are sent from the same source. Consider a simple example below that sends two messages from a Task 0 to Task 1,
\[
\begin{array}{l|l}
\;\;\;\;\;\;\;\;\mathtt{Task\ 0}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{Task\ 1}\;\;\;\;\;\;\;\; \\
\hline
\;\;\;\;\;\;\;\;\mathtt{S_{0,1}(1,\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,1}(*,\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{S_{0,2}(1,\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,2}(*,\&h4)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h4)}\;\;\;\;\;\;\;\; \\
\end{array}
\]
The ``$\cfgnt{M}$" values in the send records will be assigned to the order tracking events for $\mathtt{R_{1,1}}$ and $\mathtt{R_{1,2}}$ in the final encoding. Message non-overtaking from transactions on common endpoints is encoded by forcing the send events to be received in program order using the \texttt{HB} relation as below in our simple example:
\[\cfgnt{M}_\mathtt{S_{0,1}}\ \prec_{HB}\ \cfgnt{M}_\mathtt{S_{0,2}}\]

Prior SMT models of MCAPI program executions implicitly compute
match pairs by adding possible happens-before relations on sends and
receives with the conditions under which those orderings are
valid. The SMT solver is then asked to resolve the happens-before
relation by choosing specific orders of sends and receives. Match pair
encoding, as presented in this work, though it has the same
computational complexity as order based encoding (you still need to
figure out match pairs on endpoints), is simpler to reason about
directly rather than implicitly through orders, results in
significantly fewer terms in the SMT problem, and does not restrict out possible matches that exist under infinite-buffer semantics.

The presentation of the SMT encoding is structured as
\[\mathit{smt}\ =\ (\mathit{defs}\ \mathit{constraints}\ \mathit{match})\]
where the field $\mathit{defs}$ represents all definitions of the send, receive operations and the variables; The field $\mathit{constraints}$ represents all constraint clauses, including the assert clauses and the clauses built by the \texttt{HB} relations; and the field $\mathit{match}$ represents the set of match pairs.

The input for generating the SMT encoding is an execution trace of an MCAPI program together with a set of match pairs. The first trace in \figref{fig:trace} with the set of match pairs in \figref{fig:smt}(a) is such an example. Given an input, the algorithm for generating our encoding is enumerated as follows. For convenience, we use the notation ``\texttt{.event}" following each command to represent the \textit{event} field in our encoding.
\begin{enumerate}
\item create event variables for every location in the execution trace. Further create send and receive records for all appropriate locations in the trace. Put these in the $\mathit{def}$ section;
\item for each assume, add a statement to $\mathit{constraints}$, and for each assert, add a negated assert to $\mathit{constraints}$;
\item add \texttt{HB} relations in \textit{constraints} to assert program order in each task, including the program order of the sends(receives) with common endpoints, the program order of the receive and its nearest-enclosing wait and the program order for enforcing message non-overtaking;
\item add match pairs in the \textit{match} section to resolve the program non-determinism.
\end{enumerate}

\begin{figure}
\begin{center}
\setlength{\tabcolsep}{20pt}
\begin{tabular}[t]{cc}
\scalebox{0.7}{\usebox{\boxMP}} &
\scalebox{0.7}{\usebox{\boxSMTc}} \\\\
(a) & (b)
\end{tabular}
\end{center}
\caption{A match pair set and SMT encoding of the system in \figref{fig:mcapi}.
(a) The match pairs based on endpoints. (b) The SMT encoding where \texttt{HB} creates a
happens-before constraint, \texttt{MATCH} creates a match pair constraint, and \texttt{NE} creates a constraint to preclude the use of conflicting match pairs.}
\label{fig:smt}
\end{figure}

We use our execution trace in \figref{fig:trace} (left side) with the set of match pairs in \figref{fig:smt}(a) as input to go through the algorithm above for generating an SMT encoding shown in \figref{fig:smt}(b). Note that we use the wait command with handler in \figref{fig:trace} to denote the wait command for a send or receive. First, we use step 1 of the algorithm above to generate the $\mathit{defs}$ ``area" that is not shown because the definitions are not novel to our solution. Second, we use step 2 to generate the asserts shown on lines \texttt{11} and \texttt{12} for the assume and assert commands of the original execution trace in \figref{fig:trace}. The first assert on line \texttt{11} works as the assume (line \texttt{14} at trace 1) in \figref{fig:trace}, such that it prevents the SMT solver from finding solutions that are not consistent with control flow which requires ``$b \ge 0$". The second assert on line \texttt{12} is negated as the goal is to find schedules that violate the property. Third, we use step 3 to generate lines \texttt{00} - \texttt{10}, which asserts program order within each thread. Finally, we use steps 4 to generate the $\mathit{match}$ ``area" of the SMT encoding. In particular, we send the set of match pairs in \figref{fig:smt}(a) to the algorithm and generate each match pair and collect those on the same receive into a disjunction on line \texttt{13} - \texttt{15}.

Other than the basic structure of the SMT encoding, we use the function
\[\mathrm{ANS}(\mathit{smt}) \mapsto \{\mathrm{\cfgt{SAT}},\mathrm{\cfgt{UNSAT}}\} \]
to return the solution of an SMT problem, such that $\mathrm{\cfgt{SAT}}$ represents a satisfiable solution that finds a trace of the MCAPI program execution that violates the user defined correctness property, and $\mathrm{\cfgt{UNSAT}}$ represents an unsatisfiable solution indicating that all possible execution traces either meet the correctness property in the same control flow, or follow a different control flow. Note that $\mathrm{\cfgt{UNSAT}}$ and $\mathrm{\cfgt{SAT}}$ are ordered such that $\mathrm{\cfgt{UNSAT}} < \mathrm{\cfgt{SAT}}$.

The SMT encoding defined above is used to capture the non-deterministic behavior of an MCAPI program execution by giving a complete set of match pairs. As we discussed in the previous section, the MCAPI program in \figref{fig:mcapi} contains two outcomes of execution as defined in the MCAPI specification under the infinite-buffer semantics. The SMT encoding we present in \figref{fig:smt}(b) captures both execution traces, since the set of match pairs in \figref{fig:smt}(a) is a complete set where all matches that can occur in the real execution for our running example in \figref{fig:mcapi} are included, and all matches that cannot occur in the real execution are not included. Further, the following theorem states that we can over-approximate the true set of match pairs and still prove correctness. If there is no error with the over-approximated set, then there is no error arising from non-determinism in the runtime on that program execution. If there is an error from the over-approximated set, that error is also guaranteed to be a real error in the program runtime. Note that two SMT problems $\smt_{\alpha}$ and $\smt_{\beta}$ in the following theorem have identical $\mathit{defs}$ and $\mathit{constraints}$ sets, and the match set of $\smt_{\alpha}$ is the subset of that of $\smt_{\beta}$ so that $smt_{\beta}$ represents an over-approximation of $smt_{\alpha}$.
\\
\\
\textbf{Theorem 1.}
The relation for the solutions of two SMT problems $\smt_{\alpha}$ $= (\mathit{defs}$ $\mathit{constraints}$ $\mathit{match}_{\alpha})$ and $\smt_{\beta}$ $= (\mathit{defs}$ $\mathit{constraints}$ $\mathit{match_{\beta}})$ is,
\[\mathrm{ANS}(\smt_{\alpha}) \leq \mathrm{ANS}(\smt_{\beta})\]
where $\mathit{set(match_{\alpha})} \subseteq \mathit{set(match_{\beta})}$. Note that $\mathit{set(match)}$ represents the input set of match pairs for the $\mathtt{MATCH}$ clauses in the $\mathit{match}$ field.
\label{thm:1}
\begin{figure}
\begin{center}
\setlength{\tabcolsep}{3pt}
\begin{tabular}[c]{cc}
%\scalebox{0.7}{\usebox{\boxMP}} &
\scalebox{0.7}{\usebox{\boxSMTa}} &
\scalebox{0.7}{\usebox{\boxSMTb}} \\\\
%\scalebox{0.7}{\usebox{\boxSMTc}} \\
(a) & (b)
\end{tabular}
\end{center}
\caption{Two SMT encodings of the system in \figref{fig:mcapi}.
(a) The SMT encoding for Trace 1 in \figref{fig:trace}. (b) The SMT encoding for Trace 2 in \figref{fig:trace}.}
\label{fig:smt_trace}
\end{figure}
\\
\textbf{Proof Sketch.}
Consider the MCAPI program in \figref{fig:mcapi} as an example.
\figref{fig:smt_trace}(a) and (b) are two different SMT encodings for our running
example in \figref{fig:mcapi} generated from different sets of possible match pairs, such that \figref{fig:smt_trace}(a) encodes trace 1 in \figref{fig:trace} and \figref{fig:smt_trace}(b) encodes trace 2 in \figref{fig:trace}. By solving the encodings in \figref{fig:smt_trace}(a) and (b) for trace 1 and 2 in \figref{fig:trace} respectively, we get an unsatisfiable solution for \figref{fig:smt_trace}(a), and a satisfiable solution for \figref{fig:smt_trace}(b). As we discussed in Section 2, trace 1 is an execution trace without failure of the assertion, and trace 2 is the one that fails the assertion. %We can see that the encodings in \figref{fig:smt_trace} (a) and (b) correctly encodes trace 1 and 2 in \figref{fig:trace}, respectively.
Compare both encodings with that in \figref{fig:smt}(b), we find that the fields $\mathit{defs}$ and $\mathit{constraints}$ are identical except for the set of match pairs. In particular, the input set of match pairs of either \figref{fig:smt_trace}(a) or (b) is the subset of that in \figref{fig:smt}(b). As discussed above, the encoding in \figref{fig:smt}(b) captures the non-deterministic behavior of our running program in \figref{fig:mcapi}, which encodes trace 1 and 2 in \figref{fig:trace} into one single SMT problem. Thus, an SMT solver will return a satisfiable solution for the encoding in \figref{fig:smt}(b). Thus, $\mathrm{ANS}$ on the encoding in \figref{fig:smt}(b) is greater than or equal to the $\mathrm{ANS}$ on the encoding in either \figref{fig:smt_trace}(a) or (b). In other words, adding more match pairs can only move the $\mathrm{ANS}$ from $\mathrm{\cfgt{UNSAT}}$ to $\mathrm{\cfgt{SAT}}$.

The formal proof of Theorem 1 is in the long version of our paper at ``http://students.cs.byu.edu/$\sim$yhuang2/downloads\\/paper.pdf". The proof defines a formal operational semantics given by a term rewriting system using a \textit{CESK}\footnote{The \textit{CESK} machine state is represented with a \textbf{C}ontrol string, \textbf{E}nvironment, \textbf{S}tore, and \textbf{K}ontinuation.} style machine only the machine is augmented to include additional structure for modeling message passing. The operational framework defines how to execute a program, following the specified trace, and defines when that execution is a
success (causes no assertion violation), a failure (causes an assertion violation), infeasible (causes an assume to not hold), or an error (execution is not allowed by the MCAPI semantics.). Further, the machine generates the terms of the SMT encoding as it rewrites the machine states. The proof defines a combination operator and shows that several SMT encodings can be combined such that the combined SMT encoding returns ``SAT" if one of those encodings has a satisfiable solution.  As such, Theorem 1 is formally proved by applying the combination operator for $\smt_{\alpha}$ and $\smt_{\beta}$.

Given $\mathit{set(match_{\alpha})}$ and $\mathit{set(match_{\beta})}$ in the theorem above a complete set of match pairs and an over-approximated set, respectively, we can further prove that $\mathrm{ANS}(\smt_{\alpha})$ $ = $ $\mathrm{ANS}(\smt_{\beta})$ by giving the following theorem. Note that a match pair $(R, S) \in \mathit{set(match_{\beta})}/\mathit{set(match_{\alpha})}$ is called ``bogus", since it cannot exist in a real execution of the program.
\\
\\
\textbf{Theorem 2.}
Any match pair $(R, S)$ used in a satisfying assignment of an SMT encoding $\smt$ is a valid match pair and reflects an actual possible MCAPI program execution.
\\
\textbf{Proof.}
Proof by contradiction. Assume that $(R, S)$ is a ``bogus" match pair that causes $\mathrm{ANS}(\smt) = \cfgt{SAT}$. Since $(R, S)$ is not a valid match pair, match $R$ and $S$ requires program order, message non-overtaking, or no-multiple match to be violated. In other words, the $\mathtt{HB}$ constraints encoded in $\smt$ are not satisfied. Based on the fact above, the answer of $\smt$ is $\cfgt{UNSAT}$ and it contradicts the previous hypothesis. Thus, $(R, S)$ is a valid match pair in $\smt$ and reflects an actual possible MCAPI program execution. $\Box$


By proving Theorem 2, we infer that a ``bogus" match pair can only cause an unsatisfying assignment of an SMT problem. Further, given that $\mathit{set(match_{\alpha})}$ and $\mathit{set(match_{\beta})}$ reflect a complete set and a over-approximated set respectively, the answers of $\smt_{\alpha}$ and $\smt_{\beta}$ discussed above are equal since any ``bogus" match pair involved in $\smt_{\beta}$ is only used in unsatisfying assignments.

It is possible to use our encoding for \textit{zero-buffer} semantics as well. For \textit{zero-buffer} semantics, reorganize the encoding as follows: For each match pair that cannot exist in the program runtime under the \textit{zero-buffer} setting, add extra \texttt{HB} clauses in the SMT encoding to prevent incorrect behavior. For example in \figref{fig:mcapi}, to prevent $\mathtt{R_{1,3}}$ from being matched with $\mathtt{S_{2,6}}$ before $\mathtt{R_{0,2}}$ is matched with $\mathtt{S_{2,4}}$ as prohibited by the \textit{zero-buffer} semantics, an \texttt{HB} relation is added such that the wait command $\mathtt{W(\&h1)}$ for $\mathtt{R_{0,2}}$ happens before $\mathtt{S_{2,6}}$.













