

\newsavebox{\boxSMTa}
\begin{lrbox}{\boxSMTa}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h1)}}$}\\
\texttt{01 $\mathit{event_\mathtt{R_{0,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h2)}}$}\\
\texttt{02 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{R_{0,5}}}$}\\
\texttt{03 $\mathit{event_\mathtt{R_{1,3}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h3)}}$}\\
\texttt{04 $\mathit{event_\mathtt{S_{1,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h4)}}$}\\
\texttt{05 $\mathit{event_\mathtt{S_{2,4}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h5)}}$}\\
\texttt{06 $\mathit{event_\mathtt{S_{2,7}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h6)}}$}\\
\texttt{07 ($\mathit{assert}$ (> b 0))}\\
\texttt{08 ($\mathit{assert}$ (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{09 $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{2,4}}\rangle$}\\
\texttt{10 $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{1,5}}\rangle$}\\
\texttt{11 $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTb}
\begin{lrbox}{\boxSMTb}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h1)}}$}\\
\texttt{01 $\mathit{event_\mathtt{R_{0,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h2)}}$}\\
\texttt{02 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{R_{0,5}}}$}\\
\texttt{03 $\mathit{event_\mathtt{R_{1,3}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h3)}}$}\\
\texttt{04 $\mathit{event_\mathtt{S_{1,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h4)}}$}\\
\texttt{05 $\mathit{event_\mathtt{S_{2,4}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h5)}}$}\\
\texttt{06 $\mathit{event_\mathtt{S_{2,7}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h6)}}$}\\
\texttt{07 ($\mathit{assert}$ (> b 0))}\\
\texttt{08 ($\mathit{assert}$ (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{09 $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{1,5}}\rangle$}\\
\texttt{10 $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{2,4}}\rangle$}\\
\texttt{11 $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTc}
\begin{lrbox}{\boxSMTc}
\normalsize
\begin{tabular}[t]{l}
\texttt{...} \\
\texttt{01 $\mathit{order_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{order_\mathtt{W(\&h1)}}$}\\
\texttt{02 $\mathit{order_\mathtt{R_{0,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{order_\mathtt{W(\&h2)}}$}\\
\texttt{03 $\mathit{order_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{order_\mathtt{R_{0,5}}}$}\\
\texttt{04 $\mathit{order_\mathtt{R_{1,3}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{order_\mathtt{W(\&h3)}}$}\\
\texttt{05} \texttt{($\mathit{assert}$ (> b 0))}\\
\texttt{06} \texttt{($\mathit{assert}$ (not (= a 4)))}\\
\texttt{07} $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{2,4}}\rangle\vee\langle\mathtt{R_{0,2}}$,$\mathtt{S_{1,5}}\rangle$\\
\texttt{08} $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{2,4}}\rangle\vee\langle\mathtt{R_{0,5}}$,$\mathtt{S_{1,5}}\rangle$\\
\texttt{09} $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$
\end{tabular}
\end{lrbox}

\newsavebox{\boxMP}
\begin{lrbox}{\boxMP}
\normalsize
\begin{tabular}[t]{l}
$\langle\mathtt{R_{0,2}}$, $\mathtt{S_{2,4}}\rangle$\\
$\langle\mathtt{R_{0,2}}$, $\mathtt{S_{1,5}}\rangle$\\
\\
$\langle\mathtt{R_{0,5}}$, $\mathtt{S_{2,4}}\rangle$\\
$\langle\mathtt{R_{0,5}}$, $\mathtt{S_{1,5}}\rangle$\\
\\
$\langle\mathtt{R_{1,3}}$, $\mathtt{S_{2,7}}\rangle$\\
\end{tabular}
\end{lrbox}


%%---------------------------------------------------------------------------
%%% Start --- SMT Machine reductions
\begin{figure}
\mprset{flushleft}
\scalebox{0.75}{
\begin{mathpar}
\and
%  (--> (h eta aid-map ep-send-calls pending-r
%           (thread_0 ... ([ploc_0 cmd_0] [ploc_1 cmd_1] [ploc_2 cmd_2] ...) thread_2 ...)
%           (ploc_0 trace-entry_1 ...) status smt)
%        (h_pr eta_pr aid-map_pr ep-send-calls_pr pending-r_pr
%              (thread_0 ... ([ploc_1 cmd_1] [ploc_2 cmd_2] ...) thread_2 ...)
%              (trace-entry_1 ...) status_pr smt_prpr)
%        "Machine Step"
%        (where (h_pr eta_pr aid-map_pr ep-send-calls_pr pending-r_pr
%                     e status_pr ret smt_pr)
%               ,(apply-reduction-relation** expr-reductions
%                                            (term (h eta aid-map ep-send-calls
%                                                     pending-r
%                                                     cmd_0 status ret smt))))
%        (where smt_prpr (add-po smt_pr ploc_0 ploc_1)))
\inferrule[Machine Step]{
  (\epsnd~\qset~\movebot~\status)~\reduceK{q}~
  (\epsnd_\mathit{p0}~\qset_\mathit{p0}~\movebot_p~\status_\mathit{p0}) \\\\
  (h~\eta~\aidmap~\epsnd_\mathit{p0}~\eprcv~\qset_\mathit{p0}~\cmd_0~\status_\mathit{p0}~\ret~\last~\smt)~\reduceK{e}~
  (h_p~\eta_p~\aidmap_p~\epsnd_\mathit{p1}~\eprcv_p~\qset_\mathit{p1}~e~\status_\mathit{p1}~\ret~\last_p~\smt_\mathit{p0}) \\
  \smt_\mathit{p1} =  \mathrm{addHB}(\smt_\mathit{p0}~\ploc_0~\ploc_1)
}{
  (h~\eta~\aidmap~\epsnd~\eprcv~\qset~
           (\thread_0~\ldots~
            ([\ploc_0~\cmd_0]~[\ploc_1~\cmd_1]~[\ploc_2~\cmd_2]~\ldots)~\thread_2~\ldots)~
           ([\ploc_0~\movebot]~\traceentry_1~\ldots)~\status~\last~\smt) \reduce{m} \\\\
  (h_p~\eta_p~\aidmap_p~\epsnd_\mathit{p1}~\eprcv_p~\qset_\mathit{p1}~
              (\thread_0~\ldots~([\ploc_1~\cmd_1]~[\ploc_2~\cmd_2]~\dots)~\thread_2~\dots)~
              (\traceentry_1~\dots)~\status_\mathit{p1}~\last_p~\smt_\mathit{p1})
}
\end{mathpar}}
\caption{Machine Reductions to build the SMT model of a trace language program ($\reduce{\mathrm{m-smt}}$)}
\label{fig:machine_smt}
\end{figure}


\begin{figure}
\scalebox{0.75}{%
\mprset{flushleft}
\begin{mathpar}
%   (--> (h eta aid-map pending-s pending-r  (assume e) status k
%           (defs (any ...)))
%        (h eta aid-map pending-s pending-r  e status (assume * -> k )
%           (defs (e any ...)))
%        "Assume Pull Out Expr")
\inferrule[Assume Expressions Evaluation]{}{
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ (\assume\ e)\ \status\ k\ \last\ (\defs\ (\any\ \ldots))) \reduce{e}
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ e\ \status\ (\assume\ * \rightarrow k)\ \last\ (\defs\ (e\ \any\ \ldots)))
}
\and
%   ;;Negate expression and add it to the SMT assertions.
%   (--> (h eta aid-map pending-s pending-r  (assert e) status k
%           (defs (any ...)))
%        (h eta aid-map pending-s pending-r  e status (assert * -> k)
%           (defs ((not e) any ...)))
%        "Assert Pull Out Expr")
\inferrule[Assert Expressions Evaluation]{}{
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ (\assert\ e)\ \status\ k\ \last\ (\defs\ (\any\ \ldots))) \reduce{e}
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ e\ \status\ (\assert\ * \rightarrow k)\ \last\ (\defs\ ((\negate\ e)\ \any\ \ldots)))
}
\and
%   (--> (h eta aid-map pending-s pending-r  (x := e) status k
%           (defs (any ...)))
%        (h eta aid-map pending-s pending-r  e status (x := * -> k)
%           (defs ((= x e) any ...)))
%        "Assign Pull Out Expr")
\inferrule[Assign Expressions Evaluation]{}{
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ (x\ :=\ e)\ \status\ k\ \last\ (\defs\ (\any\ \ldots))) \reduce{e}
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ e\ \status\ (x\ :=\ * \rightarrow k)\ \last\ (\defs\ ((=\ x\ e)\ \any\ \ldots)))
}
\and
%   ;;Adds sendi cmd to aid-map and pending-s. - VALIDATED
%   (--> (h eta ([aid_x ep_x] ...) pending-s pending-r q-set
%           (sendi aid src dst x ploc number) status k ((any_d ...) (any_a ...)))
%        (h eta ([aid src] [aid_x ep_x] ...) pending-s_pr pending-r q-set
%           true status k ((any_0 any_d ...) (any_1 any_a ...)))
%        "Sendi Cmd x -> v"
%        (where v (h-lookup h (eta-lookup eta x)))
%        (where any_0 (define aid :: send))
%        (where any_1 (make-send aid src dst x ploc number))
%        (where pending-s_pr (add-send pending-s [aid -> src dst v])))
\inferrule[Sndi Command]{
  ([\aid_1\ v_1]\ \ldots) = \epsnd(\dst)(\src) \\ \epsnd_p = [\epsnd \mid \dst \mapsto [\epsnd(\dst) \mid \src \mapsto ([\aid_0\ h(\eta(x))]\ [\aid_1\ v_1]\ \ldots)]] \\
  \any_0 = (\define\ \aid\ ::\ send) \\ \any_1 = (\andd\ (=\ (\select\ \aid\ ep)\ \dst)\ (=\ (\select\ \aid\ value)\ x))
}{
  (h\ \eta\ ([\aid\ \ep]\ \ldots)\ \epsnd\ \eprcv\ \qset\
     (\sendi\ \aid_0\ \src\ \dst\ x)\ \status\ k\ \last\ ((\any_d\ \ldots)\ (\any_a\ \ldots))) \reduce{e} \\
  (h\ \eta\ ([\aid_0\ \src]\ [\aid\ \ep]\ \ldots)\ \epsnd_p\ \eprcv\ \qset\ \true\ \status\ k\ \last\ ((\any_0\ \any_d\ \ldots)\ (\any_1\ \any_a\ \ldots)))
}
\and
%   ;;Adds recvi cmd to aid-map and pending-r. - VALIDATED
%   (--> (h eta ([aid_x ep_x] ...) pending-s pending-r q-set
%           (recvi aid dst x ploc) status k ((any_d ...) (any_a ...)))
%        (h eta ([aid dst] [aid_x ep_x] ...) pending-s pending-r_pr q-set
%           true status k ((any_0 any_d ...) (any_1 any_a ...)))
%        "Recvi Cmd0"
%        (where pending-r_pr (add-recv pending-r [aid -> dst x]))
%        (where any_0 (define aid :: recv))
%        (where any_1 (make-recv aid dst x ploc)))
\inferrule[Rcvi Command]{
  ([\aid_1\ x_1]\ \ldots) = \eprcv(\dst) \\
   \eprcv_p = [\eprcv \mid \dst \mapsto ([\aid_0\ x_0]\ [\aid_1\ x_1]\ \ldots)] \\
   \any_0 = (\define\ \aid\ ::\ recv) \\ \any_1 = (\andd\ (=\ (\select\ \aid\ ep)\ \dst)\ (=\ (\select\ \aid\ var)\ x_0))
}{
  (h\ \eta\ ([\aid\ \ep]\ \ldots)\ \epsnd\ \eprcv\ \qset\ (\recvi\ \aid_0\ \dst\ x_0)\ \status\ k\ \last\ ((\any_d\ \ldots)\ (\any_a\ \ldots))) \reduce{e} \\
  (h\ \eta\ ([\aid_0\ \dst]\ [\aid\ \ep]\ \ldots)\ \epsnd\ \eprcv_p\ \qset\ \true\ \status\ k\ \last\ ((\any_0\ \any_d\ \ldots)\ (\any_1\ \any_a\ \ldots)))
}
\and
   %(--> (h eta aid-map pending-s pending-r q-set (wait aid_r)
%           status k (defs (any_a ...)))
%        (h_pr eta aid-map_pr pending-s pending-r_pr q-set_pr true
%              status_pr k
%              (defs ((HB (select aid-ยกร_s-last match_po) (select aid_s match_po))
%                    (MATCH aid_r0 aid_s0) any_a ...)))
%        "Recvi Wait Cmd"
%            ;; get recv and corresponding send command, mark each send in front of the destination send (by set variable "mark" to 1)
%        (where true (find-recv pending-r aid_r) )
%        (where (aid-map_0 dst_r) (get-ep aid-map aid_r))
%        (where (h_pr aid_s pending-r_pr q-set_pr status_pr)
%               (get-mark-remove h eta pending-r q-set dst_r aid_r status))
%        (where (aid-map_pr src_s) (get-ep aid-map_0 aid_s))
%        )
%   ))
\inferrule[Wait (rcvi) Command]{
    ([\aid_0\ \ep_0]\ \ldots\ [\aid_s\ \src]\ \ldots\ [\aid_r\ \dst]\ \ldots\ [\aid_1\ \ep_1]) = \aidmap\\
    %\aidmap_0 = ([\aid_0\ \ep_0]\ \ldots\ [\aid_s\ \src]\ \ldots\ [\aid_1\ \ep_1])\\
    (h_p\ \aid_s\ \eprcv_p\ \qset_p\ \status_p) = \getmarkremove(h, \eta, \eprcv, \qset, \dst, \aid_r, \status) \\
    %([\aid_0\ \ep_0]\ \ldots\ [\aid_s\ \src][\aid_1\ \ep_1]) = \aidmap_0\\
    \aidmap_p = ([\aid_0\ \ep_0]\ \ldots\ [\aid_1\ \ep_1])\\
    (\last_p\ last\_\aid_s) = \getlastsendreplace(\last, \aid_s, \src, \dst)
}{
    (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ \qset\ (\wait\ \aid_r)\ \status\ k\ \last\ (\defs\ (\any_a\ \ldots))) \reduce{e} \\
    (h_p\ \eta\ \aidmap_p\ \epsnd\ \eprcv_p\ \qset_p\ true\ \status_p\ k\ \last_p\ (\defs\ ((\HB\ (\select\ last\_\aid_s)\ \mathit{MP})\ (\select\ \aid_s\ \mathit{MP}))\
                    (\MATCH\ \aid_r\ \aid_s)\ \any_a\ \ldots)))
}
\end{mathpar}}
\caption{Expression Reductions to build the SMT model of a trace language program ($\reduce{\mathrm{e-smt}}$)}
\label{fig:expression_smt}
\end{figure}
%%% END --- SMT Machine reductions
%%---------------------------------------------------------------------------

\section{SMT Encoding}\label{sec:smt}

The new SMT encoding is based on (1) a trace of events during an
execution of an MCAPI program including control-flow assumptions and
property assertions, such as \figref{fig:trace1}; and (2) a set of
possible match pairs. A match pair is the coupling of a receive to a
particular send.  In the running example, the set admits, for example,
that $\mathtt{R_{0,2}}$ can be matched with either $\mathtt{S_{1,5}}$
or $\mathtt{S_{2,4}}$. This direct use of match pairs, rather than a
state-based or indirect use of match pairs in an order-based
encoding, \cite{elwakil:padtad10} and \cite{elwakil:atva10}, is novel.

The purpose of the SMT encoding is to force the SMT solver to resolve
the match pairs for the system in such a way that the final values of
program variables meet the assumptions on control flow but violate
some assertion. In essence, the SMT solver completes a partial order
on operations into a total order that determines the final match pair
relationships.

\subsection{Definitions} \label{sec:smt-defns}

The encoding needs to express the partial order imposed by the MCAPI
semantics as SMT constraints. The partial order is based on a
\emph{Happens-Before} relation over operations such as send, receive,
wait, or assert:

\begin{definition}[Happens-Before]
The \emph{Happens-Before} $(\mathtt{HB})$ relation, denoted as
$\mathrm{\prec_\mathtt{HB}}$, is a partial order over operations.
\label{def:hb}
\end{definition}

Given two operations, $A$ and $B$, if $A$ must complete before $B$ in a
valid program execution, then $A$ $\mathrm{\prec_{\mathtt{HB}}}$ $B$
will be an SMT constraint.

The relation is derived from the program source and potential match pairs. In
order to specify the constraints from the program source, each program operation is mapped to a set of variables that can be manipulated by the SMT solver.

\begin{definition}[Wait] \label{def:event}
The occurrence of a wait operation, \texttt{W}, is captured by a
single variable, $\mathit{order}_\mathtt{W}$, that constrains when
the wait occurs.
\end{definition}

It is not enough to represent all events as simple numbers
that will be ordered in this way.  Such an encoding would not allow the solver to
discover what values would flow across communication primitives. Instead, some events in the trace are modeled as a set of SMT
variables that record the pertinent information about the event. For
example,

\begin{definition}[Send] \label{def:snd}
A send operation $\mathtt{S}$, is a four-tuple of variables:
\begin{compactenum}
\item $M_\mathtt{S}$, the order of the matching receive event;

\item $\mathit{order}_\mathtt{S}$, the order of the send;

\item $e_\mathtt{S}$, the endpoint; and,

\item $\mathit{value}_\mathtt{S}$, the transmitted value.
\end{compactenum}
\end{definition}

The most complex operation in MCAPI is a receive. Since receives are
inherently asynchronous, it is not possible to represent them
atomically. Instead, we need to associate each receive with a wait
that marks where in the program the receive operation is guaranteed to be
complete. The MCAPI runtime semantics allow a single wait to witness the completion of many receives due to \emph{the message
  non-overtaking property}. A wait that witnesses the completion of
one or more receives is the \emph{nearest-enclosing wait}.

\begin{definition}[Nearest-Enclosing Wait] \label{def:nw}
A wait that witnesses the completion of a receive by indicating that
the message is delivered and that all the previous receives in the
same task issued earlier are complete as well.
\end{definition}

\begin{figure}[h]
\[
\begin{array}{l|l}
\;\;\;\;\;\;\;\;\mathtt{Task\ 0}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{Task\ 1}\;\;\;\;\;\;\;\; \\
\hline
\;\;\;\;\;\;\;\;\mathtt{R_{0,1}(*,\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{S_{1,1}(0,\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{R_{0,2}(*,\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W{(\&h3)}}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W{(\&h2)}}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{S_{1,2}(0,\&h4)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W{(\&h1)}}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W{(\&h4)}}\;\;\;\;\;\;\;\; \\
\end{array}
\]
\caption{Nearest-enclosing Wait example} \label{fig:nw}
\end{figure}

\figref{fig:nw} shows that the wait $\mathtt{W{(\&h2)}}$
witnesses the completion of the receive $\mathtt{R_{0,1}}$ and
$\mathtt{R_{0,2}}$ in task 0. Thus, $\mathtt{W{(\&h2)}}$ is their
nearest-enclosing wait.

The encoding requires that every receive operation have a
nearest-enclosing wait as it makes match pair decisions at the wait
operation. The requirement is not a limitation of the encoding, as
accessing a buffer from a receive that does not have a
nearest-enclosing wait is an error. Rather, the wait is a convenience
in the encoding to mark where a receive actually takes place. The same
requirement can be made for sends for correctness but is not required
for the encoding as send buffering is handled differently than receive
buffering.  The encoding effectively ignores wait operations for sends
as will be seen.

\begin{definition}[Receive] \label{def:rcv}
A receive operation $\mathtt{R}$ is modeled by a five-tuple of variables:
\begin{compactenum}
\item $M_\mathtt{R}$, the order of the matching send event;

\item $\mathit{order}_\mathtt{R}$, the order of the receive;

\item $e_\mathtt{R}$, the endpoint;

\item $\mathit{value}_\mathtt{R}$, the received value; and,

\item $\mathit{nw}_\mathtt{R}$, the order of the nearest enclosing wait.
\end{compactenum}
\end{definition}

\subsection{Assumptions, Assertions, and match pairs}

The definitions so far merely establish the pertinent information
about each event in the trace as SMT variables. It is necessary to now express
constraints on those variables.

The most trivial kind of constraints are those for control-flow
assumptions.

\begin{definition}[Assumption] \label{def:assm}
Every assumption $\mathtt{A}$ is added as an SMT assertion.
\end{definition}

It may seem strange to turn \emph{assumptions} into
\emph{assertions}, but from a constraint perspective, the assumption
that we have already observed some property (during control-flow) is
equivalent to instructing the SMT solver to treat it as inviolate
truth, or an assertion.

The next level of constraint complexity comes from property
assertions. These correspond to the invariants of the program. The
goal is to discover if they can be violated, so we instruct the SMT
solver to seek for a way to satisfy their \emph{negation} given all
the other constraints.

\begin{definition}[Property Assertion] \label{def:assert}
For every property assertion $\mathtt{P}$, $\neg \mathtt{P}$ is added as
an SMT assertion.
\end{definition}

Finally, we must express the relation in a given match pair as a set of SMT
constraints. Informally, a match pair equates the shared components of
a send and receive and constrains the send to occur before the
nearest-enclosing wait of the receive. Formally:

\begin{definition}[Match Pair] \label{def:match}
A match pair, $\langle\mathtt{R}, \mathtt{S}\rangle$, for a receive
$\mathtt{R}$ and a send $\mathtt{S}$ corresponds to the constraints:
\begin{compactenum}
\item $M_{\mathtt{R}} = \mathit{order}_{\mathtt{S}}$
\item $M_{\mathtt{S}} = \mathit{order}_{\mathtt{R}}$
\item $e_{\mathtt{R}} = e_{\mathtt{S}}$
\item $\mathit{value}_{\mathtt{R}} = \mathit{value}_{\mathtt{S}}$ and
\item $\mathit{order}_{\mathtt{S}}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{nw}_{\mathtt{R}}$
\end{compactenum}
\end{definition}

The encoding is given a set of potential match pairs over all the
sends and receives in the program trace. The constraints from these
match pairs are not simply joined in a conjunctions. If we were to do that, then we
would be constraining the system such that a single receive must be
paired with all possible sends in a feasible execution rather than a
single send. Therefore, we combine all the constraints for a given
receive with all possible sends as specified by the input match pairs
into a single disjunction:

\begin{definition}[Receive Matches]
For each receive $\mathtt{R}$, if $\langle\mathtt{R},
\mathtt{S}_0\rangle$ through $\langle\mathtt{R}, \mathtt{S}_n\rangle$
are match pairs, then $\bigvee_{i}^{n} \langle\mathtt{R},
\mathtt{S}_i\rangle$ is used as an SMT constraint.
\end{definition}

This encoding of the input ensures that the SMT solver can only use
compatible send/receive pairs and ensures that sends happen before
nearest-enclosing waits on receives.

\subsection{Program Order Constraints}

The encoding thus far is missing
additional constraints on the \emph{Happens-Before} relation stemming from program order. These constraints are added in four steps: we must ensure that sends to common endpoints occur
in program order in a single task (step 1); similarly for receives
(step 2); receives occur before their nearest-enclosing wait (step 3);
and, that sends are received in the order they are sent (step 4).

\paragraph*{Step 1} For each task, if there are sequential send
operations, say $\mathtt{S}$ and $\mathtt{S^\prime}$, from that task
to a common endpoint, $e_\mathtt{S} = e_\mathtt{S^\prime}$, then those
sends must follow program order: $\mathit{order}_\mathtt{S}$
$\prec_\mathtt{HB}$ $\mathit{order}_\mathtt{S^\prime}$.

\paragraph*{Step 2} For each task, if there are sequential receive
operations, say $\mathtt{R}$ and $\mathtt{R^\prime}$, in that task
on a common endpoint, $e_\mathtt{R} = e_\mathtt{R^\prime}$, then those
receives must follow program order: $\mathit{order}_\mathtt{R}$
$\prec_\mathtt{HB}$ $\mathit{order}_\mathtt{R^\prime}$.

\paragraph*{Step 3} For every receive \texttt{R} and its nearest
enclosing wait \texttt{W}, $\mathit{order}_\mathtt{R}$
$\prec_\mathtt{HB}$ $\mathit{order}_\mathtt{W}$.

\paragraph*{Step 4} For any pair of sends $\mathtt{S}$ and
$\mathtt{S'}$ on common endpoints, $e_{\mathtt{S}}=e_{\mathtt{S'}}$,
such that
$\mathit{order}_\mathtt{S}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{order}_\mathtt{S'}$,
then those sends must be received in the same order:
$M_{\mathtt{S}}\ \mathrm{\prec_{\mathtt{HB}}}\ M_{\mathtt{S'}}$.

For example, consider two tasks where task 0 sends two messages to
task 1 as shown in \figref{fig:step4}.

\begin{figure}[h]
\[
\begin{array}{l|l}
\;\;\;\;\;\;\;\;\mathtt{Task\ 0}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{Task\ 1}\;\;\;\;\;\;\;\; \\
\hline
\;\;\;\;\;\;\;\;\mathtt{S_{0,1}(1,\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,1}(*,\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{S_{0,2}(1,\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,2}(*,\&h4)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h4)}\;\;\;\;\;\;\;\; \\
\end{array}
\]
\caption{Send Ordering Example} \label{fig:step4}
\end{figure}

The $\mathit{M_\mathtt{S}}$ variables from the sends will be assigned to the orders
for $\mathtt{R_{1,1}}$ and $\mathtt{R_{1,2}}$ by the match pairs
selected by the SMT solver. The constraints added in this step force
the send to be received in program order using the \texttt{HB}
relation which for this example yields
$\cfgnt{M}_\mathtt{S_{0,1}}\ \mathrm{\prec_\mathtt{HB}}\ \cfgnt{M}_\mathtt{S_{0,2}}$.

\subsection{Zero Buffer Semantics}

The constraints presented so far correspond to an infinite-buffer
semantics, because we do not constrain how many messages may be in
transit at once. We can add additional, orthogonal, constraints to
further restrict behavior and enforce a zero-buffer semantics. There are
two kinds of such constraints.

First, for each task, if there are two sends $\mathtt{S}$ and
$\mathtt{S'}$ such that
$\mathit{order}_\mathtt{S}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{order}_\mathtt{S'}$,
and $\mathtt{S}$ and $\mathtt{S'}$ can both match a receive
$\mathtt{R}$, then we add the following constraint to the encoding:
$\mathit{order}_{\mathtt{W}}\ \mathrm{\prec_{\mathtt{HB}}}\ \mathit{order}_{\mathtt{S'}}$
where $\mathtt{W}$ is the nearest-enclosing wait that witnesses the
completion of $\mathtt{R}$ in execution.

The second constraint relies on a dependence relation between two match pairs.
\begin{definition}
To match pairs are dependent, denoted as $\langle\mathtt{R}, \mathtt{S}\rangle$ $\rightharpoonup$ $\langle\mathtt{R'}, \mathtt{S'}\rangle$, if and only if
\begin{compactenum}
\item the nearest-enclosing wait $\mathtt{W}$ of $\mathtt{R'}$ issues before $\mathtt{S}$ on an identical endpoint; or
\item $\exists\langle\mathtt{R''} \mathtt{S''}\rangle$ such that $\langle\mathtt{R}, \mathtt{S}\rangle \rightharpoonup \langle\mathtt{R''}, \mathtt{S''}\rangle\wedge\langle\mathtt{R''}, \mathtt{S''}\rangle \rightharpoonup \langle\mathtt{R'}, \mathtt{S'}\rangle$.
\end{compactenum}
\label{def:matchrelation}
\end{definition}
With the dependence relation, the second set of constraints for the zero-buffer semantics is give as: for each pair of sends $\mathtt{S}$ and $\mathtt{S'}$ that can both match an receive $\mathtt{R}$, if there is a send $\mathtt{S''}$ issued after the issuing of $\mathtt{S'}$ by an identical endpoint, and a receive $\mathtt{R'}$ such that $\langle\mathtt{R}, \mathtt{S}\rangle\rightharpoonup\langle\mathtt{R'}, \mathtt{S''}\rangle$, then we add the following constraint to the encoding: $\mathit{order}_{\mathtt{W}}\ \mathrm{\prec_{\mathtt{HB}}}\ \mathit{order}_{\mathtt{S}}$
where $\mathtt{W}$ is the nearest-enclosing wait that witnesses the
completion of $\mathtt{R}$.


\subsection{Example}

\begin{figure}[t]
\begin{center}
\usebox{\boxSMTc}
\end{center}
\caption{SMT Encoding} \label{fig:smt-encode}
\end{figure}

\figref{fig:smt-encode} shows the encoding of \figref{fig:mcapi} as an
SMT problem. We elide the basic definition of the variables discussed
in \secref{sec:smt-defns}. Lines \texttt{05} through \texttt{09} give
the assumptions, assertions, and match pairs. The first four lines
reflect the program order constraints: receives happen before
corresponding wait operations and receives from a common endpoint follow
program order. There are no constraints between sends because there are no sequential sends from a common endpoint to a common endpoint. To encode the zero-buffer semantics, the constraint
$\mathit{order}_\mathtt{W(\&h1)}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{order}_\mathtt{S_{1,5}}$
would need to be added to force the receive to complete before another
send is issued.

\subsection{Correctness}

Before we can state our correctness theorem, we must define a few
terms. We define our encoder as a function from programs and match pair sets
to SMT problems:

\begin{definition}[Encoder]
For all programs, $p$, and match pair sets $m$, let $\mathcal{SMT}(p,
m)$ be our encoding as an SMT problem.
\end{definition}

We assume that an SMT solver can be represented as a function that
takes a problem and returns a satisfying assignment of variables or an
unsatisfiable flag:

\begin{definition}[SMT Solver]
For all SMT problems, $s$, let $\mathcal{SOL}(s)$ be in $\sigma +
\mathbb{UNSAT}$, where $\sigma$ is a satisfying assignment of
variables to values.
\end{definition}

We assume that from a satisfying assignment to one of our SMT
problems, we can derive an execution trace by observing the values
given to each of the $\textit{order}_{e}$ variables. In other words,
we can view the SMT solver as returning traces and not assignments.

We assume a semantics for traces that gives their behavior as either
having an assertion violation or being correct. This formal semantics is presented in Section 4. 

\begin{definition}[Semantics]
For all programs, $p$, and traces $t$, $\mathcal{SEM}(p, t)$ is either
$\mathbb{BAD}$ or $\mathbb{OK}$.
\end{definition}

Given this framework, our SMT encoding technique is sound if

\begin{theorem}[Soundness]
For all programs, $p$, and match pair sets, $m$,
$\mathcal{SOL}(\mathcal{SMT}(p, m)) = t \Rightarrow \mathcal{SEM}(p, t) =
\mathbb{BAD}$.
\end{theorem}

Our soundness proof relies on the following lemma:

\begin{lemma} \label{lem:bogus}
Any match pair $\langle \mathtt{R}, \mathtt{S}\rangle$ used in a
satisfying assignment of an SMT encoding is a valid match pair and
reflects an actual possible MCAPI program execution.
\end{lemma}
\begin{proof}
We prove this by contradiction. First, assume that $\langle
\mathtt{R}, \mathtt{S}\rangle$ is an invalid match pair (i.e. one that
is not valid in an actual MCAPI execution). Second, assume that the
SMT solver finds a satisfying assignment.

Since $\langle \mathtt{R}, \mathtt{S}\rangle$ is not a valid match
pair, match $\mathtt{R}$ and $\mathtt{S}$ requires program order,
message non-overtaking, or no-multiple match to be violated. In other
words, the \emph{Happens-Before} constraints encoded in the SMT
problem are not satisfied.

This is a contradiction: either the SMT solver would not return an
assignment or the match pair was actually valid.
\end{proof}

The correctness of our technique relies on completeness:

\begin{theorem}[Completeness]
For all programs, $p$, and traces, $t$, $\mathcal{SEM}(p, t) =
\mathbb{BAD} \Rightarrow \exists m . \mathcal{SOL}(\mathcal{SMT}(p,
m)) = t$.
\end{theorem}

To completely prove completeness, we give the following modified framework that produces a correlating SMT problem for a given execution trace. The evaluation syntax for the machine reductions to build the SMT
model of a trace language program are largely those of the regular machine
reductions with a few changes below
\[
\cfgstart
\cfgrule{mstate}{\lp\cfgnt{h}\ \cfgnt{\ensuremath{\eta}}\ \cfgnt{\aidmap}\
  \cfgnt{\epsnd}\ \cfgnt{\eprcv}\ \cfgnt{\qset}\ \cfgnt{ctp}\ \cfgnt{\trace}\ \cfgnt{\status}\ \cfgnt{k}\ \cfgnt{\last}\ \smt\rp}
%  (expr-state (h eta aid-map pending-s pending-r e status k smt))
\cfgrule{estate}{\lp\cfgnt{h}\ \cfgnt{\ensuremath{\eta}}\ \cfgnt{\aidmap}\
  \cfgnt{\epsnd}\ \cfgnt{\eprcv}\ \cfgnt{\qset}\ \cfgnt{e}\ \cfgnt{\status}\ \cfgnt{k}\ \cfgnt{\last}\ \smt\rp}
%  (smt (defs constraints ML))
\cfgrule{\smt}{\lp\cfgnt{defs}~\cfgnt{constraints}~\ml\rp}
%  (defs (any ...))
\cfgrule{defs}{\lp\cfgnt{any}~$\ldots$\rp}
%  (constraints (any ...))
\cfgrule{constraints}{\lp\cfgnt{any}~$\ldots$\rp}
% ()
\cfgrule{\ml}{\lp\ml~=~$\emptyset$~$|$~(\ml~[\recv~$\rightarrow$[(\recv~\send)$\ldots$]])\rp}
\cfgend
\]
The new syntax adds the \textit{smt} member to the \textit{mstate}
and \textit{estate} where the ``\cfgnt{any}'' term in \textit{defs}
and \textit{constraints} matches any structure. The lists will
be filled with definitions, HB entries, MATCH entries, etc. as defined by the SMT machine reductions. A match-list \ml\ is a set of match pair lists uniquely identified by a receive action ID, and each list consists of a set of match pairs for this receive action ID and a send action ID. Note that we alpha renamed so that \recv\ and \send\ are all unique labels. For convenience, we define function $\mathit{dom(\ml)}$ and $\mathit{range(\ml)}$ that return the set of receive action IDs in the set of match pairs of \ml\ and the set itself, respectively. The symbol \last\ is another member added to the \textit{mstate} and \textit{estate}. It records the last send operation that happens before the current one in the same thread. The \textit{qstate} does not contain any SMT encodings in the reductions and it is not changed.

The changes for the reduction rules are presented in \figref{fig:machine_smt} and \figref{fig:expression_smt}. The support function $\mathrm{addHB}(((\mathit{any}_d ...)\ (\mathit{any}_c ...))\ \ploc_0\ \ploc_1)$ adds program location to the definition list and adds a happens before relation
\[
 \equiv \\
   (((\mathtt{define\ \ploc_0 :: int})\ \mathit{any}_d ...)((\mathtt{HB\ \ploc_0\ \ploc_1})\ \mathit{any}_c ...))
\]

The reduction rules in \figref{fig:machine_smt} and \figref{fig:expression_smt} add constraints to the SMT problem with respect to the semantic definition of the trace language. The $\mathrm{Machine\ Step}$ in \figref{fig:machine_smt} adds the program order of actions in the same thread to the SMT problem. The evaluation of assume, assert and assign in \figref{fig:expression_smt} adds assertions to the SMT problem. The $Sndi$ and $Rcvi$ commands define the send and receive actions in the SMT problem, and the $Wait (Rcvi)$ reduction adds the ''match" constraints to the SMT problem. Note that the function $\getlastsendreplace$ picks up the last send operation, $\mathit{last}\_\aid_s$, that happens before the current one in the same thread, and adds a HB relation between the $\mathit{MP}$ of $\mathit{last}\_\aid_s$ and that of the current send operation. The added relation ensures the messages from a common endpoint are non-overtaking (i.e., FIFO ordered).

The following definition supports the rest of the section.

\begin{definition}
A machine state $(h\ \eta\ \aidmap\ \epsnd\ \eprcv\ \cfgnt{ctp}\ \trace\ \status\ k)$ is smt-enabled if it is well formed.  The SMT problem is taken from the final SMT reduced state:
\[\begin{array}{l}
        (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ \cfgnt{ctp}\ \trace\ \status\ k\ (()()))  \reduceK{\mathrm{m-smt}} \\
 (h_p\ \eta_p\ \aidmap_p\ \epsnd_p\ \eprcv_p\ \cfgnt{ctp}_p\ \trace_p\ \status_p\ k_p\ \mathrm{smt})
 \end{array}\]
For convenience, we define the function
$\mathrm{getSMT}(m) \mapsto\ \mathrm{smt}$ to return the SMT problem in the final state, and $\mathrm{ANS}(\mathrm{getSMT}(m)) \mapsto \{\mathrm{\cfgt{SAT}},\mathrm{\cfgt{UNSAT}}\}$ to return the status of the SMT problem in the final state of $m$. Also, we define the relation of the range of function $\mathrm{ANS}$ such that $\mathrm{\cfgt{UNSAT}} > \mathrm{\cfgt{SAT}}$.
\end{definition}

\begin{figure}
\begin{center}
\setlength{\tabcolsep}{7pt}
\begin{tabular}[c]{ccc}
\scalebox{0.68}{\usebox{\boxSMTa}} &
\scalebox{0.68}{\usebox{\boxSMTb}} &
\scalebox{0.68}{\usebox{\boxSMTc}} \\
(a) & (b) & (c)
\end{tabular}
\end{center}

\caption{SMT problems. (a) SMT problem based on the first trace. (b) SMT
problem based on a second trace. (c) SMT problem built from the preceding two
problems.}

\label{fig:smts}
\end{figure}

\figref{fig:smts} shows the SMT problem (minus the event definitions) generated from our new \textit{CESK SMT} encoding machines for the program in \figref{fig:mcapi} on two different traces (parts (a) and (b)). Note that the encodings in \figref{fig:smts} (a) and (b) are identical except for the $\mathrm{MATCH}$ clauses, which are generated from the trace parts of the program. Furthermore, the encoding in \figref{fig:smts}(a) violates the properties of interest encoded in the assert clauses, and the answer for the encoding in \figref{fig:smts} (a) is $\mathrm{SAT}$. From this observation, we present the following lemma that indicates the equivalence between the status of our \textit{CESK} machines and the satisfiability of the generated SMT encoding.%\figref{fig:smts}(a) uses several functions defined above to encode a single trace through the CTP. Especially, the $\mathrm{assume}$ statement is created by
%asserting any branch conditions that we encountered in the trace. As was stated
%earlier, this prevents the SMT solver from finding any solutions that are not
%consistent with the program's control flow. The $\mathrm{assert}$ statement is
%created by negating any assertions that were made in the original program. This
%creates an SMT problem that will only be satisfiable if an assertion violation
%can be found.

%So far, we have achieved two different methods that can both verify the execution of a single trace. Furthermore, the following lemma indicates the equivalence between the trace language and the SMT encoding. Before presenting the lemma, we have the following definition.


\begin{lemma}
For a well-formed machine state $m$,
\[
\mathrm{status}(m) = \cfgt{failure} \iff \mathrm{ANS}(\mathrm{getSMT}(m)) = \mathrm{\cfgt{SAT}}
\]
\label{lemma:1}
\end{lemma}
\begin{proof}
%To prove the statement, we focus on each reduction rule that adds clauses to the SMT problem. Since the only reduction rule that causes the status of state $\cfgt{failure}$ is
%Assert Expression Evaluation in \figref{fig:expression_smt}, we need to prove that an $\cfgt{assert}$ expression causes the machine state $\cfgt{failure}$ if and only if the added clause in SMT problem is satisfiable. Suppose expression $\emph{e}$ in the assert reduction rule in \figref{fig:machine_smt} is evaluated false, which causes the status of state $\cfgt{failure}$, It is obvious that the new clause, $(not\ \emph{e})$, is evaluated true by any SMT solver. For the other direction, since $(not\ \emph{e})$ is true, the evaluation of $\emph{e}$ is false so that the status of state is evaluated $\cfgt{failure}$.
%For other reduction rules in \figref{fig:machine_smt} and \figref{fig:expression_smt}, we need to prove the contraposition, such that the SMT problem returns $\mathrm{\cfgt{UNSAT}}$ if and only if the status of state is either $\cfgt{success}$ or $\cfgt{infeasible}$ ($\cfgt{error}$ is not considered since it can only reduced by non-well-formed machine state). Suppose the status of final state is $\cfgt{success}$, such that each reduction rule is reduced without changing the status. Note that the $\mathrm{HB}$ relations are correctly defined in the machine reduction, assertions for assume and assign commands are evaluated true, the send and receive operations are correctly defined and the match pairs are valid in the SMT problem since the trace is executed successfully in the trace language semantics. The assertion for the assert command, however, is negated in the SMT problem so that makes it $\mathrm{\cfgt{UNSAT}}$. Also, suppose the status of state is $\cfgt{infeasible}$, such that the evaluation of expression $\emph{e}$ in assume command is false. Since the clause $e$ is also added to the SMT problem and it is evaluated false, the whole SMT problem is evaluated $\mathrm{\cfgt{UNSAT}}$ eventually. For the other direction, suppose the generated SMT problem is $\mathrm{\cfgt{UNSAT}}$, we need to prove the non-existence of $\cfgt{failure}$ for the state status. Since the SMT problem is found $\mathrm{\cfgt{UNSAT}}$, there should be at least one clause that is not satisfiable. If the unsatisfiable clause is generated from the assert command, such that $(not\ e)$ is evaluated false. It implies that $e$ is evaluated true. Thus, the assert command can not make the status of state $\cfgt{failure}$. If the unsatisfiable clause is generated from other reduction rules, the status of state could only be $\cfgt{success}$ or $\cfgt{infeasible}$ by definition.
%Thus, this is the end of proof.

The generated SMT problem in \figref{fig:machine_smt} and \figref{fig:expression_smt} captures the execution trace from the initial state up to the final state by looking at the following facts. First, the machine step in \figref{fig:machine_smt} adds an $\mathrm{HB}$ relation for two consecutive program locations $\ploc_0$ and $\ploc_1$ in an identical thread, with respect to the program order constraint. Second, the $\mathrm{assume}$, $\mathrm{assert}$ and $\mathrm{assign}$ expression evaluations in \figref{fig:expression_smt} add assert constraints for variable $x$ or expression $e$ with respect to the trace constraint. Note that the negated system is used in the assert evaluation when generating the SMT statement. Third, the $\mathrm{sndi}$ and $\mathrm{rcvi}$ commands in \figref{fig:expression_smt} add $\any_0$ as the definition of a receive or send operation, followed by $\any_1$ as the initialization of operation fields. Finally, the $\mathrm{wait(rcvi)}$ command in \figref{fig:expression_smt} adds a match pair for the receive operation $\aid_r$ and the send operation $\aid_s$ where $\aid_s$ is obtained by applying the process we described in Section 3.2. Furthermore, an $\mathrm{HB}$ relation is added with respect to the program order, such that the messages from a common endpoint are non-overtaking. The observations described above either adds program order constraints for the execution trace modeled in the machine states, or adds constraints for variables or expressions that are also modeled in the machine state. In a word, the generated SMT problem captures the execution trace in the machine.

Notice the fact above, we suppose the status of the final machine state is $\cfgt{failure}$. From the reduction rules, we know that there exists at least one assert action that is evaluated false. In \figref{fig:expression_smt}, we know that expression ``$e$" is negated and added to the SMT encoding for the second reduction rule. Since $e$ is evaluated false, $(not\ e)$ is evaluated true trivially in the generated SMT problem. Other statements are all evaluated true due to the trace capture fact that the program order is assigned correctly based on the execution trace modeled in the machine states, and the variables and expressions are also evaluated true in assume and assign commands. Thus, the SMT problem is evaluated $\cfgt{SAT}$.
On the other hand, suppose the SMT problem is evaluated $\cfgt{SAT}$, indicating that all statements of the SMT problem are satisfiable. Since the reduction rules in \figref{fig:expression_smt} add statements with respect to the transition flow of the trace, it implies that each transition of the trace is executed correctly except for some assert action. Because of the same reason above, we know that expression $e$ for the assert action is evaluated false. Thus, the status of the final machine state is $\cfgt{failure}$.
$\Box$
\end{proof}


 As we discussed early, \figref{fig:smts} (a) and (b) are generated from the same program with two different traces. The encoding in \figref{fig:smts} (c) combines part (a) and (b) into one, the answer of which implies the non-deterministic behavior of the program. By solving the problem in \figref{fig:smts} (c), we implicitly solve two problems in \figref{fig:smts} (a) and (b) respectively. The following definition defines the ``combination" behavior of two SMT problems.

%\begin{definition}
%A match-list \ml\ is a set of match pair lists uniquely identified by a receive action ID, and each list consists of a set of match pairs for this receive action ID and a send action ID:
%\[\ml\ =\ \emptyset\ |\ (\ml\ [\recv\ \rightarrow [(\recv\ \send)\ldots]])\]
%Note that we alpha renamed so that \recv\ and \send\ are all unique labels. For convenience, we define function $\mathit{dom(\ml)}$ and $\mathit{range(\ml)}$ that return the set of receive %action IDs in the set of match pairs of \ml\ and the set itself, respectively.
%\label{def:match-list}
%\end{definition}

%We extend the structure \ml\ to the structure \smt\ such that
%\[\smt=(\mathit{defs}\ \mathit{constraints}\ \ml)\]
%where the match constraints are separated from $\mathit{constraints}$. In addition, two SMT problems are assumed to hold the same $\mathit{defs}$ and $\mathit{constraints}$ excluding the match constraints if and only if they can be combined by applying a combination operator in \defref{def:combinator}.

\begin{definition}
A combination operator $\mathit{COMB}$ for two SMT problems, represented as three-tuples $\smt_1$ and $\smt_2$, where $\smt_1 = (\mathit{defs}\ \mathit{constraints}\ \ml_1)$ and $\smt_2 = (\mathit{defs}\ \mathit{constraints}\ \ml_2)$, returns a new SMT tuple, such that,
\[\mathit{COMB}(smt_1,smt_2)\ =\ (\mathit{defs}\ \mathit{constraints}\ \ml_{new})\]
where $\ml_{new}$ is a new relation such that $\forall\recv\in dom(\ml_1)\cup dom(\ml_2)$, $\ml_{new}(\recv) = \ml_1(\recv)\cdot\ml_2(\recv)$. Note that two SMT problems are assumed to hold the same $\mathit{defs}$ and $\mathit{constraints}$ excluding the match constraints.
\label{def:combinator}
\end{definition}

To further finding the correlation between the combined SMT problem and the single SMT problems, we get the following lemma and proof.

\begin{lemma}
For a set of traces $\mathrm{T_n}$ for the same CTP, and a set of SMT problems $\mathrm{SMT_n} = \{\smt_0,\smt_{1},\ldots,\smt_{n}\}$, where each member in $\mathrm{SMT_n}$ encodes a trace in $\mathrm{T_n}$ according to our trace machine, there exists a new SMT problem $\smt_{total}$, where
\[\smt_{total} = \mathit{COMB}(\smt_n, \mathit{COMB}(\smt_{n-1}, \mathit{COMB}(\smt_{n-2}, \mathit{COMB}(\ldots ))))\]
and
\[
\mathrm{ANS}(\smt_{total}) = \left\{ \begin{array}{rl}
  \mathit{\cfgt{SAT}} &\ \mathrm{iff}\ \exists \smt_i \in \mathrm{SMT_n},\ s.t.\ \mathrm{ANS}(\smt_i) = \mathit{\cfgt{SAT}}  \\
  \mathit{\cfgt{UNSAT}} &\ \mathrm{otherwise}\
\end{array}
\right .
\]
\end{lemma}
\begin{proof}
We Prove it by induction.

We consider the base case as a SMT problem that encodes a single trace and the answer can be trivially proved by definition.

Induction. Assume we have combined n SMT problems and the combined SMT problem $\smt_{total}$ is evaluated $\mathit{\cfgt{UNSAT}}$. We combine an additional SMT problem $\smt_{n+1}$, which is different from any existent SMT problems. If $\mathrm{ANS}(\smt_{n+1})$ is equal to $\mathit{\cfgt{SAT}}$, the newly combined SMT problem, $\smt_{total}'$, is evaluated $\mathit{\cfgt{SAT}}$ because the match pairs defined in $\smt_{n+1}$ are combined into $\smt_{total}'$. If $\mathrm{ANS}(\smt_{n+1})$ is equal to $\mathit{\cfgt{UNSAT}}$, on the other hand, $\smt_{total}'$ is then evaluated $\mathit{\cfgt{UNSAT}}$ because all the traces implied in $\smt_{total}'$ are evaluated $\mathit{\cfgt{UNSAT}}$. Additionally, it can be trivially proved if $\smt_{total}$ is evaluated $\mathit{\cfgt{SAT}}$ then the newly added SMT problem $\smt_{n+1}$ do not change the answer. $\Box$
\end{proof}

From \textbf{Lemma 2}, the combined SMT problem is more powerful because it can find the violation of an assertion among several trace encodings. The following theorem states the relation between the ability of finding violation and the content of the match-list \ml.

\begin{theorem}
For two SMT problems, $\smt_{\phi} = (\mathit{defs}\ \mathit{constraints}\ \ml_{\phi})$ and $\smt = (\mathit{defs}\ \mathit{constraints}\ \ml)$,
if $\mathit{range(\ml_{\phi})} \subseteq \mathit{range(\ml)}$,
\[\mathrm{ANS}(\smt_{\phi}) \geq \mathrm{ANS}(\smt)\]
\end{theorem}
\begin{proof}
Since the range of $\ml_{\phi}$ is the subset of the range of $\ml$, we can obtain $\smt$ by combining $\smt_{\phi}$ with other SMT problems. Suppose $\mathrm{ANS}(\smt_{\phi})$ is equal to $\mathit{\cfgt{SAT}}$, by \textbf{Lemma 2}, $\mathrm{ANS}(\smt)$ is equal to $\mathit{\cfgt{SAT}}$ as well. If $\mathrm{ANS}(\smt_{\phi})$ is equal to $\mathit{\cfgt{UNSAT}}$, $\mathrm{ANS}(\smt)$ is equal to either $\mathit{\cfgt{UNSAT}}$ or $\mathit{\cfgt{SAT}}$, depending on the answers of other single SMT problems that combine $\smt$. In either case, $\mathrm{ANS}(\smt_{\phi}) \geq \mathrm{ANS}(\smt)$.
\end{proof}

These theorems above obscure an important problem: how do we know
which match pair set to use? Soundness assumes we have one, while
completeness merely asserts that one exists. Although \secref{sec:mp-gen}
discusses our generation algorithm, we prove here an additional
theorem that asserts that any conservative over-approximation of match
pair sets is safe.

\begin{theorem}[Approximation]
Give two match pair sets $m$ and $m'$, $m \subseteq m' \Rightarrow \mathcal{SOL}(\mathcal{SMT}(p, m))
  \sqsubseteq \mathcal{SOL}(\mathcal{SMT}(p, m'))$, where
  $\mathbb{UNSAT} \sqsubseteq \sigma$.
\end{theorem}

Informally, this is true because larger match pair sets only allow
\emph{more} behavior, which means that the SMT solver has more freedom
to find violations, but that all prior violations are still
present. However, because of soundness, it is not possible that using
a larger match pair set will discover false violations. 
