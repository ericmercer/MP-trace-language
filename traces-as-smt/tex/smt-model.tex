\newcommand{\epsnd}{\textit{Pnd\_s}}
\newcommand{\eprcv}{\textit{Pnd\_r}}
\newcommand{\qset}{\textit{Q\_s}}
\newcommand{\snd}{\textit{snd}}
\newcommand{\rcv}{\textit{rcv}}
\newcommand{\q}{\textit{q}}
\newcommand{\frm}{\textit{frm}}
\newcommand{\vbot}{\textit{v$-\bot$}}
\newcommand{\status}{\textit{s}}
\newcommand{\last}{\textit{l}}
\newcommand{\error}{\ensuremath{\mathbf{error}}}
\newcommand{\aidmap}{\textit{A}}
\newcommand{\thread}{\ensuremath{\mathit{t}}}
\newcommand{\aid}{\ensuremath{\mathit{a}}}
\newcommand{\ploc}{\ensuremath{\rho}}
\newcommand{\loc}{\ensuremath{\mathit{l}}}
\newcommand{\cmd}{\ensuremath{\mathit{c}}}
\newcommand{\op}{\ensuremath{\mathit{op}}}
\newcommand{\applyop}{\ensuremath{\mathrm{op}}}
\newcommand{\wait}{\ensuremath{\mathbf{wait}}}
\newcommand{\sendi}{\ensuremath{\mathbf{sndi}}}
\newcommand{\recvi}{\ensuremath{\mathbf{rcvi}}}
\newcommand{\traceentry}{\ensuremath{\sigma}}
\newcommand{\movelist}{\ensuremath{\delta}}
\newcommand{\assume}{\ensuremath{\mathit{assume}}}
\newcommand{\checkassume}{\ensuremath{\mathrm{assume}}}
\newcommand{\assert}{\ensuremath{\mathit{assert}}}
\newcommand{\checkassert}{\ensuremath{\mathrm{assert}}}
\newcommand{\ep}{\ensuremath{\mathbf{\gamma}}}
\newcommand{\src}{\ensuremath{\alpha}}
\newcommand{\dst}{\ensuremath{\beta}}
\newcommand{\true}{\ensuremath{\mathbf{true}}}
\newcommand{\false}{\ensuremath{\mathbf{false}}}
\newcommand{\match}{\ensuremath{\mathrm{m}}}
\newcommand{\matchl}{\ensuremath{\mathrm{match}}}
\newcommand{\findrecv}{\ensuremath{\mathrm{search_r}}}
\newcommand{\smt}{\ensuremath{\mathit{smt}}}


\newcommand{\addsend}{\ensuremath{\mathrm{addsend}}}
\newcommand{\getsend}{\ensuremath{\mathrm{getsend}}}
\newcommand{\removesend}{\ensuremath{\mathrm{removesend}}}
\newcommand{\addrecv}{\ensuremath{\mathrm{addrecv}}}
\newcommand{\getrecv}{\ensuremath{\mathrm{getrecv}}}
\newcommand{\removerecv}{\ensuremath{\mathrm{removefrecv}}}
\newcommand{\hextend}{\ensuremath{\mathrm{hextend}}}
\newcommand{\hlookup}{\ensuremath{\mathrm{hlookup}}}
\newcommand{\etalookup}{\ensuremath{\mathrm{etalookup}}}
\newcommand{\checkmatch}{\ensuremath{\mathrm{checkmatch}}}
\newcommand{\getep}{\ensuremath{\mathrm{getEP}}}
\newcommand{\getmarkremove}{\ensuremath{\mathrm{getMarkRemove}}}
\newcommand{\getlastsendreplace}{\ensuremath{\mathrm{getlastsend/replace}}}
\newcommand{\statuschange}{\left\{ \begin{array}{ll}  \status &\ \mathrm{if}\ |\epsnd(\dst)(\src)|>0\\
   \mathit{error} &\  \mathrm{otherwise}\end{array}\right .}

\newcommand{\reduce}[1]{\ensuremath{\rightarrow_{#1}}}
% Multiple reductions
\newcommand{\reduceK}[1]{\ensuremath{\rightarrow_{#1}^{*}}}
% Non-deterministic reductions
\newcommand{\reduceN}[1]{\ensuremath{\dashrightarrow_{#1}}}
\newcommand{\reduceNK}[1]{\ensuremath{\dashrightarrow_{#1}^{*}}}
\newcommand{\mt}{\ensuremath{\emptyset}}
\newcommand{\trace}{\ensuremath{\mathit{trace}}}
\newcommand{\movebot}{\ensuremath{\mathit{m}}}
\newcommand{\ret}{\ensuremath{\mathbf{ret}}}

\newcommand{\defs}{\ensuremath{\mathrm{defs}}}
\newcommand{\any}{\ensuremath{\mathrm{any}}}
\newcommand{\negate}{\ensuremath{\mathrm{not}}}
\newcommand{\define}{\ensuremath{\mathrm{define}}}
\newcommand{\andd}{\ensuremath{\mathrm{and}}}
\newcommand{\select}{\ensuremath{\mathrm{select}}}
\newcommand{\HB}{\ensuremath{\mathrm{HB}}}
\newcommand{\getlast}{\ensuremath{\mathrm{last}}}
\newcommand{\MATCH}{\ensuremath{\mathrm{MATCH}}}
\newcommand{\ml}{\ensuremath{\mathit{ML}}}
\newcommand{\matchpair}{\ensuremath{\mathrm{MP}}}
\newcommand{\recv}{\ensuremath{\mathrm{\mu}}}
\newcommand{\send}{\ensuremath{\mathrm{\nu}}}



\newsavebox{\boxSMTa}
\begin{lrbox}{\boxSMTa}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathtt{event_{R_{0,2}}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h1)}}$}\\
\texttt{01 $\mathtt{event_{W(\&h1)}}$.event $\mathtt{\prec_{HB}}$ $\mathtt{event_{R_{0,5}}}$}\\
\texttt{02 $\mathtt{event_{R_{0,5}}}$.event $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h2)}}$}\\
\texttt{03 $\mathtt{event_{W(\&h2)}}$.event $\mathtt{\prec_{HB}}$ $\mathtt{event_{assume}}$}\\
\texttt{04 $\mathtt{event_{assume}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{assert}}$}\\
\texttt{05 $\mathtt{event_{R_{1,3}}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h3)}}$}\\
\texttt{06 $\mathtt{event_{W(\&h3)}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{S_{1,5}}}$}\\
\texttt{07 $\mathtt{event_{S_{1,5}}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h4)}}$}\\
\texttt{08 $\mathtt{event_{S_{2,4}}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h5)}}$}\\
\texttt{09 $\mathtt{event_{W(\&h5)}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{S_{2,7}}}$}\\
\texttt{10 $\mathtt{event_{S_{2,7}}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h6)}}$}\\
\texttt{11 (assert (> b 0))}\\
\texttt{12 (assert (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{13 $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{2,4}}\rangle$}\\
\texttt{14 $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{1,5}}\rangle$}\\
\texttt{15 $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTb}
\begin{lrbox}{\boxSMTb}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathtt{event_{R_{0,2}}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h1)}}$}\\
\texttt{01 $\mathtt{event_{W(\&h1)}}$.event $\mathtt{\prec_{HB}}$ $\mathtt{event_{R_{0,5}}}$}\\
\texttt{02 $\mathtt{event_{R_{0,5}}}$.event $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h2)}}$}\\
\texttt{03 $\mathtt{event_{W(\&h2)}}$.event $\mathtt{\prec_{HB}}$ $\mathtt{event_{assume}}$}\\
\texttt{04 $\mathtt{event_{assume}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{assert}}$}\\
\texttt{05 $\mathtt{event_{R_{1,3}}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h3)}}$}\\
\texttt{06 $\mathtt{event_{W(\&h3)}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{S_{1,5}}}$}\\
\texttt{07 $\mathtt{event_{S_{1,5}}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h4)}}$}\\
\texttt{08 $\mathtt{event_{S_{2,4}}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h5)}}$}\\
\texttt{09 $\mathtt{event_{W(\&h5)}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{S_{2,7}}}$}\\
\texttt{10 $\mathtt{event_{S_{2,7}}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h6)}}$}\\
\texttt{11 (assert (> b 0))}\\
\texttt{12 (assert (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{13 $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{1,5}}\rangle$}\\
\texttt{14 $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{2,4}}\rangle$}\\
\texttt{15 $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTc}
\begin{lrbox}{\boxSMTc}
\normalsize
\begin{tabular}[t]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathtt{event_{R_{0,2}}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h1)}}$}\\
\texttt{01 $\mathtt{event_{W(\&h1)}}$.event $\mathtt{\prec_{HB}}$ $\mathtt{event_{R_{0,5}}}$}\\
\texttt{02 $\mathtt{event_{R_{0,5}}}$.event $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h2)}}$}\\
\texttt{03 $\mathtt{event_{W(\&h2)}}$.event $\mathtt{\prec_{HB}}$ $\mathtt{event_{assume}}$}\\
\texttt{04 $\mathtt{event_{assume}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{assert}}$}\\
\texttt{05 $\mathtt{event_{R_{1,3}}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h3)}}$}\\
\texttt{06 $\mathtt{event_{W(\&h3)}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{S_{1,5}}}$}\\
\texttt{07 $\mathtt{event_{S_{1,5}}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h4)}}$}\\
\texttt{08 $\mathtt{event_{S_{2,4}}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h5)}}$}\\
\texttt{09 $\mathtt{event_{W(\&h5)}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{S_{2,7}}}$}\\
\texttt{10 $\mathtt{event_{S_{2,7}}}$ $\mathtt{\prec_{HB}}$ $\mathtt{event_{W(\&h6)}}$}\\
\texttt{11 (assert (> b 0))}\\
\texttt{12 (assert (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{13} $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{2,4}}\rangle\vee\langle\mathtt{R_{0,2}}$,$\mathtt{S_{1,5}}\rangle$\\
\texttt{14} $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{2,4}}\rangle\vee\langle\mathtt{R_{0,5}}$,$\mathtt{S_{1,5}}\rangle$\\
\texttt{15} $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxMP}
\begin{lrbox}{\boxMP}
\normalsize
\begin{tabular}[t]{l}
\\\\\\\\\\\\\\\\\\
$\langle\mathtt{R_{0,2}}$, $\mathtt{S_{2,4}}\rangle$\\
$\langle\mathtt{R_{0,2}}$, $\mathtt{S_{1,5}}\rangle$\\
\\
$\langle\mathtt{R_{0,5}}$, $\mathtt{S_{2,4}}\rangle$\\
$\langle\mathtt{R_{0,5}}$, $\mathtt{S_{1,5}}\rangle$\\
\\
$\langle\mathtt{R_{1,3}}$, $\mathtt{S_{2,7}}\rangle$\\
\end{tabular}
\end{lrbox}




\section{SMT Model}\label{sec:smt}

%The next step, after formally defining the operational semantics of our trace
%language, is to formally define a translation from the trace language into an
%SMT problem that can correctly models the original execution trace.

The novelty of the SMT encoding in this paper is its use of match pairs rather than the state-based or order-based encoding of prior work~\cite{elwakil:padtad10,elwakil:atva10}. The algorithm to create the encoding takes as input a set of possible match pairs and a trace through an MCAPI program with the appropriate assumes and asserts as shown in \figref{fig:trace}. A match pair is the coupling of a receive to a particular send. \figref{fig:smt}(a) is the set of possible match pairs for the program in \figref{fig:mcapi} using our shorthand notation defined in \figref{fig:trace}. The set admits, for example, that $\mathtt{R_{0,2}}$ can be matched with either $\mathtt{S_{1,5}}$ or $\mathtt{S_{2,4}}$. The SMT encoding in this paper asks the SMT solver to resolve the match pairs for the system in such a way that the final values of program variables meet the assumption on control flow but violate some assertion.

Before presenting our SMT encoding for a specific example, we need to define auxiliary notations in detail.
\begin{definition}
The event $event_{\mathtt{op}}\in\mathbb{N}$ of an operation $\mathtt{op}$ is its program order in an execution trace, where $\mathbb{N}$ is the set of natural numbers and $\mathtt{op}\in\{\mathtt{S}, \mathtt{R}, \mathtt{W}\}$.
\label{def:event}
\end{definition}
In our SMT encoding, every operation $\mathtt{op}$ in an execution trace is assigned an event $event_{\mathtt{op}}$ and the \texttt{HB} relation defined in \defref{def:hb} orders those events.
\begin{definition}
The \emph{Happens-Before} $(\mathtt{HB})$ relation denoted as $\mathrm{\prec_{HB}}$ is a partial order between two events $event_{\mathtt{op}}$ and $event_{\mathtt{op'}}$ for the operation $\mathtt{op}$ and $\mathtt{op'}$ respectively such that $event_{\mathtt{op}}\ \mathrm{\prec_{HB}}\ event_{\mathtt{op'}}$ if and only if $event_{\mathtt{op}} < event_{\mathtt{op'}}$.
\label{def:hb}
\end{definition}
The \texttt{HB} relation is essential to the following definitions. Also, \defref{def:nw} and \defref{def:match} further define two rules of how to compute the \texttt{HB} relation. As such, we first give the detail of those definitions. After that, the rules for the \texttt{HB} computation are listed.
\begin{definition}
The wait operation $\mathtt{W}$ is the nearest-enclosing wait for a receive $\mathtt{R}$ if and only if $event_{\mathtt{R}}\ \mathrm{\prec_{HB}}\ event_{\mathtt{W}}$ where $\mathtt{W}$ and $\mathtt{R}$ are from an identical endpoint, and for any wait $\mathtt{W'}$ such that $\mathtt{W'} \neq \mathtt{W}$, $event_{\mathtt{W}}\ \mathrm{\prec_{HB}}\ event_{\mathtt{W'}}$.
%\noindent The nearest-enclosing wait $NW_{\mathtt{R}}$ for a receive $\mathtt{R}$ is the wait operation following $\mathrm{R}$ in an execution trace,   that witnesses the completion of $\mathrm{R}$.
\label{def:nw}
\end{definition}
The nearest-enclosing wait for a receive witnesses the completion of the receive indicating the message has already been in the buffer and that all the previous receives from the same task are complete as well. This constraint is enforced by the message non-overtaking requirement in the MCAPI specification. The intuitive example below shows that the wait $\mathtt{W{(\&h2)}}$ witnesses the completion of the receive $\mathtt{R_{0,1}}$ and $\mathtt{R_{0,2}}$ in Task 0. As such, the wait $\mathtt{W{(\&h2)}}$ is their nearest-enclosing wait.
\[
\begin{array}{l|l}
\;\;\;\;\;\;\;\;\mathtt{Task\ 0}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{Task\ 1}\;\;\;\;\;\;\;\; \\
\hline
\;\;\;\;\;\;\;\;\mathtt{R_{0,1}(*,\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{S_{1,1}(0,\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{R_{0,2}(*,\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W{(\&h3)}}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W{(\&h2)}}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{S_{1,2}(0,\&h4)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W{(\&h1)}}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W{(\&h4)}}\;\;\;\;\;\;\;\; \\
\end{array}
\]
\begin{definition}
The send operation $\mathtt{S}$ is defined as a tuple $(M,e,value,event)$ such that $\mathit{M}$, $\mathit{e}$, $\mathit{value}$, $\mathit{event}$$ \in \mathbb{N}$. $M$ represents the program order of a matched receive, $e$ represents the endpoint, $value$ is the value being sent and $event$ indicates the program order.
\label{def:snd}
\end{definition}
\begin{definition}
The receive operation $\mathtt{R}$ is defined as a tuple $(M,e,value,event,NW)$ such that $\mathit{M}$, $\mathit{e}$, $\mathit{value}$, $\mathit{event}$, $\mathit{NW}$$ \in \mathbb{N}$. $M$ represents the program order of a matched send, $e$ represents the endpoint, $value$ is the value being received, $event$ indicates the program order and $\mathit{NW}$ is the nearest-enclosing wait for the receive.
\label{def:rcv}
\end{definition}
\defref{def:snd} and \defref{def:rcv} are essential to our SMT encoding such that each field must be assigned by the SMT solver in a way that is consistent with all the constraints in the encoding. Such constraints include the \emph{Happens-Before} relation in \defref{def:hb}, the match pair encoding in \defref{def:match} and the message non-overtaking rules. For convenience, we use $M_{\mathtt{op}}$, $e_{\mathtt{op}}$, $value_{\mathtt{op}}$ to represent the match, endpoint and value of $\mathtt{op}$ respectively, where $\mathtt{op} \in \{\mathtt{S}, \mathtt{R}\}$. Note that $event_{\mathtt{op}}$ in \defref{def:event} is used to represent the program order of $\mathtt{op}$, where $\mathtt{op} \in \{\mathtt{S}, \mathtt{R}, \mathtt{W}\}$. We also use $NW_{\mathtt{op}}$ to represent the nearest-enclosing wait of $\mathtt{op}$ where $\mathtt{op} \in \{\mathtt{R}\}$.
\begin{definition}
The match pair $\langle\mathtt{R}, \mathtt{S}\rangle$ for a receive $\mathtt{R}$ and a send $\mathtt{S}$ is generated if the following relations are satisfied,
\begin{itemize}
\item $M_{\mathtt{R}} = event_{\mathtt{S}}$ and $M_{\mathtt{S}} = event_{\mathtt{R}}$.
\item $e_{\mathtt{R}} = e_{\mathtt{S}}$.
\item $value_{\mathtt{R}} = value_{\mathtt{S}}$.
\item An \texttt{HB} relation defined in \defref{def:hb} is enforced for $event_{\mathtt{S}}$ and $NW_{\mathtt{R}}$. The rule is presented later in this section.
\end{itemize}
\label{def:match}
\end{definition}
The match pair in \defref{def:match} ensures that a receive is matched with a send such that the destination endpoint of the send operation is the same as the endpoint used by the receive operation, that the value sent by the send operation is the same value received by the receive operation, that the ``match'' value ($\cfgnt{M}$) in the receive(send) tuple is equal to the ``$\cfgnt{event}$'' value in the send(receive) tuple, and that an $\mathtt{HB}$ relation defined in \defref{def:hb} is constrained for the send and the receive's nearest-enclosing wait.

Given the definitions above, following are the rules for the $\mathtt{HB}$ computation:
\begin{itemize}
\item For any pair of operations $\mathtt{op}$ and $\mathtt{op'}$, if $e_{\mathtt{op}} = e_{\mathtt{op'}}$ and $event_{\mathtt{op}}<event_{\mathtt{op'}}$, then we have $event_{\mathtt{op}}\ \mathrm{\prec_{HB}}\ event_{\mathtt{op'}}$.
\item For any operation $\mathtt{op}$, if it has a nearest-enclosing wait $NW_{\mathtt{op}}$, then we have $event_{\mathtt{op}}\ \mathrm{\prec_{HB}}\ NW_{\mathtt{op}}$.
\item For any match pair $\langle\mathtt{R},\mathtt{S}\rangle$, we have $event_{\mathtt{S}}\ \mathrm{\prec_{HB}}\ NW_{\mathtt{R}}$.
\item For any pair of sends $\mathtt{S}$ and $\mathtt{S'}$, if $e_{\mathtt{S}}=e_{\mathtt{S'}}$ and $\mathtt{S}\ \mathrm{\prec_{HB}}\ \mathtt{S'}$, then we have $M_{\mathtt{S}}\ \mathrm{\prec_{\mathtt{HB}}}\ M_{\mathtt{S'}}$.
\item If \textit{zero-buffer} semantics is applied, add any $\mathtt{HB}$ relations to prevent incorrect behavior that is not allowed under \textit{zero-buffer}.
\end{itemize}
Basically, the \texttt{HB} relation asserts that two receives(sends) with common endpoints from the same source are ordered. Also, the \texttt{HB} relation asks an operation to happen before its nearest-enclosing wait if the wait exists in the execution trace. Given that a send is immediately completed and the completion of a receive must be witnessed  by the nearest-enclosing wait, the \texttt{HB} relation also asserts, for any matched pair, that the send happens before the nearest-enclosing wait of the matched receive. It also asserts that no two sends(receives) can match an identical receive(send). Note that the encoding is going to use the ``$\cfgnt{M}$"  value of a send in conjunction with the \texttt{HB} relation to enforce message non-overtaking when messages are sent from the same source. Consider a simple example below that sends two messages from a Task 0 to Task 1,
\[
\begin{array}{l|l}
\;\;\;\;\;\;\;\;\mathtt{Task\ 0}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{Task\ 1}\;\;\;\;\;\;\;\; \\
\hline
\;\;\;\;\;\;\;\;\mathtt{S_{0,1}(1,\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,1}(*,\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{S_{0,2}(1,\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,2}(*,\&h4)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h4)}\;\;\;\;\;\;\;\; \\
\end{array}
\]
The ``$\cfgnt{M}$" values in the send records will be assigned to the order tracking events for $\mathtt{R_{1,1}}$ and $\mathtt{R_{1,2}}$ in the final encoding. Message non-overtaking from transactions on common endpoints is encoded by forcing the send events to be received in program order using the \texttt{HB} relation as below in our simple example:
\[\cfgnt{M}_\mathtt{S_{0,1}}\ \mathrm{\prec_{HB}}\ \cfgnt{M}_\mathtt{S_{0,2}}\]
Last but not least, the $\mathtt{HB}$ relation can also be adapted for \textit{zero-buffer} semantics. For \textit{zero-buffer} semantics, reorganize the encoding as follows: For each match pair that cannot exist in the program runtime under the \textit{zero-buffer} setting, add extra \texttt{HB} relations in the SMT encoding to prevent incorrect behavior. For example in \figref{fig:mcapi}, to prevent $\mathtt{R_{1,3}}$ from being matched with $\mathtt{S_{2,6}}$ before $\mathtt{R_{0,2}}$ is matched with $\mathtt{S_{2,4}}$ as prohibited by the \textit{zero-buffer} semantics, an \texttt{HB} relation is added such that the wait command $\mathtt{W(\&h1)}$ for $\mathtt{R_{0,2}}$ happens before $\mathtt{S_{2,6}}$.


Prior SMT models of MCAPI program executions implicitly compute
match pairs by adding possible \emph{Happens-Before} relations on sends and
receives with the conditions under which those orderings are
valid. The SMT solver is then asked to resolve the \emph{Happens-Before}
relation by choosing specific orders of sends and receives. Match pair
encoding, as presented in this work, though it has the same
computational complexity as order based encoding (you still need to
figure out match pairs on endpoints), is simpler to reason about
directly rather than implicitly through orders, results in
significantly fewer terms in the SMT problem, and does not restrict out possible matches that exist under infinite-buffer semantics.

The presentation of the SMT encoding is structured as
\[\mathit{smt}\ =\ (\mathit{defs}\ \mathit{constraints}\ \mathit{match})\]
where the field $\mathit{defs}$ represents all definitions of the send, receive operations and the variables; The field $\mathit{constraints}$ represents all constraint clauses, including the assert clauses and the clauses built by the \texttt{HB} relations; and the field $\mathit{match}$ represents the set of match pairs.

The input for generating the SMT encoding is an execution trace of an MCAPI program together with a set of match pairs. The first trace in \figref{fig:trace} with the set of match pairs in \figref{fig:smt}(a) is such an example. Given an input, the algorithm for generating our encoding is enumerated as follows.
\begin{enumerate}
\item create event variables for every location in the execution trace. Further create send and receive records for all appropriate locations in the trace. Put these in the $\mathit{def}$ section;
\item for each assume, add a statement to $\mathit{constraints}$, and for each assert, add a negated assert to $\mathit{constraints}$;
\item add \texttt{HB} relations in \textit{constraints} to assert program orders using the rules presented above;
\item in the \textit{match} section, add match pairs for the input send and receive pairs. If a receive can match on multiple sends, then inclose each possible match for that receive in a disjunct.
\end{enumerate}

\begin{figure}
\begin{center}
\setlength{\tabcolsep}{20pt}
\begin{tabular}[t]{cc}
\scalebox{0.7}{\usebox{\boxMP}} &
\scalebox{0.7}{\usebox{\boxSMTc}} \\\\
(a) & (b)
\end{tabular}
\end{center}
\caption{A match pair set and SMT encoding of the system in \figref{fig:mcapi}.
(a) The match pairs based on endpoints. (b) The SMT encoding where $\mathtt{\prec_{HB}}$ creates a
\emph{Happens-Before} constraint, a pair surrounded by $\langle$ and $\rangle$ creates a match pair constraint, and $\mathtt{assume}$ and $\mathtt{assert}$ creates an assume and assert, respectively.}
\label{fig:smt}
\end{figure}

We use our execution trace in \figref{fig:trace} (left side) with the set of match pairs in \figref{fig:smt}(a) as input to go through the algorithm above for generating an SMT encoding shown in \figref{fig:smt}(b). Note that we use the wait command with handler in \figref{fig:trace} to denote the wait command for a send or receive. First, we use step 1 of the algorithm above to generate the $\mathit{defs}$ ``area" that is not shown because the definitions are not novel to our solution. Second, we use step 2 to generate the asserts shown on lines \texttt{11} and \texttt{12} for the assume and assert commands of the original execution trace in \figref{fig:trace}. The first assert on line \texttt{11} works as the assume (line \texttt{14} at trace 1) in \figref{fig:trace}, such that it prevents the SMT solver from finding solutions that are not consistent with control flow which requires ``$b \ge 0$". The second assert on line \texttt{12} is negated as the goal is to find schedules that violate the property. Third, we use step 3 to generate lines \texttt{00} - \texttt{10}, which asserts program orders in the execution. Finally, we use step 4 to generate the $\mathit{match}$ ``area" of the SMT encoding. In particular, we send the set of match pairs in \figref{fig:smt}(a) to the algorithm and generate each match pair and collect those on the same receive into a disjunction on line \texttt{13} - \texttt{15}.

Other than the basic structure of the SMT encoding, we use the function
\[\mathrm{ANS}(\mathit{smt}) \mapsto \{\mathrm{\cfgt{SAT}},\mathrm{\cfgt{UNSAT}}\} \]
to return the solution of an SMT problem, such that $\mathrm{\cfgt{SAT}}$ represents a satisfiable solution that finds a trace of the MCAPI program execution that violates the user defined correctness property, and $\mathrm{\cfgt{UNSAT}}$ represents an unsatisfiable solution indicating that all possible execution traces either meet the correctness property in the same control flow, or follow a different control flow. Note that $\mathrm{\cfgt{UNSAT}}$ and $\mathrm{\cfgt{SAT}}$ are ordered such that $\mathrm{\cfgt{UNSAT}} < \mathrm{\cfgt{SAT}}$.

The SMT encoding defined above is used to capture the non-deterministic behaviors of an MCAPI program execution by giving a complete set of match pairs. As we discussed in the previous section, the MCAPI program in \figref{fig:mcapi} contains two outcomes of execution as defined in the MCAPI specification under the infinite-buffer semantics. The SMT encoding we present in \figref{fig:smt}(b) captures both execution traces, since the set of match pairs in \figref{fig:smt}(a) is a complete set where all matches that can occur in the real execution for our running example in \figref{fig:mcapi} are included, and all matches that cannot occur in the real execution are not included. Further, the following theorem states that we can over-approximate the true set of match pairs and still prove correctness. If there is no error with the over-approximated set, then there is no error arising from non-determinism in the runtime on that program execution. If there is an error from the over-approximated set, that error is also guaranteed to be a real error in the program runtime. Note that two SMT problems $\smt_{\alpha}$ and $\smt_{\beta}$ in the following theorem have identical $\mathit{defs}$ and $\mathit{constraints}$ sets, and differ only by match set.
\\
\\
\textbf{Theorem 1.}
The relation for the solutions of two SMT problems $\smt_{\alpha}$ $= (\mathit{defs}$ $\mathit{constraints}$ $\mathit{match}_{\alpha})$ and $\smt_{\beta}$ $= (\mathit{defs}$ $\mathit{constraints}$ $\mathit{match_{\beta}})$ is,
\[\mathrm{ANS}(\smt_{\alpha}) \leq \mathrm{ANS}(\smt_{\beta})\]
where $\mathit{set(match_{\alpha})} \subseteq \mathit{set(match_{\beta})}$. Note that $\mathit{set(match)}$ represents the input set of match pairs in the $\mathit{match}$ field.
\label{thm:1}
\begin{figure}
\begin{center}
\setlength{\tabcolsep}{3pt}
\begin{tabular}[c]{cc}
%\scalebox{0.7}{\usebox{\boxMP}} &
\scalebox{0.7}{\usebox{\boxSMTa}} &
\scalebox{0.7}{\usebox{\boxSMTb}} \\\\
%\scalebox{0.7}{\usebox{\boxSMTc}} \\
(a) & (b)
\end{tabular}
\end{center}
\caption{Two SMT encodings of the system in \figref{fig:mcapi}.
(a) The SMT encoding for Trace 1 in \figref{fig:trace}. (b) The SMT encoding for Trace 2 in \figref{fig:trace}.}
\label{fig:smt_trace}
\end{figure}
\\
\textbf{Proof Sketch.}
Consider the MCAPI program in \figref{fig:mcapi} as an example.
\figref{fig:smt_trace}(a) and (b) are two different SMT encodings for our running
example in \figref{fig:mcapi} generated from different sets of possible match pairs, such that \figref{fig:smt_trace}(a) encodes trace 1 in \figref{fig:trace} and \figref{fig:smt_trace}(b) encodes trace 2 in \figref{fig:trace}. By solving the encodings in \figref{fig:smt_trace}(a) and (b) for trace 1 and 2 in \figref{fig:trace} respectively, we get an unsatisfiable solution for \figref{fig:smt_trace}(a), and a satisfiable solution for \figref{fig:smt_trace}(b). As we discussed in Section 2, trace 1 is an execution trace without failure of the assertion, and trace 2 is the one that fails the assertion. %We can see that the encodings in \figref{fig:smt_trace} (a) and (b) correctly encodes trace 1 and 2 in \figref{fig:trace}, respectively.
Compare both encodings with that in \figref{fig:smt}(b), we find that the fields $\mathit{defs}$ and $\mathit{constraints}$ are identical except for the set of match pairs. In particular, the input set of match pairs of either \figref{fig:smt_trace}(a) or (b) is the subset of that in \figref{fig:smt}(b). As discussed above, the encoding in \figref{fig:smt}(b) captures the non-deterministic behavior of our running program in \figref{fig:mcapi}, which encodes trace 1 and 2 in \figref{fig:trace} into one single SMT problem. Thus, an SMT solver will return a satisfiable solution for the encoding in \figref{fig:smt}(b). Thus, $\mathrm{ANS}$ on the encoding in \figref{fig:smt}(b) is greater than or equal to the $\mathrm{ANS}$ on the encoding in either \figref{fig:smt_trace}(a) or (b). In other words, adding more match pairs can only move the $\mathrm{ANS}$ from $\mathrm{\cfgt{UNSAT}}$ to $\mathrm{\cfgt{SAT}}$.

The formal proof of Theorem 1 is in the long version of our paper at ``http://students.cs.byu.edu/$\sim$yhuang2/downloads\\/paper.pdf". The proof defines a formal operational semantics given by a term rewriting system using a \textit{CESK}\footnote{The \textit{CESK} machine state is represented with a \textbf{C}ontrol string, \textbf{E}nvironment, \textbf{S}tore, and \textbf{K}ontinuation.} style machine only the machine is augmented to include additional structure for modeling message passing. The operational framework defines how to execute a program, following the specified trace, and defines when that execution is a success (causes no assertion violation), a failure (causes an assertion violation), infeasible (causes an assume to not hold), or an error (execution is not allowed by the MCAPI semantics.). Further, the machine generates the terms of the SMT encoding as it rewrites the machine states. The proof defines a combination operator and shows that several SMT encodings can be combined such that the combined SMT encoding returns ``SAT" if one of those encodings has a satisfiable solution.  As such, Theorem 1 is formally proved by applying the combination operator for $\smt_{\alpha}$ and $\smt_{\beta}$.

Assume $\mathit{set(match_{\alpha})}$ and $\mathit{set(match_{\beta})}$ in the theorem above a complete set of match pairs and an over-approximated set, respectively, we can further prove that $\mathrm{ANS}(\smt_{\alpha})$ $ = $ $\mathrm{ANS}(\smt_{\beta})$ by giving the following theorem. Note that a match pair $\langle \mathtt{R},\mathtt{S}\rangle \in \mathit{set(match_{\beta})}/\mathit{set(match_{\alpha})}$ is called ``bogus", since it cannot exist in a real execution of the program.
\\
\\
\textbf{Theorem 2.}
Any match pair $\langle \mathtt{R}, \mathtt{S}\rangle$ used in a satisfying assignment of an SMT encoding $\smt$ is a valid match pair and reflects an actual possible MCAPI program execution.
\\
\textbf{Proof.}
Proof by contradiction. Assume that $\langle \mathtt{R}, \mathtt{S}\rangle$ is a ``bogus" match pair that causes $\mathrm{ANS}(\smt) = \cfgt{SAT}$. Since $\langle \mathtt{R}, \mathtt{S}\rangle$ is not a valid match pair, match $\mathtt{R}$ and $\mathtt{S}$ requires program order, message non-overtaking, or no-multiple match to be violated. In other words, the $\mathtt{HB}$ constraints encoded in $\smt$ are not satisfied. Based on the fact above, the answer of $\smt$ is $\cfgt{UNSAT}$ and it contradicts the previous hypothesis. Thus, $\langle \mathtt{R}, \mathtt{S}\rangle$ is a valid match pair in $\smt$ and reflects an actual possible MCAPI program execution. $\Box$


By proving Theorem 2, we infer that a ``bogus" match pair can only cause an unsatisfying assignment of an SMT problem. Further, given that $\mathit{set(match_{\alpha})}$ and $\mathit{set(match_{\beta})}$ reflect a complete set and a over-approximated set respectively, the answers of $\smt_{\alpha}$ and $\smt_{\beta}$ discussed above are equal since any ``bogus" match pair involved in $\smt_{\beta}$ is only used in unsatisfying assignments.











