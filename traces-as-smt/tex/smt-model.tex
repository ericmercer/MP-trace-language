\newcommand{\epsnd}{\textit{Pnd\_s}}
\newcommand{\eprcv}{\textit{Pnd\_r}}
\newcommand{\qset}{\textit{Q\_s}}
\newcommand{\snd}{\textit{snd}}
\newcommand{\rcv}{\textit{rcv}}
\newcommand{\q}{\textit{q}}
\newcommand{\frm}{\textit{frm}}
\newcommand{\vbot}{\textit{v$-\bot$}}
\newcommand{\status}{\textit{s}}
\newcommand{\last}{\textit{l}}
\newcommand{\error}{\ensuremath{\mathbf{error}}}
\newcommand{\aidmap}{\textit{A}}
\newcommand{\thread}{\ensuremath{\mathit{t}}}
\newcommand{\aid}{\ensuremath{\mathit{a}}}
\newcommand{\ploc}{\ensuremath{\rho}}
\newcommand{\loc}{\ensuremath{\mathit{l}}}
\newcommand{\cmd}{\ensuremath{\mathit{c}}}
\newcommand{\op}{\ensuremath{\mathit{op}}}
\newcommand{\applyop}{\ensuremath{\mathrm{op}}}
\newcommand{\wait}{\ensuremath{\mathbf{wait}}}
\newcommand{\sendi}{\ensuremath{\mathbf{sndi}}}
\newcommand{\recvi}{\ensuremath{\mathbf{rcvi}}}
\newcommand{\traceentry}{\ensuremath{\sigma}}
\newcommand{\movelist}{\ensuremath{\delta}}
\newcommand{\assume}{\ensuremath{\mathit{assume}}}
\newcommand{\checkassume}{\ensuremath{\mathrm{assume}}}
\newcommand{\assert}{\ensuremath{\mathit{assert}}}
\newcommand{\checkassert}{\ensuremath{\mathrm{assert}}}
\newcommand{\ep}{\ensuremath{\mathbf{\gamma}}}
\newcommand{\src}{\ensuremath{\alpha}}
\newcommand{\dst}{\ensuremath{\beta}}
\newcommand{\true}{\ensuremath{\mathbf{true}}}
\newcommand{\false}{\ensuremath{\mathbf{false}}}
\newcommand{\match}{\ensuremath{\mathrm{m}}}
\newcommand{\matchl}{\ensuremath{\mathrm{match}}}
\newcommand{\findrecv}{\ensuremath{\mathrm{search_r}}}
\newcommand{\smt}{\ensuremath{\mathit{smt}}}


\newcommand{\addsend}{\ensuremath{\mathrm{addsend}}}
\newcommand{\getsend}{\ensuremath{\mathrm{getsend}}}
\newcommand{\removesend}{\ensuremath{\mathrm{removesend}}}
\newcommand{\addrecv}{\ensuremath{\mathrm{addrecv}}}
\newcommand{\getrecv}{\ensuremath{\mathrm{getrecv}}}
\newcommand{\removerecv}{\ensuremath{\mathrm{removefrecv}}}
\newcommand{\hextend}{\ensuremath{\mathrm{hextend}}}
\newcommand{\hlookup}{\ensuremath{\mathrm{hlookup}}}
\newcommand{\etalookup}{\ensuremath{\mathrm{etalookup}}}
\newcommand{\checkmatch}{\ensuremath{\mathrm{checkmatch}}}
\newcommand{\getep}{\ensuremath{\mathrm{getEP}}}
\newcommand{\getmarkremove}{\ensuremath{\mathrm{getMarkRemove}}}
\newcommand{\getlastsendreplace}{\ensuremath{\mathrm{getlastsend/replace}}}
\newcommand{\statuschange}{\left\{ \begin{array}{ll}  \status &\ \mathrm{if}\ |\epsnd(\dst)(\src)|>0\\
   \mathit{error} &\  \mathrm{otherwise}\end{array}\right .}

\newcommand{\reduce}[1]{\ensuremath{\rightarrow_{#1}}}
% Multiple reductions
\newcommand{\reduceK}[1]{\ensuremath{\rightarrow_{#1}^{*}}}
% Non-deterministic reductions
\newcommand{\reduceN}[1]{\ensuremath{\dashrightarrow_{#1}}}
\newcommand{\reduceNK}[1]{\ensuremath{\dashrightarrow_{#1}^{*}}}
\newcommand{\mt}{\ensuremath{\emptyset}}
\newcommand{\trace}{\ensuremath{\mathit{trace}}}
\newcommand{\movebot}{\ensuremath{\mathit{m}}}
\newcommand{\ret}{\ensuremath{\mathbf{ret}}}

\newcommand{\defs}{\ensuremath{\mathrm{defs}}}
\newcommand{\any}{\ensuremath{\mathrm{any}}}
\newcommand{\negate}{\ensuremath{\mathrm{not}}}
\newcommand{\define}{\ensuremath{\mathrm{define}}}
\newcommand{\andd}{\ensuremath{\mathrm{and}}}
\newcommand{\select}{\ensuremath{\mathrm{select}}}
\newcommand{\HB}{\ensuremath{\mathrm{HB}}}
\newcommand{\getlast}{\ensuremath{\mathrm{last}}}
\newcommand{\MATCH}{\ensuremath{\mathrm{MATCH}}}
\newcommand{\ml}{\ensuremath{\mathit{ML}}}
\newcommand{\matchpair}{\ensuremath{\mathrm{MP}}}
\newcommand{\recv}{\ensuremath{\mathrm{\mu}}}
\newcommand{\send}{\ensuremath{\mathrm{\nu}}}

\newsavebox{\boxSMTa}
\begin{lrbox}{\boxSMTa}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h1)}}$}\\
\texttt{01 $\mathit{event_\mathtt{R_{0,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h2)}}$}\\
\texttt{02 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{R_{0,5}}}$}\\
\texttt{03 $\mathit{event_\mathtt{R_{1,3}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h3)}}$}\\
\texttt{04 $\mathit{event_\mathtt{S_{1,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h4)}}$}\\
\texttt{05 $\mathit{event_\mathtt{S_{2,4}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h5)}}$}\\
\texttt{06 $\mathit{event_\mathtt{S_{2,7}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h6)}}$}\\
\texttt{07 ($\mathit{assert}$ (> b 0))}\\
\texttt{08 ($\mathit{assert}$ (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{09 $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{2,4}}\rangle$}\\
\texttt{10 $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{1,5}}\rangle$}\\
\texttt{11 $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTb}
\begin{lrbox}{\boxSMTb}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h1)}}$}\\
\texttt{01 $\mathit{event_\mathtt{R_{0,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h2)}}$}\\
\texttt{02 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{R_{0,5}}}$}\\
\texttt{03 $\mathit{event_\mathtt{R_{1,3}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h3)}}$}\\
\texttt{04 $\mathit{event_\mathtt{S_{1,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h4)}}$}\\
\texttt{05 $\mathit{event_\mathtt{S_{2,4}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h5)}}$}\\
\texttt{06 $\mathit{event_\mathtt{S_{2,7}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h6)}}$}\\
\texttt{07 ($\mathit{assert}$ (> b 0))}\\
\texttt{08 ($\mathit{assert}$ (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{09 $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{1,5}}\rangle$}\\
\texttt{10 $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{2,4}}\rangle$}\\
\texttt{11 $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTc}
\begin{lrbox}{\boxSMTc}
\normalsize
\begin{tabular}[t]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h1)}}$}\\
\texttt{01 $\mathit{event_\mathtt{R_{0,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h2)}}$}\\
\texttt{02 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{R_{0,5}}}$}\\
\texttt{03 $\mathit{event_\mathtt{R_{1,3}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h3)}}$}\\
\texttt{04 $\mathit{event_\mathtt{S_{1,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h4)}}$}\\
\texttt{05 $\mathit{event_\mathtt{S_{2,4}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h5)}}$}\\
\texttt{06 $\mathit{event_\mathtt{S_{2,7}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h6)}}$}\\
\texttt{07 ($\mathit{assert}$ (> b 0))}\\
\texttt{08 ($\mathit{assert}$ (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{09} $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{2,4}}\rangle\vee\langle\mathtt{R_{0,2}}$,$\mathtt{S_{1,5}}\rangle$\\
\texttt{10} $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{2,4}}\rangle\vee\langle\mathtt{R_{0,5}}$,$\mathtt{S_{1,5}}\rangle$\\
\texttt{11} $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxMP}
\begin{lrbox}{\boxMP}
\normalsize
\begin{tabular}[t]{l}
\\\\\\\\\\\\\\\\\\
$\langle\mathtt{R_{0,2}}$, $\mathtt{S_{2,4}}\rangle$\\
$\langle\mathtt{R_{0,2}}$, $\mathtt{S_{1,5}}\rangle$\\
\\
$\langle\mathtt{R_{0,5}}$, $\mathtt{S_{2,4}}\rangle$\\
$\langle\mathtt{R_{0,5}}$, $\mathtt{S_{1,5}}\rangle$\\
\\
$\langle\mathtt{R_{1,3}}$, $\mathtt{S_{2,7}}\rangle$\\
\end{tabular}
\end{lrbox}

\section{SMT Encoding}\label{sec:smt}

Our SMT encoding is based on (1) a trace of events during an execution
of an MCAPI program including control-flow assumptions and property
assertions, such as \figref{fig:trace1} and (2) a set of possible
match pairs.

A match pair is the coupling of a receive to a particular
send. \figref{fig:smt}(a) is the set of possible match pairs for the
program in \figref{fig:mcapi} using our shorthand notation. The set
admits, for example, that $\mathtt{R_{0,2}}$ can be matched with
either $\mathtt{S_{1,5}}$ or $\mathtt{S_{2,4}}$.

This match pair-based encoding, rather than state-based or order-based
encoding~\cite{elwakil:padtad10,elwakil:atva10}, is novel.

The purpose of the SMT encoding is to force the SMT solver to resolve
the match pairs for the system in such a way that the final values of
program variables meet the assumptions on control flow but violate
some assertion. In essence, the SMT solver completes a partial order
on events into a total order that determines the final match pair
relationships.

\subsection{Definitions}

The encoding needs to express the partial order imposed by the MCAPI
semantics as SMT constraints. The partial order is based on a
\emph{Happens-Before} relation over events:

\begin{definition}[Happens-Before]
The \emph{Happens-Before} $(\mathtt{HB})$ relation denoted as
$\mathrm{\prec_\mathtt{HB}}$ is a partial order.
\label{def:hb}
\end{definition}

Given two events, $A$ and $B$, if $A$ must complete before $B$ in a
valid program execution, then $A$ $\mathrm{\prec_{\mathtt{HB}}}$ $B$
will be an SMT constraint.

The constraints on this relation are derived from the program source
and match pairs. In order to specify the constraints from the program
source, we must map each operation to a order variable. For example,

\begin{definition}[Wait] \label{def:event}
For a wait operation \texttt{W}, the only relevant information is when
it occurs, so we create a variable $\mathit{order}_\mathtt{W}$.
\end{definition}

However, it is not enough to represent all events as simple numbers
that will be ordered in this way. This would not allow the solver to
discover what values would flow across communication primitives, for
example. Instead, we represent each event in the trace as a set of SMT
variables that record the pertinent information about the event. For
example,

\begin{definition}[Send] \label{def:snd}
For every send operation $\mathtt{S}$, we create four variables:
\begin{compactenum}
\item $M_\mathtt{S}$, the order of the matching receive event;

\item $\mathit{order}_\mathtt{S}$, the order of the send;

\item $e_\mathtt{S}$, the endpoint; and,

\item $\mathit{value}_\mathtt{S}$, the transmitted value.
\end{compactenum}
\end{definition}

The most complex operation in MCAPI is a receive. Since receives are
inherently asynchronous, it is not possible to represent them
atomically. Instead, we need to associate each receive with a wait
where the program expects the operation to be completed by. A single
wait can be associated with many receives due to \emph{the message
  non-overtaking property} required by MCAPI. We refer to this wait as
the \emph{nearest-enclosing wait}.

\begin{definition}[Nearest-Enclosing Wait] \label{def:nw}
A wait that witnesses the completion of a receive by indicating that
the message is delivered and that all the previous receives in the
same task issued earlier are complete as well.
\end{definition}

\begin{figure}[h]
\[
\begin{array}{l|l}
\;\;\;\;\;\;\;\;\mathtt{Task\ 0}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{Task\ 1}\;\;\;\;\;\;\;\; \\
\hline
\;\;\;\;\;\;\;\;\mathtt{R_{0,1}(*,\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{S_{1,1}(0,\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{R_{0,2}(*,\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W{(\&h3)}}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W{(\&h2)}}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{S_{1,2}(0,\&h4)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W{(\&h1)}}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W{(\&h4)}}\;\;\;\;\;\;\;\; \\
\end{array}
\]
\caption{Nearest-enclosing Wait example} \label{fig:nw}
\end{figure}

\figref{fig:nw} shows that the wait $\mathtt{W{(\&h2)}}$
witnesses the completion of the receive $\mathtt{R_{0,1}}$ and
$\mathtt{R_{0,2}}$ in Task 0. Thus, $\mathtt{W{(\&h2)}}$ is their
nearest-enclosing wait.

We assume that every receive operation has a nearest-enclosing
wait. This assumption disallows a few a misbehaving programs, those
that receive but never wait for the operation to complete before
continuing.  (We could use the same assumption for sends, since MCAPI
allows waiting on send operations as well, but we deal with send
buffering differently.)

Given this definition, we can define the pertinent information of a
receive:

\begin{definition}[Receive] \label{def:rcv}
For every receive operation $\mathtt{R}$ we create five variables:
\begin{compactenum}
\item $M_\mathtt{R}$, the order of the matching send event;

\item $\mathit{order}_\mathtt{R}$, the order of the receive;

\item $e_\mathtt{R}$, the endpoint;

\item $\mathit{value}_\mathtt{R}$, the received valued; and,

\item $\mathit{nw}_\mathtt{R}$, the order of the nearest enclosing wait.
\end{compactenum}
\end{definition}

\subsection{Constraints}

These definitions so far merely establish the pertinent information
about each event in the trace as SMT variables. We must also express
the constraints on those variables.

The most trivial kind of constraint are those for control-flow
assumptions.

\begin{definition}[Assumption] \label{def:assm}
For every assumption $\mathtt{A}$, we add it as an SMT assertion.
\end{definition}

It may seem strange to turn \emph{assumptions} into a
\emph{assertions}, but from a constraint perspective, the assumption
that we have already observed some property (during control-flow) is
equivalent to instructing the SMT solver to treat it is inviolate
truth, or assertion.

The next level of constraint complexity comes from property
assertions. These correspond to the invariants of the program. Our
goal is to discover if they can be violated, so we instruct the SMT
solver to seek for a way to satisfy their \emph{negation} given all
the other constraints.

\begin{definition}[Property Assertion] \label{def:assert}
For every property assertion $\mathtt{P}$, we add $\neg \mathtt{P}$ as
an SMT assertion.
\end{definition}

Finally, we must express each match pair as a set of SMT
constraints. Informally, a match pair equates the shared components of
a send and receive and constrains the send to occur before the
nearest-enclosing wait of the receive. Formally:

\begin{definition}[Match Pair] \label{def:match}
A match pair, $\langle\mathtt{R}, \mathtt{S}\rangle$, for a receive
$\mathtt{R}$ and a send $\mathtt{S}$ corresponds to the constraints:
\begin{compactenum}
\item $M_{\mathtt{R}} = \mathit{order}_{\mathtt{S}}$
\item $M_{\mathtt{S}} = \mathit{order}_{\mathtt{R}}$
\item $e_{\mathtt{R}} = e_{\mathtt{S}}$
\item $\mathit{value}_{\mathtt{R}} = \mathit{value}_{\mathtt{S}}$ and
\item $\mathit{order}_{\mathtt{S}}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{nw}_{\mathtt{R}}$
\end{compactenum}
\end{definition}

However, these match pair constraints are not simply unioned. If we
were to do that, then we would be constraining the system such that a
single receive were paired with multiple sends if both were valid
match pairs. Therefore, we combine all the constraints for a receive's
match pairs into a single disjunction:

\begin{definition}[Receive Matches]
For each receive $\mathtt{R}$, if $\langle\mathtt{R},
\mathtt{S}_0\rangle$ through $\langle\mathtt{R}, \mathtt{S}_n\rangle$
are match pairs, then $\bigvee_{i}^{n} \langle\mathtt{R},
\mathtt{S}_i\rangle$ is used as an SMT constraint.
\end{definition}

This encoding of the input ensures that the SMT solver can only use
compatible send/receive pairs and ensures that sends happen ``before''
receives.

\subsection{More \emph{Happens-Before} Constraints}

The encoding is not sufficient, though. We must extend it with
additional constraints on the \emph{Happens-Before} relation, which we
do in four steps. We must ensure that sends to common endpoints occur
in program order in a single task (step 1); similarly for receives
(step 2); receives occur before their nearest-enclosing wait (step 3);
and, that sends are received in the order they are sent (step 4).

\paragraph*{Step 1} For each thread, if there are multiple send
operations, say $\mathtt{S}$ and $\mathtt{S^\prime}$, from that thread
to a common endpoint, $e_\mathtt{S} = e_\mathtt{S^\prime}$, then those
sends must follow program order: $\mathit{order}_\mathtt{S}$
$\prec_\mathtt{HB}$ $\mathit{order}_\mathtt{S^\prime}$.

\paragraph*{Step 2} For each thread, if there are multiple receive
operations, say $\mathtt{R}$ and $\mathtt{R^\prime}$, from that thread
to a common endpoint, $e_\mathtt{S} = e_\mathtt{S^\prime}$, then those
receives must follow program order: $\mathit{order}_\mathtt{R}$
$\prec_\mathtt{HB}$ $\mathit{order}_\mathtt{R^\prime}$.

\paragraph*{Step 3} For every receive \texttt{R} and its nearest
enclosing wait \texttt{W}, $\mathit{order}_\mathtt{R}$
$\prec_\mathtt{HB}$ $\mathit{order}_\mathtt{W}$.

\paragraph*{Step 4} For any pair of sends $\mathtt{S}$ and
$\mathtt{S'}$ on common endpoints, $e_{\mathtt{S}}=e_{\mathtt{S'}}$,
such that
$\mathit{order}_\mathtt{S}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{order}_\mathtt{S'}$,
then those sends must be received in the same order:
$M_{\mathtt{S}}\ \mathrm{\prec_{\mathtt{HB}}}\ M_{\mathtt{S'}}$.

For example, consider two tasks where Task 0 sends two messages to
Task 1 as shown in \figref{fig:step4}.

\begin{figure}[h]
\[
\begin{array}{l|l}
\;\;\;\;\;\;\;\;\mathtt{Task\ 0}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{Task\ 1}\;\;\;\;\;\;\;\; \\
\hline
\;\;\;\;\;\;\;\;\mathtt{S_{0,1}(1,\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,1}(*,\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{S_{0,2}(1,\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,2}(*,\&h4)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h4)}\;\;\;\;\;\;\;\; \\
\end{array}
\]
\caption{Send Ordering Example} \label{fig:step4}
\end{figure}

The \texttt{M} variables from the sends will be assigned to the orders
for $\mathtt{R_{1,1}}$ and $\mathtt{R_{1,2}}$ by the match-pairs
selected by the SMT solver. The constraints added in this step force
the send to be received in program order using the \texttt{HB}
relation which for this example yields
$\cfgnt{M}_\mathtt{S_{0,1}}\ \mathrm{\prec_\mathtt{HB}}\ \cfgnt{M}_\mathtt{S_{0,2}}$.

\subsection{Zero Buffer Semantics}

The constraints presented so far correspond to an infinite-buffer
semantics, because we do not constrain how many messages may be ``in
transit'' at once. We can add additional, orthogonal, constraints to
restrict such behavior and enforce a zero-buffer semantics. There are
two kinds of such constraints.

First, for each thread, if there are two sends $\mathtt{S}$ and
$\mathtt{S'}$ such that
$\mathit{order}_\mathtt{S}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{order}_\mathtt{S'}$,
and $\mathtt{S}$ and $\mathtt{S'}$ can both match a receive
$\mathtt{R}$, then we add the following constraint to the encoding:
$\mathit{order}_{\mathtt{W(\&h)}}\ \mathrm{\prec_{\mathtt{HB}}}\ \mathit{order}_{\mathtt{S'}}$
where $\mathtt{W(\&h)}$ is a wait function that witnesses the
completion of $\mathtt{R}$ in execution.

Second, for each pair of sends $\mathtt{S}$ and $\mathtt{S'}$, if
there is a receive $\mathtt{R}$ such that

\begin{compactenum}
\item $\mathtt{R'}$ is a preceding receive over $\mathtt{S}$ in an
  identical thread; Or

\item there exists a match pair $\langle\mathtt{R''},
  \mathtt{S''}\rangle$ such that $\langle\mathtt{R}, \mathtt{S}\rangle
  \rightarrow \langle\mathtt{R''}, \mathtt{S''}\rangle$ and
  $\langle\mathtt{R''}, \mathtt{S''}\rangle \rightarrow
  \langle\mathtt{R'}, \mathtt{S'}\rangle$.
\end{compactenum}

Then we add the following constraint to the encoding:
$\mathit{order}_{\mathtt{W(\&h)}}\ \mathrm{\prec_{\mathtt{HB}}}\ \mathit{order}_{\mathtt{S'}}$
where $\mathtt{W(\&h)}$ is a wait function that witnesses the
completion of $\mathtt{R}$ in execution.

\subsection{Example}

--- XXX ---

As an intuitive example, we revisit the example in
\figref{fig:mcapi}. In order to prevent $\mathtt{R_{1,3}}$ from being matched
with $\mathtt{S_{2,6}}$ before $\mathtt{R_{0,2}}$ is matched with
$\mathtt{S_{2,4}}$, add
$\mathit{event}_\mathtt{W(\&h1)}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{event}_\mathtt{S_{1,5}}$.

\begin{figure}
\begin{center}
\setlength{\tabcolsep}{20pt}
\begin{tabular}[t]{cc}
\scalebox{0.7}{\usebox{\boxMP}} &
\scalebox{0.7}{\usebox{\boxSMTc}} \\\\
(a) & (b)
\end{tabular}
\end{center}
\caption{A match pair set and SMT encoding of the system in \figref{fig:mcapi}.
(a) The match pairs based on endpoints. (b) The SMT encoding where $\mathtt{\prec_\mathtt{HB}}$ creates a
\emph{Happens-Before} constraint, a pair surrounded by $\langle$ and $\rangle$ creates a match pair constraint, and $\mathtt{assume}$ and $\mathtt{assert}$ creates an assume and assert, respectively.}
\label{fig:smt}
\end{figure}

\figref{fig:smt}(b) is the final encoding for the trace which is
explained here. The encoding is divided into three sections:
\textit{SMT = \{defs constraints match\}}. Stage 1 is not shown
because the definitions are not novel to our solution; suffice to say
that variables are created as defined. The constraints section is
created by stages 2-7. Lines \texttt{00} - \texttt{06} reflect program
orders in the trace. Lines \texttt{07} and \texttt{08} for the assume
and assert commands of the original execution trace in
\figref{fig:trace}. The first assert on line \texttt{07} (line
\texttt{14} at trace 1) prevents the SMT solver from finding solutions
that are not consistent with control flow which requires ``$b \ge
0$". The second assert on line \texttt{08} is negated as the goal is
to find schedules that violate the property. Finally, stage 8
generates the $\mathit{match}$ ``area" of the SMT encoding. In
particular, we send the set of match pairs in \figref{fig:smt}(a) to
the algorithm and generate each match pair and collect those on the
same receive into a disjunction on line \texttt{09} - \texttt{11}.

\subsection{Correctness}

Other than the basic structure of the SMT encoding, we use the
function
\[\mathrm{ANS}(\mathit{smt}) \mapsto \{\mathrm{\cfgt{SAT}},\mathrm{\cfgt{UNSAT}}\} \]
to return the solution of an SMT problem, such that
$\mathrm{\cfgt{SAT}}$ represents a satisfiable solution that finds a
trace of the MCAPI program execution that violates the user defined
correctness property, and $\mathrm{\cfgt{UNSAT}}$ represents an
unsatisfiable solution indicating that all possible execution traces
either meet the correctness property in the same control flow, or
follow a different control flow. Note that $\mathrm{\cfgt{UNSAT}}$ and
$\mathrm{\cfgt{SAT}}$ are ordered such that $\mathrm{\cfgt{UNSAT}} <
\mathrm{\cfgt{SAT}}$.

The SMT encoding defined above is used to capture the
non-deterministic behaviors of an MCAPI program execution by giving a
complete set of match pairs. As we discussed in the previous section,
the MCAPI program in \figref{fig:mcapi} contains two outcomes of
execution as defined in the MCAPI specification under the
infinite-buffer semantics. The SMT encoding we present in
\figref{fig:smt}(b) captures both execution traces, since the set of
match pairs in \figref{fig:smt}(a) is a complete set where all matches
that can occur in the real execution for our running example in
\figref{fig:mcapi} are included, and all matches that cannot occur in
the real execution are not included. Further, the following theorem
states that we can over-approximate the true set of match pairs and
still prove correctness. If there is no error with the
over-approximated set, then there is no error arising from
non-determinism in the runtime on that program execution. If there is
an error from the over-approximated set, that error is also guaranteed
to be a real error in the program runtime. Note that two SMT problems
$\smt_{\alpha}$ and $\smt_{\beta}$ in the following theorem have
identical $\mathit{defs}$ and $\mathit{constraints}$ sets, and differ
only by match set.

\begin{theorem}
The relation for the solutions of two SMT problems $\smt_{\alpha}$ $= (\mathit{defs}$ $\mathit{constraints}$ $\mathit{match}_{\alpha})$ and $\smt_{\beta}$ $= (\mathit{defs}$ $\mathit{constraints}$ $\mathit{match_{\beta}})$ is,
\[\mathrm{ANS}(\smt_{\alpha}) \leq \mathrm{ANS}(\smt_{\beta})\]
where $\mathit{set(match_{\alpha})} \subseteq \mathit{set(match_{\beta})}$. Note that $\mathit{set(match)}$ represents the input set of match pairs in the $\mathit{match}$ field.
\label{thm:1}
\end{theorem}

\begin{figure}[h]
\begin{center}
\setlength{\tabcolsep}{3pt}
\begin{tabular}[c]{cc}
%\scalebox{0.7}{\usebox{\boxMP}} &
\scalebox{0.7}{\usebox{\boxSMTa}} &
\scalebox{0.7}{\usebox{\boxSMTb}} \\\\
%\scalebox{0.7}{\usebox{\boxSMTc}} \\
(a) & (b)
\end{tabular}
\end{center}
\caption{Two SMT encodings of the system in \figref{fig:mcapi}.
(a) The SMT encoding for Trace 1 in \figref{fig:trace}. (b) The SMT encoding for Trace 2 in \figref{fig:trace}.}
\label{fig:smt_trace}
\end{figure}

\begin{proof}[Proof Sketch]
Consider the MCAPI program in \figref{fig:mcapi} as an example.
\figref{fig:smt_trace}(a) and (b) are two different SMT encodings for our running
example in \figref{fig:mcapi} generated from different sets of
possible match pairs, such that \figref{fig:smt_trace}(a) encodes
trace 1 in \figref{fig:trace} and \figref{fig:smt_trace}(b) encodes
trace 2 in \figref{fig:trace}. By solving the encodings in
\figref{fig:smt_trace}(a) and (b) for trace 1 and 2 in
\figref{fig:trace} respectively, we get an unsatisfiable solution for
\figref{fig:smt_trace}(a), and a satisfiable solution for
\figref{fig:smt_trace}(b). As we discussed in Section 2, trace 1 is an
execution trace without failure of the assertion, and trace 2 is the
one that fails the assertion.

Compare both encodings with that in \figref{fig:smt}(b), we find that
the fields $\mathit{defs}$ and $\mathit{constraints}$ are identical
except for the set of match pairs. In particular, the input set of
match pairs of either \figref{fig:smt_trace}(a) or (b) is the subset
of that in \figref{fig:smt}(b). As discussed above, the encoding in
\figref{fig:smt}(b) captures the non-deterministic behaviors of our
running program in \figref{fig:mcapi}, which encodes trace 1 and 2 in
\figref{fig:trace} into one single SMT problem. Thus, an SMT solver
will return a satisfiable solution for the encoding in
\figref{fig:smt}(b). Thus, $\mathrm{ANS}$ on the encoding in
\figref{fig:smt}(b) is greater than or equal to the $\mathrm{ANS}$ on
the encoding in either \figref{fig:smt_trace}(a) or (b). In other
words, adding more match pairs can only move the $\mathrm{ANS}$ from
$\mathrm{\cfgt{UNSAT}}$ to $\mathrm{\cfgt{SAT}}$.
\end{proof}

The formal proof of \thmref{thm:1} is in the long version of our
paper\footnote{\texttt{http://students.cs.byu.edu/$\sim$yhuang2/downloads\\/paper.pdf}}. The
proof defines a formal operational semantics given by a term rewriting
system using a \textit{CESK}\footnote{The \textit{CESK} machine state
  is represented with a \textbf{C}ontrol string, \textbf{E}nvironment,
  \textbf{S}tore, and \textbf{K}ontinuation.} style machine only the
machine is augmented to include additional structure for modeling
message passing. The operational framework defines how to execute a
program, following the specified trace, and defines when that
execution is a success (causes no assertion violation), a failure
(causes an assertion violation), infeasible (causes an assume to not
hold), or an error (execution is not allowed by the MCAPI
semantics.). Further, the machine generates the terms of the SMT
encoding as it rewrites the machine states. The proof defines a
combination operator and shows that several SMT encodings can be
combined such that the combined SMT encoding returns
$\mathrm{\cfgt{SAT}}$ if one of those encodings has a satisfiable
solution.  As such, Theorem 1 is formally proved by applying the
combination operator for $\smt_{\alpha}$ and $\smt_{\beta}$.

Assume $\mathit{set(match_{\alpha})}$ and
$\mathit{set(match_{\beta})}$ in the theorem above a complete set of
match pairs and an over-approximated set, respectively, we can further
prove that $\mathrm{ANS}(\smt_{\alpha})$ $ = $
$\mathrm{ANS}(\smt_{\beta})$ by giving the following theorem. Note
that a match pair $\langle \mathtt{R},\mathtt{S}\rangle \in
\mathit{set(match_{\beta})}/\mathit{set(match_{\alpha})}$ is called
``bogus", since it cannot exist in a real execution of the program.

\begin{theorem} \label{thm:two}
Any match pair $\langle \mathtt{R}, \mathtt{S}\rangle$ used in a
satisfying assignment of an SMT encoding $\smt$ is a valid match pair
and reflects an actual possible MCAPI program execution.
\end{theorem}

\begin{proof}
Proof by contradiction. Assume that $\langle \mathtt{R},
\mathtt{S}\rangle$ is a ``bogus" match pair that causes
$\mathrm{ANS}(\smt) = \cfgt{SAT}$. Since $\langle \mathtt{R},
\mathtt{S}\rangle$ is not a valid match pair, match $\mathtt{R}$ and
$\mathtt{S}$ requires program order, message non-overtaking, or
no-multiple match to be violated. In other words, the $\mathtt{HB}$
constraints encoded in $\smt$ are not satisfied. Based on the fact
above, the answer of $\smt$ is $\cfgt{UNSAT}$ and it contradicts the
previous hypothesis. Thus, $\langle \mathtt{R}, \mathtt{S}\rangle$ is
a valid match pair in $\smt$ and reflects an actual possible MCAPI
program execution.
\end{proof}

By proving \thmref{thm:two}, we infer that a ``bogus" match pair can
only cause an unsatisfying assignment of an SMT problem. Further, if
$\mathit{set(match_{\alpha})}$ and $\mathit{set(match_{\beta})}$
reflect a complete set and a over-approximated set respectively, the
answers of $\smt_{\alpha}$ and $\smt_{\beta}$ discussed above are
equal since any ``bogus" match pair involved in $\smt_{\beta}$ is only
used in unsatisfying assignments.

