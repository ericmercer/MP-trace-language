\newcommand{\defs}{\ensuremath{\mathrm{defs}}}
\newcommand{\any}{\ensuremath{\mathrm{any}}}
\newcommand{\negate}{\ensuremath{\mathrm{not}}}
\newcommand{\define}{\ensuremath{\mathrm{define}}}
\newcommand{\andd}{\ensuremath{\mathrm{and}}}
\newcommand{\select}{\ensuremath{\mathrm{select}}}
\newcommand{\HB}{\ensuremath{\mathrm{HB}}}
\newcommand{\getlast}{\ensuremath{\mathrm{last}}}
\newcommand{\MATCH}{\ensuremath{\mathrm{MATCH}}}
\newcommand{\ml}{\ensuremath{\mathit{ML}}}
\newcommand{\matchpair}{\ensuremath{\mathrm{MP}}}
\newcommand{\recv}{\ensuremath{\mathrm{\mu}}}
\newcommand{\send}{\ensuremath{\mathrm{\nu}}}



\newsavebox{\boxSMTa}
\begin{lrbox}{\boxSMTa}
\begin{minipage}[c]{0.4\linewidth}
\begin{alltt}
(HB rcvA (wait rcvA))
(HB (wait rcvA) rcvB)
(HB rcvB (wait rcvB))
(HB (wait rcvB) assume)
(HB assume assert)
(HB rcvC (wait rcvC))
(HB (wait rcvC) snd3)
(HB snd3 (wait snd3))
(HB snd1 (wait snd1))
(HB (wait snd1) snd2)
(HB snd2 (wait snd2))

(MATCH rcvA snd1)
(MATCH rcvB snd3)
(MATCH rcvC snd2)

(assume (> b 0))
(assert (not (= a 4)))
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxSMTb}
\begin{lrbox}{\boxSMTb}
\begin{minipage}[c]{0.4\linewidth}
\begin{alltt}
(HB rcvA (wait rcvA))
(HB (wait rcvA) rcvB)
(HB rcvB (wait rcvB))
(HB (wait rcvB) assume)
(HB assume assert)
(HB rcvC (wait rcvC))
(HB (wait rcvC) snd3)
(HB snd3 (wait snd3))
(HB snd1 (wait snd1))
(HB (wait snd1) snd2)
(HB snd2 (wait snd2))

(MATCH rcvA snd3)
(MATCH rcvB snd1)
(MATCH rcvC snd2)

(assume (> b 0))
(assert (not (= a 4)))
\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxSMTc}
\begin{lrbox}{\boxSMTc}
\begin{minipage}[c]{0.4\linewidth}
\begin{alltt}
(HB rcvA (wait rcvA))
(HB (wait rcvA) rcvB)
(HB rcvB (wait rcvB))
(HB (wait rcvB) assume)
(HB assume assert)
(HB rcvC (wait rcvC))
(HB (wait rcvC) snd3)
(HB snd3 (wait snd3))
(HB snd1 (wait snd1))
(HB (wait snd1) snd2)
(HB snd2 (wait snd2))

(or (MATCH rcvA snd1)
    (MATCH rcvA snd3))
(or (MATCH rcvB snd1)
    (MATCH rcvB snd3))
(MATCH rcvC snd2)

(NE rcvA rcvB)

(assume (> b 0))
(assert (not (= a 4)))


\end{alltt}
\end{minipage}
\end{lrbox}


%%---------------------------------------------------------------------------
%%% Start --- SMT Machine reductions
\begin{figure}
\mprset{flushleft}
\scalebox{0.75}{
\begin{mathpar}
\and
%  (--> (h eta aid-map ep-send-calls pending-r
%           (thread_0 ... ([ploc_0 cmd_0] [ploc_1 cmd_1] [ploc_2 cmd_2] ...) thread_2 ...)
%           (ploc_0 trace-entry_1 ...) status smt)
%        (h_pr eta_pr aid-map_pr ep-send-calls_pr pending-r_pr
%              (thread_0 ... ([ploc_1 cmd_1] [ploc_2 cmd_2] ...) thread_2 ...)
%              (trace-entry_1 ...) status_pr smt_prpr)
%        "Machine Step"
%        (where (h_pr eta_pr aid-map_pr ep-send-calls_pr pending-r_pr
%                     e status_pr ret smt_pr)
%               ,(apply-reduction-relation** expr-reductions
%                                            (term (h eta aid-map ep-send-calls
%                                                     pending-r
%                                                     cmd_0 status ret smt))))
%        (where smt_prpr (add-po smt_pr ploc_0 ploc_1)))
\inferrule[Machine Step]{
  (\epsnd~\qset~\movebot~\status)~\reduceK{q}~
  (\epsnd_\mathit{p0}~\qset_\mathit{p0}~\movebot_p~\status_\mathit{p0}) \\\\
  (h~\eta~\aidmap~\epsnd_\mathit{p0}~\eprcv~\qset_\mathit{p0}~\cmd_0~\status_\mathit{p0}~\ret~\last~\smt)~\reduceK{e}~
  (h_p~\eta_p~\aidmap_p~\epsnd_\mathit{p1}~\eprcv_p~\qset_\mathit{p1}~e~\status_\mathit{p1}~\ret~\last_p~\smt_\mathit{p0}) \\
  \smt_\mathit{p1} =  \mathrm{addHB}(\smt_\mathit{p0}~\ploc_0~\ploc_1)
}{
  (h~\eta~\aidmap~\epsnd~\eprcv~\qset~
           (\thread_0~\ldots~
            ([\ploc_0~\cmd_0]~[\ploc_1~\cmd_1]~[\ploc_2~\cmd_2]~\ldots)~\thread_2~\ldots)~
           ([\ploc_0~\movebot]~\traceentry_1~\ldots)~\status~\last~\smt) \reduce{m} \\\\
  (h_p~\eta_p~\aidmap_p~\epsnd_\mathit{p1}~\eprcv_p~\qset_\mathit{p1}~
              (\thread_0~\ldots~([\ploc_1~\cmd_1]~[\ploc_2~\cmd_2]~\dots)~\thread_2~\dots)~
              (\traceentry_1~\dots)~\status_\mathit{p1}~\last_p~\smt_\mathit{p1})
}
\end{mathpar}}
\caption{Machine Reductions to build the SMT model of a trace language program ($\reduce{\mathrm{m-smt}}$)}
\label{fig:machine_smt}
\end{figure}


\begin{figure}
\scalebox{0.75}{%
\mprset{flushleft}
\begin{mathpar}
%   (--> (h eta aid-map pending-s pending-r  (assume e) status k
%           (defs (any ...)))
%        (h eta aid-map pending-s pending-r  e status (assume * -> k )
%           (defs (e any ...)))
%        "Assume Pull Out Expr")
\inferrule[Assume Expressions Evaluation]{}{
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ (\assume\ e)\ \status\ k\ \last\ (\defs\ (\any\ \ldots))) \reduce{e}
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ e\ \status\ (\assume\ * \rightarrow k)\ \last\ (\defs\ (e\ \any\ \ldots)))
}
\and
%   ;;Negate expression and add it to the SMT assertions.
%   (--> (h eta aid-map pending-s pending-r  (assert e) status k
%           (defs (any ...)))
%        (h eta aid-map pending-s pending-r  e status (assert * -> k)
%           (defs ((not e) any ...)))
%        "Assert Pull Out Expr")
\inferrule[Assert Expressions Evaluation]{}{
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ (\assert\ e)\ \status\ k\ \last\ (\defs\ (\any\ \ldots))) \reduce{e}
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ e\ \status\ (\assert\ * \rightarrow k)\ \last\ (\defs\ ((\negate\ e)\ \any\ \ldots)))
}
\and
%   (--> (h eta aid-map pending-s pending-r  (x := e) status k
%           (defs (any ...)))
%        (h eta aid-map pending-s pending-r  e status (x := * -> k)
%           (defs ((= x e) any ...)))
%        "Assign Pull Out Expr")
\inferrule[Assign Expressions Evaluation]{}{
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ (x\ :=\ e)\ \status\ k\ \last\ (\defs\ (\any\ \ldots))) \reduce{e}
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ e\ \status\ (x\ :=\ * \rightarrow k)\ \last\ (\defs\ ((=\ x\ e)\ \any\ \ldots)))
}
\and
%   ;;Adds sendi cmd to aid-map and pending-s. - VALIDATED
%   (--> (h eta ([aid_x ep_x] ...) pending-s pending-r q-set
%           (sendi aid src dst x ploc number) status k ((any_d ...) (any_a ...)))
%        (h eta ([aid src] [aid_x ep_x] ...) pending-s_pr pending-r q-set
%           true status k ((any_0 any_d ...) (any_1 any_a ...)))
%        "Sendi Cmd x -> v"
%        (where v (h-lookup h (eta-lookup eta x)))
%        (where any_0 (define aid :: send))
%        (where any_1 (make-send aid src dst x ploc number))
%        (where pending-s_pr (add-send pending-s [aid -> src dst v])))
\inferrule[Sndi Command]{
  ([\aid_1\ v_1]\ \ldots) = \epsnd(\dst)(\src) \\ \epsnd_p = [\epsnd \mid \dst \mapsto [\epsnd(\dst) \mid \src \mapsto ([\aid_0\ h(\eta(x))]\ [\aid_1\ v_1]\ \ldots)]] \\
  \any_0 = (\define\ \aid\ ::\ send) \\ \any_1 = (\andd\ (=\ (\select\ \aid\ ep)\ \dst)\ (=\ (\select\ \aid\ value)\ x))
}{
  (h\ \eta\ ([\aid\ \ep]\ \ldots)\ \epsnd\ \eprcv\ \qset\
     (\sendi\ \aid_0\ \src\ \dst\ x)\ \status\ k\ \last\ ((\any_d\ \ldots)\ (\any_a\ \ldots))) \reduce{e} \\
  (h\ \eta\ ([\aid_0\ \src]\ [\aid\ \ep]\ \ldots)\ \epsnd_p\ \eprcv\ \qset\ \true\ \status\ k\ \last\ ((\any_0\ \any_d\ \ldots)\ (\any_1\ \any_a\ \ldots)))
}
\and
%   ;;Adds recvi cmd to aid-map and pending-r. - VALIDATED
%   (--> (h eta ([aid_x ep_x] ...) pending-s pending-r q-set
%           (recvi aid dst x ploc) status k ((any_d ...) (any_a ...)))
%        (h eta ([aid dst] [aid_x ep_x] ...) pending-s pending-r_pr q-set
%           true status k ((any_0 any_d ...) (any_1 any_a ...)))
%        "Recvi Cmd0"
%        (where pending-r_pr (add-recv pending-r [aid -> dst x]))
%        (where any_0 (define aid :: recv))
%        (where any_1 (make-recv aid dst x ploc)))
\inferrule[Rcvi Command]{
  ([\aid_1\ x_1]\ \ldots) = \eprcv(\dst) \\
   \eprcv_p = [\eprcv \mid \dst \mapsto ([\aid_0\ x_0]\ [\aid_1\ x_1]\ \ldots)] \\
   \any_0 = (\define\ \aid\ ::\ recv) \\ \any_1 = (\andd\ (=\ (\select\ \aid\ ep)\ \dst)\ (=\ (\select\ \aid\ var)\ x_0))
}{
  (h\ \eta\ ([\aid\ \ep]\ \ldots)\ \epsnd\ \eprcv\ \qset\ (\recvi\ \aid_0\ \dst\ x_0)\ \status\ k\ \last\ ((\any_d\ \ldots)\ (\any_a\ \ldots))) \reduce{e} \\
  (h\ \eta\ ([\aid_0\ \dst]\ [\aid\ \ep]\ \ldots)\ \epsnd\ \eprcv_p\ \qset\ \true\ \status\ k\ \last\ ((\any_0\ \any_d\ \ldots)\ (\any_1\ \any_a\ \ldots)))
}
\and
   %(--> (h eta aid-map pending-s pending-r q-set (wait aid_r)
%           status k (defs (any_a ...)))
%        (h_pr eta aid-map_pr pending-s pending-r_pr q-set_pr true
%              status_pr k
%              (defs ((HB (select aid-กอ_s-last match_po) (select aid_s match_po))
%                    (MATCH aid_r0 aid_s0) any_a ...)))
%        "Recvi Wait Cmd"
%            ;; get recv and corresponding send command, mark each send in front of the destination send (by set variable "mark" to 1)
%        (where true (find-recv pending-r aid_r) )
%        (where (aid-map_0 dst_r) (get-ep aid-map aid_r))
%        (where (h_pr aid_s pending-r_pr q-set_pr status_pr)
%               (get-mark-remove h eta pending-r q-set dst_r aid_r status))
%        (where (aid-map_pr src_s) (get-ep aid-map_0 aid_s))
%        )
%   ))
\inferrule[Wait (rcvi) Command]{
    ([\aid_0\ \ep_0]\ \ldots\ [\aid_r\ \dst][\aid_1\ \ep_1]) = \aidmap\\
    \aidmap_0 = ([\aid_0\ \ep_0]\ \ldots\ [\aid_1\ \ep_1])\\
    (h_p\ \aid_s\ \eprcv_p\ \qset_p\ \status_p) = \getmarkremove(h, \eta, \eprcv, \qset, \dst, \aid_r, \status) \\
    ([\aid_0\ \ep_0]\ \ldots\ [\aid_s\ \src][\aid_1\ \ep_1]) = \aidmap_0\\
    \aidmap_p = ([\aid_0\ \ep_0]\ \ldots\ [\aid_1\ \ep_1])\\
    (\last_p\ last\_\aid_s) = \getlastsendreplace(\last, \aid_s, \src, \dst)
}{
    (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ \qset\ (\wait\ \aid_r)\ \status\ k\ \last\ (\defs\ (\any_a\ \ldots))) \reduce{e} \\
    (h_p\ \eta \aidmap_p\ \epsnd\ \eprcv_p\ \qset_p\ true\ \status_p\ k\ \last_p\ (\defs\ ((\HB\ (\select\ last\_\aid_s)\ \mathit{MP})\ (\select\ \aid_s\ \mathit{MP}))\
                    (\MATCH\ \aid_r\ \aid_s)\ \any_a\ \ldots)))
}
\end{mathpar}}
\caption{Expression Reductions to build the SMT model of a trace language program ($\reduce{\mathrm{e-smt}}$)}
\label{fig:expression_smt}
\end{figure}
%%% END --- SMT Machine reductions
%%---------------------------------------------------------------------------

\section{SMT Model}\label{sec:smt}

The next step, after formally defining the operational semantics of our trace
language, is to formally define a translation from the trace language into an
SMT problem that can correctly model the original execution trace.

An SMT problem that encodes a trace through CTP needs various data structure and support functions. We have intuitively introduced most of them in the example of Section 2. Before presenting the translation framework from trace language to the SMT problem, we need to explain them in detail. We give the definitions in the Yices input language.

% (define HB::(-> a::int b::int (subtype (c::bool) (ite (< a b) (= c true) (= c false)))))
\begin{equation}
\begin{array}{l}
(\cfgt{define}\ \mathrm{HB}::(->\ \cfgnt{a::int}\ \cfgnt{b::int}\\
\ \ \ (\cfgt{subtype}\ \cfgnt{(c::bool)}\ (\mathrm{ite}\ (<\ \mathit{a}\ \mathit{b})\ (=\ \mathit{c}\ \mathrm{true})\ (=\ \mathit{c}\ \mathrm{false})))))
\end{array}
\label{equation:hb}
\end{equation}

%\begin{equation}
%\mathrm{HB}(a,b) \equiv \left\{ \begin{array}{rl}
%  \mathit{true} & \mathrm{if}\ a < b \\
%  \mathit{false} & \mathrm{otherwise}\
%\end{array}
%\right .
%\end{equation}

The HB function in equation (\ref{equation:hb}) represents a happens-before relationship between two events. It
takes two events $a$ and $b$ as parameters, such that $a,b \in \mathbb{N}$. In the SMT encoding, every location is assigned an event, and HB orders those locations (i.e., program order, etc.). This
function creates a constraint such that the first event must be less than the
second event, indicating that the first event occurs before the second event.
This function is used to assert the program order of statements within the same
thread, and also to assert that, for any matched pair, that the send operation
occurs before the receive.

\begin{equation}
\begin{array}{l}
%(define-type recv (record match::int ep::int var::int event::int))
(\cfgt{define-type}\ R\ (\cfgt{record}\ \cfgnt{M::int}\ \cfgnt{ep::int}\ \cfgnt{var::int}\ \cfgnt{event::int})) \\
%(define-type send (record match_po::int id::int ep::int value::int event::int))
(\cfgt{define-type}\ S\ (\cfgt{record}\ \cfgnt{MP::int}\ \cfgnt{ID::int}\ \cfgnt{ep::int}\ \cfgnt{value::int}\ \cfgnt{event::int}))
\end{array}
\label{equation:record}
\end{equation}
%\[R = (M\ \ep_r\ x\ \ploc_r)\]
%\[S = (\mathit{MP}\ \mathit{ID}\ \ep_s\ e\ \ploc_s)\]

We define two records in equation (\ref{equation:record}) that are essential to encoding the SMT problem. The first tuple $\cfgnt{R}$ defined above represents a receive action such that $\mathit{M}$, $\mathit{ep}$, $\mathit{var}$, $\mathit{event} \in \mathbb{N}$. $\mathit{M}$ represents a free variable that matches $R$ with a tuple $S$. $\mathit{ep}$ is the end point of the receive operation, $\mathit{var}$ represents a variable which is assigned a value received by the receive operation, and $\mathit{event}$ is the event term which indicates the program order. The second tuple $S$ defined above is a send action such that $\mathit{MP}$, $\mathit{ID}$, $\mathit{ep}$, $\mathit{value}$, $\mathit{event} \in \mathbb{N}$. $\mathit{ep}$ and $\mathit{event}$, as those in $\cfgnt{R}$, are the end point of the send operation and event term, respectively. $\mathit{value}$ is the value for sending. $\mathit{MP}$ is another free variable for match pair and it is assigned an end point of a receive operation if such receive operation matches the send operation. $\mathit{ID}$ is a unique number that identifies each send operation. Note that integer value assigned to $\mathit{event}$ indicates the program order. For example, action $a$ happens before $b$ if and only if $\mathit{event}_a$ for $a$ is greater than $\mathit{event}_b$ for $b$. Also, we keep record of two match variables, $M$ and $\mathit{MP}$, for different purposes. $M$ is used for avoiding two receive operations matched with the same send operation, which is defined in function $\mathrm{NE}$. $\mathit{MP}$ is used for ordering two receive operations with respect to the program order of two matched send operations.

%(define MATCH::(-> r::recv s::send (subtype (c::bool) (ite
 % (and (= (select r ep) (select s ep))
 %      (= (select r var) (select s value))
  %     (HB (select s event) (select r event))
   %    (= (select r match) (select s id))
%       (= (select s match_po) (select r event)))%
% (= c true)
% (= c false)))))

\begin{equation}
\begin{array}{l}
(\cfgt{define}\ \mathrm{MATCH}::(->\ \cfgnt{r::R}\ \cfgnt{s::S}\ (\cfgt{subtype}\ \cfgnt{(c::bool)}\ (\cfgnt{ite} \\
\ \ \ (\mathrm{and}\ (=\ (\mathrm{select}\ \mathit{r}\ \mathit{ep})\ (\mathrm{select}\ \mathit{s}\ \mathit{ep})) \\
\ \ \ \ \     (=\ (\mathrm{select}\ \mathit{r}\ \mathit{var})\ (\mathrm{select}\ \mathit{s}\ \mathit{value})) \\
\ \ \ \ \    (\mathrm{HB}\ (\mathrm{select}\ \mathit{s}\ \mathit{event})\ (\mathrm{select}\ \mathit{r}\ \mathit{event})) \\
\ \ \ \ \    (=\ (\mathrm{select}\ \mathit{r}\ \mathit{M})\ (\mathrm{select}\ \mathit{s}\ \mathit{ID})) \\
\ \ \ \ \    (=\ (\mathrm{select}\ \mathit{s}\ \mathit{MP})\ (\mathrm{select}\ \mathit{r}\ \mathit{event}))) \\
\ \ \  (=\ \mathit{c}\ \mathrm{true}) \\
\ \ \  (=\ \mathit{c}\ \mathrm{false})))))
\end{array}
\label{equation:match}
\end{equation}


%\begin{equation}
%\mathrm{MATCH}(R,S) \equiv \left\{
%\begin{array}{ll}
%  \mathit{true} & \mathrm{if}\ M = \mathit{ID}~\wedge \\
%  & \ep_r = \ep_s~\wedge \\
%  & x = e~\wedge \\
%  & \mathrm{HB}(\ploc_s,\ploc_r)~\wedge \\
%  & \mathit{MP}_r = \ep_r \\
%  \mathit{false} & \mathrm{otherwise}\
%\end{array}
%\right . \\
%\end{equation}

The $\mathrm{MATCH}$ function in equation (\ref{equation:match}) takes tuple $R$ and $S$ as parameters. It creates a number of constraints that represent the pairing
of the specified send and receive operations. This function asserts that the
destination end-point of the send operation is the same as the end-point used by
the receive operation, that the value sent by the send operation is the same
value received by the receive operation, that the send operation occurs before
the receive operation, that the ``match'' value in the receive tuple is
equal to the ``ID'' value in the send tuple, and that the ``MP" value in the send tuple is equal to the ``event" value in the receive tuple.

%(define ne::(-> r1::recv r2::recv (subtype (res::bool) (ite
%  (= (select r1 match) (select r2 match))
%  (= res false)
%  (= res true)))))

\begin{equation}
\begin{array}{l}
(\cfgt{define}\ \mathrm{NE}::(->\ \cfgnt{r1::R}\ \cfgnt{r2::R}\ (\cfgt{subtype}\ \cfgnt{(res::bool)}\ (\cfgnt{ite} \\
\ \ (=\ (\mathrm{select}\ \mathit{r1}\ \mathit{M})\ (\mathrm{select}\ \mathit{r2}\ \mathit{M})) \\
\ \ (=\ \mathit{res}\ \mathrm{false}) \\
\ \ (=\ \mathit{res}\ \mathrm{true})))))
\end{array}
\label{equation:ne}
\end{equation}

%\begin{equation}
%\mathrm{ne}(a,b) \equiv \left\{ \begin{array}{rl}
%  \mathit{true} & \mathrm{if}\ M_a \not = M_b \\
%  \mathit{false} & \mathrm{otherwise}\
%\end{array}
%\right .
%\end{equation}

The $\mathrm{NE}$ function in equation (\ref{equation:ne}) is used to assert that no two receive operations are matched
with the same send operation. The parameters for this function are two receive
tuples. An assertion is made that the values of their ``match'' fields, $M$,
are not equal. This shows that they are paired with two different send
operations.

We modify our system on the same framework of the trace language that produces a correlating SMT problem for a given execution trace.

The evaluation syntax for the machine reductions to build the SMT
model of a trace language program are largely those of the regular machine
reductions with a few changes below
\[
\cfgstart
\cfgrule{mstate}{\lp\cfgnt{h}\ \cfgnt{\ensuremath{\eta}}\ \cfgnt{\aidmap}\
  \cfgnt{\epsnd}\ \cfgnt{\eprcv}\ \cfgnt{\qset}\ \cfgnt{ctp}\ \cfgnt{\trace}\ \cfgnt{\status}\ \cfgnt{k}\ \cfgnt{\last}\ \smt\rp}
%  (expr-state (h eta aid-map pending-s pending-r e status k smt))
\cfgrule{estate}{\lp\cfgnt{h}\ \cfgnt{\ensuremath{\eta}}\ \cfgnt{\aidmap}\
  \cfgnt{\epsnd}\ \cfgnt{\eprcv}\ \cfgnt{\qset}\ \cfgnt{e}\ \cfgnt{\status}\ \cfgnt{k}\ \cfgnt{\last}\ \smt\rp}
%  (smt (defs asrts))
\cfgrule{\smt}{\lp\cfgnt{defs}~\cfgnt{constraints}\rp}
%  (defs (any ...))
\cfgrule{defs}{\lp\cfgnt{any}~$\ldots$\rp}
%  (constraints (any ...))
\cfgrule{constraints}{\lp\cfgnt{any}~$\ldots$\rp}
\cfgend
\]
The new syntax adds the \textit{smt} member to the \textit{mstate}
and \textit{estate} where the ``\cfgnt{any}'' term in \textit{defs}
and \textit{constraints} matches any structure.  The lists will
be filled with definitions, HB entries, MATCH entries, NE
entries, etc. as defined by the SMT machine reductions. \last, which records the last send operation happens before the current one in the same thread, is another member added to the \textit{mstate} and \textit{estate}. The \textit{qstate} does not contain any SMT encodings in the reductions and it is not changed.

The changes for the reduction rules are presented in \figref{fig:machine_smt} and \figref{fig:expression_smt}. The support function $\mathrm{addHB}(((\mathit{any}_d ...)\ (\mathit{any}_c ...))\ \ploc_0\ \ploc_1)$ adds program location to the definition list and adds a happens before relation
\[
 \equiv \\
   (((\mathtt{define\ \ploc_0 :: int})\ \mathit{any}_d ...)((\mathtt{HB\ \ploc_0\ \ploc_1})\ \mathit{any}_c ...))
\]

The reduction rules in \figref{fig:machine_smt} and \figref{fig:expression_smt} add constrains to the SMT problem with respect to the semantic definition of trace language. The $\mathrm{Machine\ Step}$ in \figref{fig:machine_smt} adds the program order of actions in the same thread to the SMT problem. The evaluation of assume, assert and assign in \figref{fig:expression_smt} adds assertions to the SMT problem. The $Sndi$ and $Rcvi$ commands define the send and receive actions in the SMT problem, and the $Wait (Rcvi)$ reduction adds the ''match" constrains to the SMT problem. Note that the function $\getlastsendreplace$ picks up the last send operation, $\mathit{last}\_\aid_s$, that happens before the current one in the same thread, and adds a HB relation between the $\mathit{MP}$ of $\mathit{last}\_\aid_s$ and that of the current send operation. The added relation ensures the matched receive operations of two send operations are also program ordered properly.

\begin{figure}
\begin{center}
\setlength{\tabcolsep}{7pt}
\begin{tabular}[c]{ccc}
\scalebox{0.68}{\usebox{\boxSMTa}} &
\scalebox{0.68}{\usebox{\boxSMTb}} &
\scalebox{0.68}{\usebox{\boxSMTc}} \\
(a) & (b) & (c)
\end{tabular}
\end{center}

\caption{SMT problems. (a) SMT problem based on the first trace. (b) SMT
problem based on a second trace. (c) SMT problem built from the preceding two
problems.}

\label{fig:smts}
\end{figure}

\figref{fig:smts} contains three SMT problems for the same CTP in the bottom of \figref{fig:mcapi}. \figref{fig:smts}(a) uses several functions defined above to encode a single trace through the CTP. Especially, the $\mathrm{assume}$ statement is created by
asserting any branch conditions that we encountered in the trace. As was stated
earlier, this prevents the SMT solver from finding any solutions that are not
consistent with the program's control flow. The $\mathrm{assert}$ statement is
created by negating any assertions that were made in the original program. This
creates an SMT problem that will only be satisfiable if an assertion violation
can be found.

So far, we have achieved two different methods that can both verify the execution of a single trace. Furthermore, the following lemma indicates the equivalence between the trace language and the SMT encoding. Before presenting the lemma, we have the following definition.
\begin{definition}
A machine state $(h\ \eta\ \aidmap\ \epsnd\ \eprcv\ \cfgnt{ctp}\ \trace\ \status\ k)$ is smt-enabled if it is well formed.  The SMT problem is taken from the final SMT reduced state:
\[\begin{array}{l}
        (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ \cfgnt{ctp}\ \trace\ \status\ k\ (()()))  \reduceK{\mathrm{m-smt}} \\
 (h_p\ \eta_p\ \aidmap_p\ \epsnd_p\ \eprcv_p\ \cfgnt{ctp}_p\ \trace_p\ \status_p\ k_p\ \mathrm{smt})
 \end{array}\]
For convenience, we define the function
$\mathrm{getSMT}(m) \mapsto\ \mathrm{smt}$ to return the SMT problem in the final state, and $\mathrm{ANS}(\mathrm{getSMT}(m)) \mapsto \{\mathrm{\cfgt{SAT}},\mathrm{\cfgt{UNSAT}}\}$ to return the status of the SMT problem in the final state of $m$. Also, we define the relation of the range of function $\mathrm{ANS}$ such that $\mathrm{\cfgt{UNSAT}} > \mathrm{\cfgt{SAT}}$.
\end{definition}

\begin{lemma}
For a well-formed machine state $m$,
\[
\mathrm{status}(m) = \cfgt{failure} \iff \mathrm{ANS}(\mathrm{getSMT}(m)) = \mathrm{\cfgt{SAT}}
\]
\label{lemma:1}
\end{lemma}
\begin{proof}
%To prove the statement, we focus on each reduction rule that adds clauses to the SMT problem. Since the only reduction rule that causes the status of state $\cfgt{failure}$ is
%Assert Expression Evaluation in \figref{fig:expression_smt}, we need to prove that an $\cfgt{assert}$ expression causes the machine state $\cfgt{failure}$ if and only if the added clause in SMT problem is satisfiable. Suppose expression $\emph{e}$ in the assert reduction rule in \figref{fig:machine_smt} is evaluated false, which causes the status of state $\cfgt{failure}$, It is obvious that the new clause, $(not\ \emph{e})$, is evaluated true by any SMT solver. For the other direction, since $(not\ \emph{e})$ is true, the evaluation of $\emph{e}$ is false so that the status of state is evaluated $\cfgt{failure}$.
%For other reduction rules in \figref{fig:machine_smt} and \figref{fig:expression_smt}, we need to prove the contraposition, such that the SMT problem returns $\mathrm{\cfgt{UNSAT}}$ if and only if the status of state is either $\cfgt{success}$ or $\cfgt{infeasible}$ ($\cfgt{error}$ is not considered since it can only reduced by non-well-formed machine state). Suppose the status of final state is $\cfgt{success}$, such that each reduction rule is reduced without changing the status. Note that the $\mathrm{HB}$ relations are correctly defined in the machine reduction, assertions for assume and assign commands are evaluated true, the send and receive operations are correctly defined and the match pairs are valid in the SMT problem since the trace is executed successfully in the trace language semantics. The assertion for the assert command, however, is negated in the SMT problem so that makes it $\mathrm{\cfgt{UNSAT}}$. Also, suppose the status of state is $\cfgt{infeasible}$, such that the evaluation of expression $\emph{e}$ in assume command is false. Since the clause $e$ is also added to the SMT problem and it is evaluated false, the whole SMT problem is evaluated $\mathrm{\cfgt{UNSAT}}$ eventually. For the other direction, suppose the generated SMT problem is $\mathrm{\cfgt{UNSAT}}$, we need to prove the non-existence of $\cfgt{failure}$ for the state status. Since the SMT problem is found $\mathrm{\cfgt{UNSAT}}$, there should be at least one clause that is not satisfiable. If the unsatisfiable clause is generated from the assert command, such that $(not\ e)$ is evaluated false. It implies that $e$ is evaluated true. Thus, the assert command can not make the status of state $\cfgt{failure}$. If the unsatisfiable clause is generated from other reduction rules, the status of state could only be $\cfgt{success}$ or $\cfgt{infeasible}$ by definition.
%Thus, this is the end of proof.

Suppose the status of the final machine state is $\cfgt{failure}$. From the reduction rules, we know that there exists at least one assert action that is evaluated false. In \figref{fig:expression_smt}, we know that expression ``$e$" is negated and added to the SMT encoding for the second reduction rule. By hypothesis, $e$ is evaluated false, so clause $(not\ e)$ is evaluated satisfiable in the generated SMT problem. Since the SMT problem generated by applying the reduction rules only remains a set of free variables for program ordering unresolved (other free variables are assigned to some value after creating the problem), the SMT problem exactly captures the execution trace described in the final state. Thus, the SMT problem is evaluated $\cfgt{SAT}$.
On the other hand, suppose the SMT problem is evaluated $\cfgt{SAT}$, indicating that all statements of the SMT problem are satisfiable. Since the reduction rules in \figref{fig:expression_smt} add statements with respect to the transition of the trace, it implies that each transition of the trace is executed correctly except for some assert action. Because of the same reason above, we know that expression $e$ for the assert action is evaluated false. Thus, the status of the final machine state is $\cfgt{failure}$.
\end{proof}


As we have discussed in the early section, the CTP can have other traces in execution. \figref{fig:smts}(b) represents a SMT problem that encodes another trace. The structure of the second SMT problem is similar to the first one. The only difference is the predefined set of match pair. Because of that, we combine two SMT problems into one, which is presented in \figref{fig:smts}(c). To formally define the ''combination" of multiple single SMT problems, we have the following definitions.

\begin{definition}
A match-list \ml\ is a set of match pair lists uniquely identified by a receive action ID, and each list consists of a set of match pairs for this receive action ID and a send action ID:
\[\ml\ =\ \emptyset\ |\ (\ml\ [\recv\ \rightarrow [(\recv\ \send)\ldots]])\]
Note that we alpha renamed so that \recv\ and \send\ are all unique labels. For convenience, we define function $\mathit{dom(\ml)}$ and $\mathit{range{\ml}}$ that returns the set of receive action IDs in the set of match pairs of \ml and the set itself, respectively.
\label{def:match-list}
\end{definition}

We extend the structure \ml\ to the structure \smt\ such that
\[\smt=(\mathit{defs}\ \mathit{constrains}\ \ml)\]
where the match constraints are separated from $\mathit{constraints}$. In addition, two SMT problems are assumed to hold the same $\mathit{defs}$ and $\mathit{constrains}$ excluding the match constraints if and only if they can be combined by applying a combination operator in \defref{def:combinator}.

\begin{definition}
A combination operator $\mathit{COMB}$ for two SMT problems, represented as three-tuples $\smt_1$ and $\smt_2$, where $\smt_1 = (\mathit{defs}\ \mathit{constrains}\ \ml_1)$ and $\smt_2 = (\mathit{defs}\ \mathit{constrains}\ \ml_2)$, returns a new SMT tuple, such that,
\[\mathit{COMB}(smt_1,smt_2)\ =\ (\mathit{defs}\ \mathit{constraints}\ \ml_{new})\]
where $\ml_{new}$ is a new relation such that $\forall\recv\in dom(\ml_1)\cup dom(\ml_2)$, $\ml_{new}(\recv) = \ml_1(\recv)\cdot\ml_2(\recv)$.
\label{def:combinator}
\end{definition}

To further finding the correlation between the combined SMT problem and the single SMT problems, we get the following lemma and proof.

\begin{lemma}
For a set of traces $\mathrm{T_n}$ for the same CTP, and a set of SMT problems $\mathrm{SMT_n} = \{\smt_0,\smt_{1},\ldots,\smt_{n}\}$, where each member in $\mathrm{SMT_n}$ encodes a trace in $\mathrm{T_n}$, there exists a new SMT problem $\smt_{total}$, where
\[\smt_{total} = \mathit{COMB}(\smt_n, \mathit{COMB}(\smt_{n-1}, \mathit{COMB}(\smt_{n-2}, \mathit{COMB}(\ldots ))))\]
and
\[
\mathrm{ANS}(\smt_{total}) = \left\{ \begin{array}{rl}
  \mathit{\cfgt{SAT}} &\ \mathrm{iff}\ \exists \smt_i \in \mathrm{SMT_n},\ s.t.\ \mathrm{ANS}(\smt_i) = \mathit{\cfgt{SAT}}  \\
  \mathit{\cfgt{UNSAT}} &\ \mathrm{otherwise}\
\end{array}
\right .
\]
\end{lemma}
\begin{proof}
We Prove it by induction.

We consider the base case as a SMT problem that encodes a single trace and the answer can be trivially proved by definition.

Induction. Assume we have combined n SMT problems and the combined SMT problem $\smt_{total}$ is evaluated $\mathit{\cfgt{UNSAT}}$. We combine an additional SMT problem $\smt_{n+1}$, which is different from any existent SMT problems. If $\mathrm{ANS}(\smt_{n+1})$ is equal to $\mathit{\cfgt{SAT}}$, the newly combined SMT problem, $\smt_{total}'$, is evaluated $\mathit{\cfgt{SAT}}$ because the match pairs defined in $\smt_{n+1}$ are combined into $\smt_{total}'$. If $\mathrm{ANS}(\smt_{n+1})$ is equal to $\mathit{\cfgt{UNSAT}}$, on the other hand, $\smt_{total}'$ is then evaluated $\mathit{\cfgt{UNSAT}}$ because all the traces implied in $\smt_{total}'$ are evaluated $\mathit{\cfgt{UNSAT}}$. Additionally, it can be trivially proved if $\smt_{total}$ is evaluated $\mathit{\cfgt{SAT}}$ then the newly added SMT problem $\smt_{n+1}$ do not change the answer.
\end{proof}

From \textbf{Lemma 2}, the combined SMT problem is more powerful because it can find the violation of an assertion among several trace encodings. Moreover, because the function $\mathit{COMB}$ only adds match pairs in $\ml$, we can conclude that it is all about match pairs that strength the verification process. The following theorem states this conclusion.

\begin{theorem}
For two SMT problems, $\smt_{\phi} = (\mathit{defs}\ \mathit{constrains}\ \ml_{\phi})$ and $\smt = (\mathit{defs}\ \mathit{constrains}\ \ml)$,
if $\mathit{range(\ml_{\phi})} \subseteq \mathit{range(\ml)}$,
\[\mathrm{ANS}(\smt_{\phi}) \geq \mathrm{ANS}(\smt)\]
\end{theorem}
\begin{proof}
Since the range of $\ml_{\phi}$ is the sub set of the range of $\ml$, we can obtain $\smt$ by combining $\smt_{\phi}$ with other SMT problems. Suppose $\mathrm{ANS}(\smt_{\phi})$ is equal to $\mathit{\cfgt{SAT}}$, by \textbf{Lemma 2}, $\mathrm{ANS}(\smt)$ is equal to $\mathit{\cfgt{SAT}}$ as well. If $\mathrm{ANS}(\smt_{\phi})$ is equal to $\mathit{\cfgt{UNSAT}}$, $\mathrm{ANS}(\smt)$ is equal to either $\mathit{\cfgt{UNSAT}}$ or $\mathit{\cfgt{SAT}}$, depending on the answers of other single SMT problems that combine $\smt$. In either case, $\mathrm{ANS}(\smt_{\phi}) \geq \mathrm{ANS}(\smt)$.
\end{proof}

%\subsection{Outline}

%SMT model is created from an extension to the operational semantics of the
%trace language.  The semantics generate an SMT for a single trace.  The key
%observation is that the SMT does not change for different traces on the same
%CTP except for the specified match pairs.  This observation leads to the main
%result that we can over-approximate the match pair sets and use the
%trance-language in a refinement loop.

%Add a figure showing the encoding of two traces for the example system.   Put the two traces next to each other.  Use the ones from LaDefense.pptx
%\begin{itemize}
%\item Define upfront MATCH, HB, and the data structure definitions (anything boiler plate)
%\item Focusing on one trace, give the new reductions for assert and assume referencing directly the line number in the trace where these statements appear.
%\item Give the new reductions for WAITI-rcv to define a match pair.  Again reference the line number in the figure for clarity.
%\item Add the full semantics to the appendix and give the reference here.
%\item Lemma 1: we can encode a single trace.
%\item Examine the second trace.  Note the only difference is seen in the MATCH pairs.
%\item Define the combinator operation that combines two SMT encodings for a common CTP
%\item Lemma 2: we can encode multiple traces into a single SMT problem.  Proof by induction.  Base case is a single trace.  Trivially established by Lemma 1.  Induction is assume you have correctly encoded n-traces, and you are adding a new trace (i.e., a new set of match pairs) to the encoding using your combinator operation.
%\item Suppose we an answer function that given a MP set and a CTP returns either success or failure with a trace.
%\item Define the main theorem for the paper (slide 68 in LaDefense.pptx).  Generalize to arbitrary sets.  Proof by induction.  Base case is a single trace in $\mathrm{mp}_1$ so $\mathrm{mp}_1 \subseteq \mathrm{mp}_1$.  Proof is trivial since $\mathrm{answer}(\mathrm{mp}_1)$ does not change.  Inductive step is $mathrm{mp}_n \subseteq \mathrm{mp}_n+1$.   Assume $\mathrm{mp}_n$ give the correct answer.  Argue on the lattice and the operational semantics for each rule that touches the status.  You have to reference in the proof every rule that updates the status!
%\end{itemize}



