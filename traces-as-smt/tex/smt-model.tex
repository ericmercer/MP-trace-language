\newcommand{\epsnd}{\textit{Pnd\_s}}
\newcommand{\eprcv}{\textit{Pnd\_r}}
\newcommand{\qset}{\textit{Q\_s}}
\newcommand{\snd}{\textit{snd}}
\newcommand{\rcv}{\textit{rcv}}
\newcommand{\q}{\textit{q}}
\newcommand{\frm}{\textit{frm}}
\newcommand{\vbot}{\textit{v$-\bot$}}
\newcommand{\status}{\textit{s}}
\newcommand{\last}{\textit{l}}
\newcommand{\error}{\ensuremath{\mathbf{error}}}
\newcommand{\aidmap}{\textit{A}}
\newcommand{\thread}{\ensuremath{\mathit{t}}}
\newcommand{\aid}{\ensuremath{\mathit{a}}}
\newcommand{\ploc}{\ensuremath{\rho}}
\newcommand{\loc}{\ensuremath{\mathit{l}}}
\newcommand{\cmd}{\ensuremath{\mathit{c}}}
\newcommand{\op}{\ensuremath{\mathit{op}}}
\newcommand{\applyop}{\ensuremath{\mathrm{op}}}
\newcommand{\wait}{\ensuremath{\mathbf{wait}}}
\newcommand{\sendi}{\ensuremath{\mathbf{sndi}}}
\newcommand{\recvi}{\ensuremath{\mathbf{rcvi}}}
\newcommand{\traceentry}{\ensuremath{\sigma}}
\newcommand{\movelist}{\ensuremath{\delta}}
\newcommand{\assume}{\ensuremath{\mathit{assume}}}
\newcommand{\checkassume}{\ensuremath{\mathrm{assume}}}
\newcommand{\assert}{\ensuremath{\mathit{assert}}}
\newcommand{\checkassert}{\ensuremath{\mathrm{assert}}}
\newcommand{\ep}{\ensuremath{\mathbf{\gamma}}}
\newcommand{\src}{\ensuremath{\alpha}}
\newcommand{\dst}{\ensuremath{\beta}}
\newcommand{\true}{\ensuremath{\mathbf{true}}}
\newcommand{\false}{\ensuremath{\mathbf{false}}}
\newcommand{\match}{\ensuremath{\mathrm{m}}}
\newcommand{\matchl}{\ensuremath{\mathrm{match}}}
\newcommand{\findrecv}{\ensuremath{\mathrm{search_r}}}
\newcommand{\smt}{\ensuremath{\mathit{smt}}}


\newcommand{\addsend}{\ensuremath{\mathrm{addsend}}}
\newcommand{\getsend}{\ensuremath{\mathrm{getsend}}}
\newcommand{\removesend}{\ensuremath{\mathrm{removesend}}}
\newcommand{\addrecv}{\ensuremath{\mathrm{addrecv}}}
\newcommand{\getrecv}{\ensuremath{\mathrm{getrecv}}}
\newcommand{\removerecv}{\ensuremath{\mathrm{removefrecv}}}
\newcommand{\hextend}{\ensuremath{\mathrm{hextend}}}
\newcommand{\hlookup}{\ensuremath{\mathrm{hlookup}}}
\newcommand{\etalookup}{\ensuremath{\mathrm{etalookup}}}
\newcommand{\checkmatch}{\ensuremath{\mathrm{checkmatch}}}
\newcommand{\getep}{\ensuremath{\mathrm{getEP}}}
\newcommand{\getmarkremove}{\ensuremath{\mathrm{getMarkRemove}}}
\newcommand{\getlastsendreplace}{\ensuremath{\mathrm{getlastsend/replace}}}
\newcommand{\statuschange}{\left\{ \begin{array}{ll}  \status &\ \mathrm{if}\ |\epsnd(\dst)(\src)|>0\\
   \mathit{error} &\  \mathrm{otherwise}\end{array}\right .}

\newcommand{\reduce}[1]{\ensuremath{\rightarrow_{#1}}}
% Multiple reductions
\newcommand{\reduceK}[1]{\ensuremath{\rightarrow_{#1}^{*}}}
% Non-deterministic reductions
\newcommand{\reduceN}[1]{\ensuremath{\dashrightarrow_{#1}}}
\newcommand{\reduceNK}[1]{\ensuremath{\dashrightarrow_{#1}^{*}}}
\newcommand{\mt}{\ensuremath{\emptyset}}
\newcommand{\trace}{\ensuremath{\mathit{trace}}}
\newcommand{\movebot}{\ensuremath{\mathit{m}}}
\newcommand{\ret}{\ensuremath{\mathbf{ret}}}

\newcommand{\defs}{\ensuremath{\mathrm{defs}}}
\newcommand{\any}{\ensuremath{\mathrm{any}}}
\newcommand{\negate}{\ensuremath{\mathrm{not}}}
\newcommand{\define}{\ensuremath{\mathrm{define}}}
\newcommand{\andd}{\ensuremath{\mathrm{and}}}
\newcommand{\select}{\ensuremath{\mathrm{select}}}
\newcommand{\HB}{\ensuremath{\mathrm{HB}}}
\newcommand{\getlast}{\ensuremath{\mathrm{last}}}
\newcommand{\MATCH}{\ensuremath{\mathrm{MATCH}}}
\newcommand{\ml}{\ensuremath{\mathit{ML}}}
\newcommand{\matchpair}{\ensuremath{\mathrm{MP}}}
\newcommand{\recv}{\ensuremath{\mathrm{\mu}}}
\newcommand{\send}{\ensuremath{\mathrm{\nu}}}



\newsavebox{\boxSMTa}
\begin{lrbox}{\boxSMTa}
\begin{minipage}[c]{0.4\linewidth}
\begin{alltt}
\textit{defs} is not shown;


\textit{constraints};
00 (HB R02.event W(&h1).event)
01 (HB W(&h1).event R05.event)
02 (HB R05.event W(&h2).event)
03 (HB W(&h2).event assume.event)
04 (HB assume.event assert.event)
05 (HB R13.event W(&h3).event)
06 (HB W(&h3).event S15.event)
07 (HB S15.event W(&h4).event)
08 (HB S24.event W(&h5).event)
09 (HB W(&h5).event S27.event)
10 (HB S27.event W(&h6).event)
11 (assert (> b 0))
12 (assert (not (= a 4)))

\textit{match};
13 (MATCH R02 S24)
14 (MATCH R05 S15)
15 (MATCH R13 S27)

\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxSMTb}
\begin{lrbox}{\boxSMTb}
\begin{minipage}[c]{0.4\linewidth}
\begin{alltt}
\textit{defs} is not shown;

\textit{constraints};
00 (HB R02.event W(&h1).event)
01 (HB W(&h1).event R05.event)
02 (HB R05.event W(&h2).event)
03 (HB W(&h2).event assume.event)
04 (HB assume.event assert.event)
05 (HB R13.event W(&h3).event)
06 (HB W(&h3).event S15.event)
07 (HB S15.event W(&h4).event)
08 (HB S24.event W(&h5).event)
09 (HB W(&h5).event S27.event)
10 (HB S27.event W(&h6).event)
11 (assert (> b 0))
12 (assert (not (= a 4)))

\textit{match};
13 (MATCH R02 S15)
14 (MATCH R05 S24)
15 (MATCH R13 S27)

\end{alltt}
\end{minipage}
\end{lrbox}

\newsavebox{\boxSMTc}
\begin{lrbox}{\boxSMTc}
\begin{minipage}[c]{0.4\linewidth}
\begin{alltt}
\textit{defs} is not shown;

\textit{constraints};
00 (HB R02.event W(&h1).event)
01 (HB W(&h1).event R05.event)
02 (HB R05.event W(&h2).event)
03 (HB W(&h2).event assume.event)
04 (HB assume.event assert.event)
05 (HB R13.event W(&h3).event)
06 (HB W(&h3).event S15.event)
07 (HB S15.event W(&h4).event)
08 (HB S24.event W(&h5).event)
09 (HB W(&h5).event S27.event)
10 (HB S27.event W(&h6).event)
11 (assert (> b 0))
12 (assert (not (= a 4)))

\textit{match};
13 (or (MATCH R02 S24)
14     (MATCH R02 S15))
15 (or (MATCH R05 S24)
16     (MATCH R05 S15))
17 (MATCH R13 S27)
18 (NE R02 R05)

\end{alltt}
\end{minipage}
\end{lrbox}




\section{SMT Model}\label{sec:smt}

%The next step, after formally defining the operational semantics of our trace
%language, is to formally define a translation from the trace language into an
%SMT problem that can correctly models the original execution trace.

The novelty of the SMT encoding in this paper is its use of match pairs rather than the state-based or order-based encoding of prior work~\cite{elwakil:padtad10,elwakil:atva10}. The algorithm to create the encoding takes as input a set of possible match pairs and a trace through an MCAPI program with the appropriate assumes and asserts as shown in \figref{fig:trace}. A match pair is the coupling of a receive to a particular send. \figref{fig:smt}(a) is the set of possible match pairs for the program in \figref{fig:mcapi} using our shorthand notation defined in \figref{fig:trace}. The set admits, for example, that $\mathtt{R_{0,2}}$ can be matched with either $\mathtt{S_{1,5}}$ or $\mathtt{S_{2,4}}$. The SMT encoding in this paper asks the SMT solver to resolve the match pairs for the system in such a way that the final values of program variables meet the assumption on control flow but violate some assertion.

Before presenting the SMT encoding for a specific example, we need to explain auxiliary data structures and support functions in detail. We give the definitions in the Yices input language.

% (define HB::(-> a::int b::int (subtype (c::bool) (ite (< a b) (= c true) (= c false)))))
\begin{equation}
\begin{array}{l}
(\cfgt{define}\ \mathrm{HB}::(\rightarrow\ \cfgnt{a::int}\ \cfgnt{b::int}\\
\ \ \ (\cfgt{subtype}\ \cfgnt{(c::bool)}\ (\mathrm{ite}\ (<\ \mathit{a}\ \mathit{b})\ (=\ \mathit{c}\ \mathrm{true})\ (=\ \mathit{c}\ \mathrm{false})))))
\end{array}
\label{equation:hb}
\end{equation}

%\begin{equation}
%\mathrm{HB}(a,b) \equiv \left\{ \begin{array}{rl}
%  \mathit{true} & \mathrm{if}\ a < b \\
%  \mathit{false} & \mathrm{otherwise}\
%\end{array}
%\right .
%\end{equation}

The HB function in equation (\ref{equation:hb}) creates a happens-before relationship between two events. The notation $``\mathrm{ite}"$ refers to a condition statement such that if the condition is satisfied, then the first subclause is true; otherwise, the second subclause is true. The function takes two events $a$ and $b$ as parameters, such that $a,b \in \mathbb{N}$, where $\mathbb{N}$ is the set of natural numbers. In the SMT encoding, every location is assigned an event, and HB orders those locations (i.e., program order, etc.). This function creates a constraint such that the first event must be less than the second event, indicating that the first event occurs before the second event. For example, action $a$ happens before $b$ if and only if $\mathit{event}_a$ for $a$ is greater than $\mathit{event}_b$ for $b$. This function is not only used to assert the program order of statements within the same thread, but also to assert, for any matched pair, that the send operation
occurs before the receive.

\begin{equation}
\begin{array}{l}
%(define-type recv (record match::int e::int var::int event::int))
(\cfgt{define-type}\ R\ (\cfgt{record}\ \cfgnt{M::int}\ \cfgnt{e::int}\ \cfgnt{value::int}\ \cfgnt{event::int})) \\
%(define-type send (record match_po::int id::int e::int value::int event::int))
(\cfgt{define-type}\ S\ (\cfgt{record}\ \cfgnt{O::int}\ \cfgnt{ID::int}\ \cfgnt{e::int}\ \cfgnt{value::int}\ \cfgnt{event::int}))
\end{array}
\label{equation:record}
\end{equation}
%\[R = (M\ \ep_r\ x\ \ploc_r)\]
%\[S = (\mathit{MP}\ \mathit{ID}\ \ep_s\ e\ \ploc_s)\]

We define two records in equation (\ref{equation:record}) that are essential to encoding the SMT problem. The first record $\cfgnt{R}$ defined above represents a receive action such that $\mathit{M}$, $\mathit{e}$, $\mathit{value}$, $\mathit{event} \in \mathbb{N}$. $\mathit{M}$ represents a free variable that is assigned the $\mathit{event}$ field of the matched record $S$. The endpoint $\mathit{e}$ is the endpoint of the receive operation, $\mathit{value}$ represents a value received by the receive operation, and $\mathit{event}$ is the event term which indicates the program order for the receive action associated with the record. The second record $S$ defined above is a send action such that $\mathit{O}$, $\mathit{ID}$, $\mathit{e}$, $\mathit{value}$, $\mathit{event} \in \mathbb{N}$. The fields $\mathit{e}$ and $\mathit{event}$, as those in $\cfgnt{R}$, are the destination endpoint and event term, respectively. The field $\mathit{value}$ is the value being sent. $\mathit{O}$ is a free variable used for match pairs, and it is assigned an event term of a receive operation if the receive operation is to be matched to the send operation. $\mathit{ID}$ is a unique number that identifies each send operation. Note that the integer value assigned to $\mathit{event}$ indicates the program order. Also, we use two match variables, $M$ and $\mathit{O}$, for different purposes. $M$ is used for preventing two receive operations from being matched with the same send operation. $\mathit{O}$ is used for ordering two receive operations with respect to the program order of two matched send operations. The SMT solver must assign the $\mathit{M}$ and $\mathit{event}$ fields of the send tuple, and it must assign the $\mathit{event}$, $\mathit{M}$, and $\mathit{value}$ fields of the receive tuple in a way that is consistent with all the constraints in the encoding.

%(define MATCH::(-> r::recv s::send (subtype (c::bool) (ite
 % (and (= (select r ep) (select s ep))
 %      (= (select r var) (select s value))
  %     (HB (select s event) (select r event))
   %    (= (select r match) (select s id))
%       (= (select s match_po) (select r event)))%
% (= c true)
% (= c false)))))

\begin{equation}
\begin{array}{l}
(\cfgt{define}\ \mathrm{MATCH}::(\rightarrow\ \cfgnt{r::R}\ \cfgnt{s::S}\ (\cfgt{subtype}\ \cfgnt{(c::bool)}\ (\cfgnt{ite} \\
\ \ \ (\mathrm{and}\ (=\ (\mathrm{select}\ \mathit{r}\ \mathit{e})\ (\mathrm{select}\ \mathit{s}\ \mathit{e})) \\
\ \ \ \ \     (=\ (\mathrm{select}\ \mathit{r}\ \mathit{value})\ (\mathrm{select}\ \mathit{s}\ \mathit{value})) \\
\ \ \ \ \    (\mathrm{HB}\ (\mathrm{select}\ \mathit{s}\ \mathit{event})\ (\mathrm{select}\ \mathit{r}\ \mathit{event})) \\
\ \ \ \ \    (=\ (\mathrm{select}\ \mathit{r}\ \mathit{M})\ (\mathrm{select}\ \mathit{s}\ \mathit{ID})) \\
\ \ \ \ \    (=\ (\mathrm{select}\ \mathit{s}\ \mathit{O})\ (\mathrm{select}\ \mathit{r}\ \mathit{event}))) \\
\ \ \  (=\ \mathit{c}\ \mathrm{true}) \\
\ \ \  (=\ \mathit{c}\ \mathrm{false})))))
\end{array}
\label{equation:match}
\end{equation}


%\begin{equation}
%\mathrm{MATCH}(R,S) \equiv \left\{
%\begin{array}{ll}
%  \mathit{true} & \mathrm{if}\ M = \mathit{ID}~\wedge \\
%  & \ep_r = \ep_s~\wedge \\
%  & x = e~\wedge \\
%  & \mathrm{HB}(\ploc_s,\ploc_r)~\wedge \\
%  & \mathit{MP}_r = \ep_r \\
%  \mathit{false} & \mathrm{otherwise}\
%\end{array}
%\right . \\
%\end{equation}

The $\mathrm{MATCH}$ function in equation (\ref{equation:match}) takes tuple $R$ and $S$ as parameters. Each $``\mathrm{select}"$ statement selects a field of the tuple $R$ or $S$. The function creates a number of constraints that represent the pairing
of the specified send and receive operations. This function asserts that the
destination endpoint of the send operation is the same as the endpoint used by
the receive operation, that the value sent by the send operation is the same
value received by the receive operation, that the send operation occurs before
the receive operation, that the ``match'' value in the receive tuple is
equal to the ``ID'' value in the send tuple, and that the ``O" value in the send tuple is equal to the ``event" value in the receive tuple. Note that the encoding is going to use the ``O"  value in conjunction with the HB function to enforce message non-overtaking when messages are sent from the same endpoint. Consider a simple example below that sends two messages from a Task 0 to Task 1,
\[
\begin{array}{l|l}
\;\;\;\;\;\;\;\;\mathtt{Task\ 0}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{Task\ 1}\;\;\;\;\;\;\;\; \\
\hline
\;\;\;\;\;\;\;\;\mathtt{S_{0,1}(1,\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,1}(*,\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{S_{0,2}(1,\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,2}(*,\&h4)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h4)}\;\;\;\;\;\;\;\; \\
\end{array}
\]
The ``O" values in the send records will be assigned to the order tracking events for $\mathtt{R_{1,1}}$ and $\mathtt{R_{1,2}}$ in the final encoding. Message non-overtaking from transactions on common endpoints is encoded by forcing the send events to be received in program order using the HB function as below in our simple example:
\[(\mathrm{HB}\ (\mathrm{select}\ \mathtt{S_{0,1}}\ \mathrm{O})\ (\mathrm{select}\ \mathtt{S_{0,2}}\ \mathrm{O}))\]


\begin{equation}
\begin{array}{l}
(\cfgt{define}\ \mathrm{NE}::(\rightarrow\ \cfgnt{r1::R}\ \cfgnt{r2::R}\ (\cfgt{subtype}\ \cfgnt{(c::bool)}\ (\cfgnt{ite} \\
\ \ (=\ (\mathrm{select}\ \mathit{r1}\ \mathit{M})\ (\mathrm{select}\ \mathit{r2}\ \mathit{M})) \\
\ \ (=\ \mathit{c}\ \mathrm{false}) \\
\ \ (=\ \mathit{c}\ \mathrm{true})))))
\end{array}
\label{equation:ne}
\end{equation}

%\begin{equation}
%\mathrm{ne}(a,b) \equiv \left\{ \begin{array}{rl}
%  \mathit{true} & \mathrm{if}\ M_a \not = M_b \\
%  \mathit{false} & \mathrm{otherwise}\
%\end{array}
%\right .
%\end{equation}

The $\mathrm{NE}$ function in equation (\ref{equation:ne}) is used to assert that no two receive operations are matched
with the same send operation. The parameters for this function are two receive
tuples. An assertion is made that the values of their ``match'' fields, $M$,
are not equal. This shows that they are paired with two different send
operations.

Prior SMT models of MCAPI program executions implicitly compute
match pairs by adding possible happens-before relations on sends and
receives with the conditions under which those orderings are
valid. The SMT solver is then asked to resolve the happens-before
relation by choosing specific orders of sends and receives. Match pair
encoding, as presented in this work, though it has the same
computational complexity as order based encoding (you still need to
figure out match pairs on endpoints), is simpler to reason about
directly rather than implicitly through orders, results in
significantly fewer terms in the SMT problem, and does not restrict out possible matches allowed by the MCAPI specification of the runtime as do existing encodings.

The presentation of the SMT encoding is structured as
\[\mathit{smt}\ =\ (\mathit{defs}\ \mathit{constraints}\ \mathit{match})\]
where the field $\mathit{defs}$ represents all definitions of the send, receive operations and the free variables; The field $\mathit{constraints}$ represents all constraint clauses, including the assert clauses and the clauses built by the \texttt{HB} functions; and the field $\mathit{match}$ represents the clauses built by the \texttt{MATCH} function on a set of match pairs and the \texttt{NE} function. %We use $\mathit{match}.\mathit{input}$ to represent the input set of match pairs.

The \textit{Intra-Happens-Before-Order}(\textit{Intra-HB}) in \cite{sarvani:fm09} constrains the Happens-Before relations between commands in any control flow path. Those relations are essential to the POE algorithm for their Message-passing verifier. Our SMT structure encodes all the relations in \textit{Intra-HB}, such that it can follow any control flow path executed by the POE algorithm in \cite{sarvani:fm09}. The \textit{Intra-HB} consists of 8 \textit{Happens-Before} relations:
\[\prec_{mhb}\ =\ \prec_S \cup \prec_R \cup \prec_W \cup \prec_{SW} \cup \prec_{RW} \cup \prec_{mb} \cup \prec_{fo} \cup \prec_{io} \]
The relations for \textit{Barrier} commands are omitted because they are not supported in the MCAPI programs. The relations $\prec_S$, $\prec_R$ and $\prec_W$ are used to constrain the state transition of commands. For example, issuing a send command happens before matching it with some receive in transit. Instead of explicitly giving the state information, the SMT structure in this paper implicitly encodes the state transitions in the field \textit{constraints}. The relations $\prec_{SW}$, $\prec_{RW}$, $\prec_{fo}$ and $\prec_{io}$ constrain the program order of commands. We encode those relations in the field \textit{constraints} of our SMT encoding. The relation $\prec_{mb}$ builds the match before for sends and receives. Also, we have the relation in the field \textit{match} in our SMT encoding.

The input for generating the SMT encoding is a MCAPI program together with a set of match pairs. The program in \figref{fig:mcapi} with the set of match pairs in \figref{fig:smt}(a) is such an example. Given an input, the algorithm for generating our encoding is enumerated as follows.
\begin{enumerate}
\item Define a variable for the program order of each assume or assert command in the field $\mathit{defs}$;
\item for each assume, add a statement to $\mathit{constraints}$, and for each assert, add a negated assert to $\mathit{constraints}$ in order to obtain an execution trace with assertion failure from an SMT solver;
\item for each send or receive in the trace, create an $S$ or $R$ definition and create an associated ``.event" variable for program order and add these to $\mathit{defs}$;
\item for each program order represented by the field $\mathrm{event}$ in each thread, add an \texttt{HB} relation on the associated event for program order to $\mathit{constraints}$;
\item for each match pair for a send and receive as input, add an $\mathrm{MATCH}$ relation to $\mathit{match}$;
\item for two sends $\mathtt{S_{i,j}}$ and $\mathtt{S_{i,k}}$ in the same task \texttt{i} sent to an identical endpoint such that $\mathtt{i} < \mathtt{k}$, if the relation $(\mathrm{HB}\ \mathtt{S_{i,j}.event}\ \mathtt{S_{i,k}.event})$ is defined in $\mathit{constraints}$, add the clause $(\mathrm{HB}\ (\mathrm{select}\ \mathtt{S_{i,j}}\ \mathrm{O})\ (\mathrm{select}\ \mathtt{S_{i,k}}\ \mathrm{O}))$ to $\mathit{constraints}$.
\item collect into a disjunction for all possible send matches for any given receive in the field $\mathit{match}$;
\item and collect into a $\mathrm{NE}$ relation for all receives that are matched with any identical send and add it to $\mathit{match}$.
\end{enumerate}

\begin{figure}
\begin{center}
\setlength{\tabcolsep}{30pt}
\begin{tabular}[c]{cc}
\scalebox{0.6}{\usebox{\boxMP}} &
%\scalebox{0.6}{\usebox{\boxSMTa}} &
%\scalebox{0.6}{\usebox{\boxSMTb}} &
\scalebox{0.6}{\usebox{\boxSMTc}} \\
(a) & (b)
\end{tabular}
\end{center}
\caption{A match pair set and SMT encoding of the system in \figref{fig:mcapi}.
(a) The match pairs based on endpoints. (b) The SMT encoding where \texttt{HB} creates a
happens-before constraint, \texttt{MATCH} creates a match pair constraint, and \texttt{NE} creates a constraint to preclude the use of conflicting match pairs.}
\label{fig:smt}
\end{figure}

\figref{fig:smt}(b) is a concrete example of the SMT encoding for our running program in \figref{fig:mcapi} given the set of match pairs in \figref{fig:smt}(a) as input. The field $\mathit{defs}$ is not shown because the definitions are not novel to our solution. Line \texttt{00} - \texttt{12} are the $\mathit{constraints}$, and line \texttt{13} - \texttt{18} are the $\mathit{match}$ of the SMT encoding. In particular, by encoding function $\mathrm{HB}$, $\mathtt{R_{0,2}}$ happens before the wait command $\mathtt{W(\&h1)}$ given the ``event'' for each command as parameters on line \texttt{00} in \figref{fig:smt}(b). We use the wait command with handler in \figref{fig:trace} to denote the wait command for a send or receive command. Any assignment to event variables by the SMT solver must comply with program order constraints. Each event in the $\mathrm{HB}$ orderings on line \texttt{00} - \texttt{10} are ordered in a thread of \figref{fig:mcapi}. Also, the \texttt{MATCH} function encodes the relation such that $\mathtt{R_{0,2}}$ is matched with $\mathtt{S_{1,5}}$ on line \texttt{14} in \figref{fig:smt}(b). The \texttt{NE} term precludes $\mathtt{R_{0,2}}$ and $\mathtt{R_{0,5}}$ from matching to the same send on line \texttt{18}. Other than the support functions, the first assert on line \texttt{11} works as the assume (line \texttt{08} at task 0) in \figref{fig:mcapi}, such that it prevents the SMT solver from finding solutions that are not consistent with control flow which requires ``$b \ge 0$". Finally, the second assert on line \texttt{12} is negated as the goal is to find schedules that violate the property. In our example, the interest is in solutions that resolve in $a \neq 4$ and follow the same control flow with $b > 0$.

Other than the basic structure of the SMT encoding, we use the function
\[\mathrm{ANS}(\mathit{smt}) \mapsto \{\mathrm{\cfgt{SAT}},\mathrm{\cfgt{UNSAT}}\} \]
to return the solution of an SMT problem, such that $\mathrm{\cfgt{SAT}}$ represents a satisfiable solution that finds an execution of the MCAPI program that violates the user defined correctness property, and $\mathrm{\cfgt{UNSAT}}$ represents an unsatisfiable solution that all possible execution traces either meet correctness property in the same control flow, or follow a different control flow. Note that $\mathrm{\cfgt{UNSAT}}$ and $\mathrm{\cfgt{SAT}}$ are ordered such that $\mathrm{\cfgt{UNSAT}} < \mathrm{\cfgt{SAT}}$.

The SMT encoding defined above is used to capture the non-deterministic behavior of an MCAPI program by giving a complete set of match pairs. As we discussed in the previous section, the MCAPI program in \figref{fig:mcapi} contains two outcomes of execution. The SMT encoding we present in \figref{fig:smt}(b) captures both executions, since the set of match pairs in \figref{fig:smt}(a) is a complete set where all matches that can occur in the real execution for our running example in \figref{fig:mcapi} are included, and all matches that can not occur in the real execution are not included. Furthermore, the following theorem states that we can over-approximate the true set of match pairs and still prove correctness. If there is no error with the over-approximated set, then there is no error arising from non-determinism in the runtime on that program execution. If there is an error from the over-approximated set, then that error may or may not be a real error. Note that two SMT problems $\smt_{\alpha}$ and $\smt_{\beta}$ in the following theorem have an identical $\mathit{defs}$ and $\mathit{constraints}$ sets, and the match set of $\smt_{\alpha}$ is the subset of that of $\smt_{\beta}$ so that $smt_{\beta}$ represents an over-approximation of $smt_{\alpha}$.

\begin{theorem}
For two SMT problems, $\smt_{\alpha} = (\mathit{defs}\ \mathit{constraints}\ \mathit{match}_{\alpha})$ and $\smt_{\beta} = (\mathit{defs}\ \mathit{constraints}\ \mathit{match_{\beta}})$,
if $\mathit{set(match_{\alpha})} \subseteq \mathit{set(match_{\beta})}$,
\[\mathrm{ANS}(\smt_{\alpha}) \leq \mathrm{ANS}(\smt_{\beta})\]
where $\mathit{set(match)}$ represents the input set of match pairs for the $\mathtt{MATCH}$ clauses in the field $\mathit{match}$.
\label{thm:1}
\end{theorem}

\begin{figure}
\begin{center}
\setlength{\tabcolsep}{30pt}
\begin{tabular}[c]{cc}
%\scalebox{0.7}{\usebox{\boxMP}} &
\scalebox{0.6}{\usebox{\boxSMTa}} &
\scalebox{0.6}{\usebox{\boxSMTb}} \\
%\scalebox{0.7}{\usebox{\boxSMTc}} \\
(a) & (b)
\end{tabular}
\end{center}
\caption{Two SMT encodings of the system in \figref{fig:mcapi}.
(a) The SMT encoding for Trace 1 in \figref{fig:trace}. (b) The SMT encoding for Trace 2 in \figref{fig:trace}.}
\label{fig:smt_trace}
\end{figure}

\subsubsection{Proof Sketch}
Consider the MCAPI program in \figref{fig:mcapi} as an example.
\figref{fig:smt_trace}(a) and (b) are two different SMT encodings for our running
example in \figref{fig:mcapi} generated from different sets of possible match pairs, such that \figref{fig:smt_trace}(a) encodes trace 1 in \figref{fig:trace} and \figref{fig:smt_trace}(b) encodes trace 2 in \figref{fig:trace}. By solving the encodings in \figref{fig:smt_trace}(a) and (b) for trace 1 and 2 in \figref{fig:trace} respectively, we get an unsatisfiable solution for \figref{fig:smt_trace}(a), and a satisfiable solution for \figref{fig:smt_trace}(b). As we discussed in Section 2, trace 1 is an execution without failure of the assertion, and trace 2 is the one that fails the assertion. %We can see that the encodings in \figref{fig:smt_trace} (a) and (b) correctly encodes trace 1 and 2 in \figref{fig:trace}, respectively.
Compare both encodings with that in \figref{fig:smt}(b), we find that the fields $\mathit{defs}$ and $\mathit{constraints}$ are identical except for the \texttt{MATCH} clauses. In particular, the input set of match pairs of either \figref{fig:smt_trace}(a) or (b) is the subset of that in \figref{fig:smt}(b). As discussed above, the encoding in \figref{fig:smt}(b) captures the non-deterministic behavior of our running program in \figref{fig:mcapi}, which encodes trace 1 and 2 in \figref{fig:trace} into one single SMT problem. Thus, an SMT solver will return a satisfiable solution for the encoding in \figref{fig:smt}(b). Thus, $\mathrm{ANS}$ on the encoding in \figref{fig:smt}(b) is greater than or equal to the $\mathrm{ANS}$ on the encoding in either \figref{fig:smt_trace}(a) or (b). The formal proof is given in a long version of paper at (\url{``http://students.cs.byu.edu/~yhuang2/downloads/paper.pdf''}).

The non-determinism of an MCAPI program discussed above relies on the \textit{infinite-buffer} setting. If the \textit{zero-buffer} setting is used instead, the SMT encoding needs to be reorganized as follows. For each match pair that can not exist in the program runtime caused by the \textit{zero-buffer} problem discussed in Section 2, add extra \texttt{HB} clauses in the SMT encoding to prevent incorrect behavior. For example in \figref{fig:mcapi}, to prevent $\mathtt{R_{1,3}}$ to be matched with $\mathtt{S_{2,6}}$ before $\mathtt{R_{0,2}}$ is matched with $\mathtt{S_{2,4}}$ prohibited by the \textit{zero-buffer}, an \texttt{HB} relation is added such that the wait command $\mathtt{W(\&h1)}$ for $\mathtt{R_{0,2}}$ happens before $\mathtt{S_{0,6}}$.













