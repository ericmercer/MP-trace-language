\newcommand{\epsnd}{\textit{Pnd\_s}}
\newcommand{\eprcv}{\textit{Pnd\_r}}
\newcommand{\qset}{\textit{Q\_s}}
\newcommand{\snd}{\textit{snd}}
\newcommand{\rcv}{\textit{rcv}}
\newcommand{\q}{\textit{q}}
\newcommand{\frm}{\textit{frm}}
\newcommand{\vbot}{\textit{v$-\bot$}}
\newcommand{\status}{\textit{s}}
\newcommand{\last}{\textit{l}}
\newcommand{\error}{\ensuremath{\mathbf{error}}}
\newcommand{\aidmap}{\textit{A}}
\newcommand{\thread}{\ensuremath{\mathit{t}}}
\newcommand{\aid}{\ensuremath{\mathit{a}}}
\newcommand{\ploc}{\ensuremath{\rho}}
\newcommand{\loc}{\ensuremath{\mathit{l}}}
\newcommand{\cmd}{\ensuremath{\mathit{c}}}
\newcommand{\op}{\ensuremath{\mathit{op}}}
\newcommand{\applyop}{\ensuremath{\mathrm{op}}}
\newcommand{\wait}{\ensuremath{\mathbf{wait}}}
\newcommand{\sendi}{\ensuremath{\mathbf{sndi}}}
\newcommand{\recvi}{\ensuremath{\mathbf{rcvi}}}
\newcommand{\traceentry}{\ensuremath{\sigma}}
\newcommand{\movelist}{\ensuremath{\delta}}
\newcommand{\assume}{\ensuremath{\mathit{assume}}}
\newcommand{\checkassume}{\ensuremath{\mathrm{assume}}}
\newcommand{\assert}{\ensuremath{\mathit{assert}}}
\newcommand{\checkassert}{\ensuremath{\mathrm{assert}}}
\newcommand{\ep}{\ensuremath{\mathbf{\gamma}}}
\newcommand{\src}{\ensuremath{\alpha}}
\newcommand{\dst}{\ensuremath{\beta}}
\newcommand{\true}{\ensuremath{\mathbf{true}}}
\newcommand{\false}{\ensuremath{\mathbf{false}}}
\newcommand{\match}{\ensuremath{\mathrm{m}}}
\newcommand{\matchl}{\ensuremath{\mathrm{match}}}
\newcommand{\findrecv}{\ensuremath{\mathrm{search_r}}}
\newcommand{\smt}{\ensuremath{\mathit{smt}}}


\newcommand{\addsend}{\ensuremath{\mathrm{addsend}}}
\newcommand{\getsend}{\ensuremath{\mathrm{getsend}}}
\newcommand{\removesend}{\ensuremath{\mathrm{removesend}}}
\newcommand{\addrecv}{\ensuremath{\mathrm{addrecv}}}
\newcommand{\getrecv}{\ensuremath{\mathrm{getrecv}}}
\newcommand{\removerecv}{\ensuremath{\mathrm{removefrecv}}}
\newcommand{\hextend}{\ensuremath{\mathrm{hextend}}}
\newcommand{\hlookup}{\ensuremath{\mathrm{hlookup}}}
\newcommand{\etalookup}{\ensuremath{\mathrm{etalookup}}}
\newcommand{\checkmatch}{\ensuremath{\mathrm{checkmatch}}}
\newcommand{\getep}{\ensuremath{\mathrm{getEP}}}
\newcommand{\getmarkremove}{\ensuremath{\mathrm{getMarkRemove}}}
\newcommand{\getlastsendreplace}{\ensuremath{\mathrm{getlastsend/replace}}}
\newcommand{\statuschange}{\left\{ \begin{array}{ll}  \status &\ \mathrm{if}\ |\epsnd(\dst)(\src)|>0\\
   \mathit{error} &\  \mathrm{otherwise}\end{array}\right .}

\newcommand{\reduce}[1]{\ensuremath{\rightarrow_{#1}}}
% Multiple reductions
\newcommand{\reduceK}[1]{\ensuremath{\rightarrow_{#1}^{*}}}
% Non-deterministic reductions
\newcommand{\reduceN}[1]{\ensuremath{\dashrightarrow_{#1}}}
\newcommand{\reduceNK}[1]{\ensuremath{\dashrightarrow_{#1}^{*}}}
\newcommand{\mt}{\ensuremath{\emptyset}}
\newcommand{\trace}{\ensuremath{\mathit{trace}}}
\newcommand{\movebot}{\ensuremath{\mathit{m}}}
\newcommand{\ret}{\ensuremath{\mathbf{ret}}}

\newcommand{\defs}{\ensuremath{\mathrm{defs}}}
\newcommand{\any}{\ensuremath{\mathrm{any}}}
\newcommand{\negate}{\ensuremath{\mathrm{not}}}
\newcommand{\define}{\ensuremath{\mathrm{define}}}
\newcommand{\andd}{\ensuremath{\mathrm{and}}}
\newcommand{\select}{\ensuremath{\mathrm{select}}}
\newcommand{\HB}{\ensuremath{\mathrm{HB}}}
\newcommand{\getlast}{\ensuremath{\mathrm{last}}}
\newcommand{\MATCH}{\ensuremath{\mathrm{MATCH}}}
\newcommand{\ml}{\ensuremath{\mathit{ML}}}
\newcommand{\matchpair}{\ensuremath{\mathrm{MP}}}
\newcommand{\recv}{\ensuremath{\mathrm{\mu}}}
\newcommand{\send}{\ensuremath{\mathrm{\nu}}}

\newsavebox{\boxSMTa}
\begin{lrbox}{\boxSMTa}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h1)}}$}\\
\texttt{01 $\mathit{event_\mathtt{R_{0,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h2)}}$}\\
\texttt{02 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{R_{0,5}}}$}\\
\texttt{03 $\mathit{event_\mathtt{R_{1,3}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h3)}}$}\\
\texttt{04 $\mathit{event_\mathtt{S_{1,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h4)}}$}\\
\texttt{05 $\mathit{event_\mathtt{S_{2,4}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h5)}}$}\\
\texttt{06 $\mathit{event_\mathtt{S_{2,7}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h6)}}$}\\
\texttt{07 ($\mathit{assert}$ (> b 0))}\\
\texttt{08 ($\mathit{assert}$ (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{09 $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{2,4}}\rangle$}\\
\texttt{10 $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{1,5}}\rangle$}\\
\texttt{11 $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTb}
\begin{lrbox}{\boxSMTb}
\normalsize
\begin{tabular}[c]{l}
\texttt{\textit{defs} is not shown;}\\
\\
\texttt{\textit{constraints};}\\
\texttt{00 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h1)}}$}\\
\texttt{01 $\mathit{event_\mathtt{R_{0,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h2)}}$}\\
\texttt{02 $\mathit{event_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{R_{0,5}}}$}\\
\texttt{03 $\mathit{event_\mathtt{R_{1,3}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h3)}}$}\\
\texttt{04 $\mathit{event_\mathtt{S_{1,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h4)}}$}\\
\texttt{05 $\mathit{event_\mathtt{S_{2,4}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h5)}}$}\\
\texttt{06 $\mathit{event_\mathtt{S_{2,7}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{event_\mathtt{W(\&h6)}}$}\\
\texttt{07 ($\mathit{assert}$ (> b 0))}\\
\texttt{08 ($\mathit{assert}$ (not (= a 4)))}\\
\\
\texttt{\textit{match};}\\
\texttt{09 $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{1,5}}\rangle$}\\
\texttt{10 $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{2,4}}\rangle$}\\
\texttt{11 $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$}\\

\end{tabular}
\end{lrbox}

\newsavebox{\boxSMTc}
\begin{lrbox}{\boxSMTc}
\normalsize
\begin{tabular}[t]{l}
\texttt{...} \\
\texttt{01 $\mathit{order_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{order_\mathtt{W(\&h1)}}$}\\
\texttt{02 $\mathit{order_\mathtt{R_{0,5}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{order_\mathtt{W(\&h2)}}$}\\
\texttt{03 $\mathit{order_\mathtt{R_{0,2}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{order_\mathtt{R_{0,5}}}$}\\
\texttt{04 $\mathit{order_\mathtt{R_{1,3}}}$ $\mathtt{\prec_\mathtt{HB}}$ $\mathit{order_\mathtt{W(\&h3)}}$}\\
\texttt{05} \texttt{(> b 0)}\\
\texttt{06} \texttt{(not (= a 4))}\\
\texttt{07} $\langle\mathtt{R_{0,2}}$,$\mathtt{S_{2,4}}\rangle\vee\langle\mathtt{R_{0,2}}$,$\mathtt{S_{1,5}}\rangle$\\
\texttt{08} $\langle\mathtt{R_{0,5}}$,$\mathtt{S_{2,4}}\rangle\vee\langle\mathtt{R_{0,5}}$,$\mathtt{S_{1,5}}\rangle$\\
\texttt{09} $\langle\mathtt{R_{1,3}}$,$\mathtt{S_{2,7}}\rangle$
\end{tabular}
\end{lrbox}

\newsavebox{\boxMP}
\begin{lrbox}{\boxMP}
\normalsize
\begin{tabular}[t]{l}
$\langle\mathtt{R_{0,2}}$, $\mathtt{S_{2,4}}\rangle$\\
$\langle\mathtt{R_{0,2}}$, $\mathtt{S_{1,5}}\rangle$\\
\\
$\langle\mathtt{R_{0,5}}$, $\mathtt{S_{2,4}}\rangle$\\
$\langle\mathtt{R_{0,5}}$, $\mathtt{S_{1,5}}\rangle$\\
\\
$\langle\mathtt{R_{1,3}}$, $\mathtt{S_{2,7}}\rangle$\\
\end{tabular}
\end{lrbox}

\section{SMT Encoding}\label{sec:smt}

The new SMT encoding is based on (1) a trace of events during an
execution of an MCAPI program including control-flow assumptions and
property assertions, such as \figref{fig:trace1}; and (2) a set of
possible match pairs. A match pair is the coupling of a receive to a
particular send.  In the running example, the set admits, for example,
that $\mathtt{R_{0,2}}$ can be matched with either $\mathtt{S_{1,5}}$
or $\mathtt{S_{2,4}}$. This direct use of match pairs, rather than a
state-based or indirect use of match pairs in an order-based
encoding, \cite{elwakil:padtad10} and \cite{elwakil:atva10}, is novel.

The purpose of the SMT encoding is to force the SMT solver to resolve
the match pairs for the system in such a way that the final values of
program variables meet the assumptions on control flow but violate
some assertion. In essence, the SMT solver completes a partial order
on operations into a total order that determines the final match pair
relationships.

\subsection{Definitions} \label{sec:smt-defns}

The encoding needs to express the partial order imposed by the MCAPI
semantics as SMT constraints. The partial order is based on a
\emph{Happens-Before} relation over operations such as send, receive,
wait, or assert:

\begin{definition}[Happens-Before]
The \emph{Happens-Before} $(\mathtt{HB})$ relation, denoted as
$\mathrm{\prec_\mathtt{HB}}$, is a partial order over operations.
\label{def:hb}
\end{definition}

Given two operations, $A$ and $B$, if $A$ must complete before $B$ in a
valid program execution, then $A$ $\mathrm{\prec_{\mathtt{HB}}}$ $B$
will be an SMT constraint.

The relation is derived from the program source and potential match pairs. In
order to specify the constraints from the program source, each program operation is mapped to a set of variables that can be manipulated by the SMT solver.

\begin{definition}[Wait] \label{def:event}
The occurrence of a wait operation, \texttt{W}, is captured by a
single variable, $\mathit{order}_\mathtt{W}$, that constrains when
the wait occurs.
\end{definition}

It is not enough to represent all events as simple numbers
that will be ordered in this way.  Such an encoding would not allow the solver to
discover what values would flow across communication primitives. Instead, some events in the trace are modeled as a set of SMT
variables that record the pertinent information about the event. For
example,

\begin{definition}[Send] \label{def:snd}
A send operation $\mathtt{S}$, is a four-tuple of variables:
\begin{compactenum}
\item $M_\mathtt{S}$, the order of the matching receive event;

\item $\mathit{order}_\mathtt{S}$, the order of the send;

\item $e_\mathtt{S}$, the endpoint; and,

\item $\mathit{value}_\mathtt{S}$, the transmitted value.
\end{compactenum}
\end{definition}

The endpoints do not change and the transmitted values are constants in an SMT encoding mainly because this static topology has already been evaluated in an existing execution trace once the trace was obtained. The most complex operation in MCAPI is a receive. Since receives are
inherently asynchronous, it is not possible to represent them
atomically. Instead, we need to associate each receive with a wait
that marks where in the program the receive operation is guaranteed to be
complete. The MCAPI runtime semantics allow a single wait to witness the completion of many receives due to \emph{the message
  non-overtaking property}. A wait that witnesses the completion of
one or more receives is the \emph{nearest-enclosing wait}.

\begin{definition}[Nearest-Enclosing Wait] \label{def:nw}
A wait that witnesses the completion of a receive by indicating that
the message is delivered and that all the previous receives in the
same task issued earlier are complete as well.
\end{definition}

\begin{figure}[t]
\[
\begin{array}{l|l}
\;\;\;\;\;\;\;\;\mathtt{Task\ 0}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{Task\ 1}\;\;\;\;\;\;\;\; \\
\hline
\;\;\;\;\;\;\;\;\mathtt{R_{0,1}(*,\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{S_{1,1}(0,\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{R_{0,2}(*,\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W{(\&h3)}}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W{(\&h2)}}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{S_{1,2}(0,\&h4)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W{(\&h1)}}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W{(\&h4)}}\;\;\;\;\;\;\;\; \\
\end{array}
\]
\caption{Nearest-enclosing Wait example} \label{fig:nw}
\end{figure}

\figref{fig:nw} shows that the wait $\mathtt{W{(\&h2)}}$
witnesses the completion of the receive $\mathtt{R_{0,1}}$ and
$\mathtt{R_{0,2}}$ in task 0. Thus, $\mathtt{W{(\&h2)}}$ is their
nearest-enclosing wait.

The encoding requires that every receive operation have a
nearest-enclosing wait as it makes match pair decisions at the wait
operation. The requirement is not a limitation of the encoding, as
accessing a buffer from a receive that does not have a
nearest-enclosing wait is an error. Rather, the wait is a convenience
in the encoding to mark where a receive actually takes place. The same
requirement can be made for sends for correctness but is not required
for the encoding as send buffering is handled differently than receive
buffering.  The encoding effectively ignores wait operations for sends
as will be seen.

\begin{definition}[Receive] \label{def:rcv}
A receive operation $\mathtt{R}$ is modeled by a five-tuple of variables:
\begin{compactenum}
\item $M_\mathtt{R}$, the order of the matching send event;

\item $\mathit{order}_\mathtt{R}$, the order of the receive;

\item $e_\mathtt{R}$, the endpoint;

\item $\mathit{value}_\mathtt{R}$, the received value; and,

\item $\mathit{nw}_\mathtt{R}$, the order of the nearest enclosing wait.
\end{compactenum}
\end{definition}

\subsection{Assumptions, Assertions, and match pairs}

The definitions so far merely establish the pertinent information
about each event in the trace as SMT variables. It is necessary to now express
constraints on those variables.

The most trivial kind of constraints are those for control-flow
assumptions.

\begin{definition}[Assumption] \label{def:assm}
Every assumption $\mathtt{A}$ is added as an SMT assertion.
\end{definition}

It may seem strange to turn \emph{assumptions} into
\emph{assertions}, but from a constraint perspective, the assumption
that we have already observed some property (during control-flow) is
equivalent to instructing the SMT solver to treat it as inviolate
truth, or an assertion.

The next level of constraint complexity comes from property
assertions. These correspond to the invariants of the program. The
goal is to discover if they can be violated, so we instruct the SMT
solver to seek for a way to satisfy their \emph{negation} given all
the other constraints.

\begin{definition}[Property Assertion] \label{def:assert}
For every property assertion $\mathtt{P}$, $\neg \mathtt{P}$ is added as
an SMT assertion.
\end{definition}

Finally, we must express the relation in a given match pair as a set of SMT
constraints. Informally, a match pair equates the shared components of
a send and receive and constrains the send to occur before the
nearest-enclosing wait of the receive. Formally:

\begin{definition}[Match Pair] \label{def:match}
A match pair, $\langle\mathtt{R}, \mathtt{S}\rangle$, for a receive
$\mathtt{R}$ and a send $\mathtt{S}$ corresponds to the constraints:
\begin{compactenum}
\item $M_{\mathtt{R}} = \mathit{order}_{\mathtt{S}}$
\item $M_{\mathtt{S}} = \mathit{order}_{\mathtt{R}}$
\item $e_{\mathtt{R}} = e_{\mathtt{S}}$
\item $\mathit{value}_{\mathtt{R}} = \mathit{value}_{\mathtt{S}}$ and
\item $\mathit{order}_{\mathtt{S}}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{nw}_{\mathtt{R}}$
\end{compactenum}
\end{definition}

The encoding is given a set of potential match pairs over all the
sends and receives in the program trace. The constraints from these
match pairs are not simply joined in a conjunctions. If we were to do that, then we
would be constraining the system such that a single receive must be
paired with all possible sends in a feasible execution rather than a
single send. Therefore, we combine all the constraints for a given
receive with all possible sends as specified by the input match pairs
into a single disjunction:

\begin{definition}[Receive Matches]
For each receive $\mathtt{R}$, if $\langle\mathtt{R},
\mathtt{S}_0\rangle$ through $\langle\mathtt{R}, \mathtt{S}_n\rangle$
are match pairs, then $\bigvee_{i}^{n} \langle\mathtt{R},
\mathtt{S}_i\rangle$ is used as an SMT constraint.
\end{definition}

This encoding of the input ensures that the SMT solver can only use
compatible send/receive pairs and ensures that sends happen before
nearest-enclosing waits on receives.

\subsection{Program Order Constraints}

The encoding thus far is missing
additional constraints on the \emph{Happens-Before} relation stemming from program order. These constraints are added in four steps: we must ensure that sends to common endpoints occur
in program order in a single task (step 1); similarly for receives
(step 2); receives occur before their nearest-enclosing wait (step 3);
and, that sends are received in the order they are sent (step 4).

\paragraph*{Step 1} For each task, if there are sequential send
operations, say $\mathtt{S}$ and $\mathtt{S^\prime}$, from that task
to a common endpoint, $e_\mathtt{S} = e_\mathtt{S^\prime}$, then those
sends must follow program order: $\mathit{order}_\mathtt{S}$
$\prec_\mathtt{HB}$ $\mathit{order}_\mathtt{S^\prime}$.

\paragraph*{Step 2} For each task, if there are sequential receive
operations, say $\mathtt{R}$ and $\mathtt{R^\prime}$, in that task
on a common endpoint, $e_\mathtt{R} = e_\mathtt{R^\prime}$, then those
receives must follow program order: $\mathit{order}_\mathtt{R}$
$\prec_\mathtt{HB}$ $\mathit{order}_\mathtt{R^\prime}$.

\paragraph*{Step 3} For every receive \texttt{R} and its nearest
enclosing wait \texttt{W}, $\mathit{order}_\mathtt{R}$
$\prec_\mathtt{HB}$ $\mathit{order}_\mathtt{W}$.

\paragraph*{Step 4} For any pair of sends $\mathtt{S}$ and
$\mathtt{S'}$ on common endpoints, $e_{\mathtt{S}}=e_{\mathtt{S'}}$,
such that
$\mathit{order}_\mathtt{S}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{order}_\mathtt{S'}$,
then those sends must be received in the same order:
$M_{\mathtt{S}}\ \mathrm{\prec_{\mathtt{HB}}}\ M_{\mathtt{S'}}$.

For example, consider two tasks where task 0 sends two messages to
task 1 as shown in \figref{fig:step4}.

\begin{figure}[h]
\[
\begin{array}{l|l}
\;\;\;\;\;\;\;\;\mathtt{Task\ 0}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{Task\ 1}\;\;\;\;\;\;\;\; \\
\hline
\;\;\;\;\;\;\;\;\mathtt{S_{0,1}(1,\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,1}(*,\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{S_{0,2}(1,\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{R_{1,2}(*,\&h4)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h1)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h3)}\;\;\;\;\;\;\;\; \\
\;\;\;\;\;\;\;\;\mathtt{W(\&h2)}\;\;\;\;\;\;\;\; & \;\;\;\;\;\;\;\; \mathtt{W(\&h4)}\;\;\;\;\;\;\;\; \\
\end{array}
\]
\caption{Send Ordering Example} \label{fig:step4}
\end{figure}

The $\mathit{M_\mathtt{S}}$ variables from the sends will be assigned to the orders
for $\mathtt{R_{1,1}}$ and $\mathtt{R_{1,2}}$ by the match pairs
selected by the SMT solver. The constraints added in this step force
the send to be received in program order using the \texttt{HB}
relation which for this example yields
$\cfgnt{M}_\mathtt{S_{0,1}}\ \mathrm{\prec_\mathtt{HB}}\ \cfgnt{M}_\mathtt{S_{0,2}}$.

\subsection{Zero Buffer Semantics}

The constraints presented so far correspond to an infinite-buffer
semantics, because we do not constrain how many messages may be in
transit at once. We can add additional, orthogonal, constraints to
further restrict behavior and enforce a zero-buffer semantics. There are
two kinds of such constraints.

First, for each task, if there are two sends $\mathtt{S}$ and
$\mathtt{S'}$ such that
$\mathit{order}_\mathtt{S}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{order}_\mathtt{S'}$,
and $\mathtt{S}$ and $\mathtt{S'}$ can both match a receive
$\mathtt{R}$, then we add the following constraint to the encoding:
$\mathit{order}_{\mathtt{W}}\ \mathrm{\prec_{\mathtt{HB}}}\ \mathit{order}_{\mathtt{S'}}$
where $\mathtt{W}$ is the nearest-enclosing wait that witnesses the
completion of $\mathtt{R}$ in execution.

The second constraint relies on a dependence relation between two match pairs.
\begin{definition}
To match pairs are dependent, denoted as $\langle\mathtt{R}, \mathtt{S}\rangle$ $\rightharpoonup$ $\langle\mathtt{R'}, \mathtt{S'}\rangle$, if and only if
\begin{compactenum}
\item the nearest-enclosing wait $\mathtt{W}$ of $\mathtt{R'}$ issues before $\mathtt{S}$ on an identical endpoint; or
\item $\exists\langle\mathtt{R''} \mathtt{S''}\rangle$ such that $\langle\mathtt{R}, \mathtt{S}\rangle \rightharpoonup \langle\mathtt{R''}, \mathtt{S''}\rangle\wedge\langle\mathtt{R''}, \mathtt{S''}\rangle \rightharpoonup \langle\mathtt{R'}, \mathtt{S'}\rangle$.
\end{compactenum}
\label{def:matchrelation}
\end{definition}
With the dependence relation, the second set of constraints for the zero-buffer semantics is give as: for each pair of sends $\mathtt{S}$ and $\mathtt{S'}$ that can both match an receive $\mathtt{R}$, if there is a send $\mathtt{S''}$ issued after the issuing of $\mathtt{S'}$ by an identical endpoint, and a receive $\mathtt{R'}$ such that $\langle\mathtt{R}, \mathtt{S}\rangle\rightharpoonup\langle\mathtt{R'}, \mathtt{S''}\rangle$, then we add the following constraint to the encoding: $\mathit{order}_{\mathtt{W}}\ \mathrm{\prec_{\mathtt{HB}}}\ \mathit{order}_{\mathtt{S}}$
where $\mathtt{W}$ is the nearest-enclosing wait that witnesses the
completion of $\mathtt{R}$.


\subsection{Example}

\begin{figure}[t]
\begin{center}
\usebox{\boxSMTc}
\end{center}
\caption{SMT Encoding} \label{fig:smt-encode}
\end{figure}

\figref{fig:smt-encode} shows the encoding of \figref{fig:mcapi} as an
SMT problem. We elide the basic definition of the variables discussed
in \secref{sec:smt-defns}. Lines \texttt{05} through \texttt{09} give
the assumptions, assertions, and match pairs. The first four lines
reflect the program order constraints: receives happen before
corresponding wait operations and receives from a common endpoint follow
program order. There are no constraints between sends because there are no sequential sends from a common endpoint to a common endpoint. To encode the zero-buffer semantics, the constraint
$\mathit{order}_\mathtt{W(\&h1)}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{order}_\mathtt{S_{1,5}}$
would need to be added to force the receive to complete before another
send is issued.

\subsection{Correctness}

Before we can state our correctness theorem, we must define a few
terms. We define our encoder as a function from programs and match pair sets
to SMT problems:

\begin{definition}[Encoder]
For all programs, $p$, and match pair sets $m$, let $\mathcal{SMT}(p,
m)$ be our encoding as an SMT problem.
\end{definition}

We assume that an SMT solver can be represented as a function that
takes a problem and returns a satisfying assignment of variables or an
unsatisfiable flag:

\begin{definition}[SMT Solver]
For all SMT problems, $s$, let $\mathcal{SOL}(s)$ be in $\sigma +
\mathbb{UNSAT}$, where $\sigma$ is a satisfying assignment of
variables to values.
\end{definition}

We assume that from a satisfying assignment to one of our SMT
problems, we can derive an execution trace by observing the values
given to each of the $\textit{order}_{e}$ variables. In other words,
we can view the SMT solver as returning traces and not assignments.

We assume a semantics for traces that gives their behavior as either
having an assertion violation or being correct: \footnote{In fact, our
  extended technical report~\cite{extended-version} gives such a
  semantics.}

\begin{definition}[Semantics]
For all programs, $p$, and traces $t$, $\mathcal{SEM}(p, t)$ is either
$\mathbb{BAD}$ or $\mathbb{OK}$.
\end{definition}

Given this framework, our SMT encoding technique is sound if

\begin{theorem}[Soundness]
For all programs, $p$, and match pair sets, $m$,
$\mathcal{SOL}(\mathcal{SMT}(p, m)) = t \Rightarrow \mathcal{SEM}(p, t) =
\mathbb{BAD}$.
\end{theorem}

Our soundness proof relies on the following lemma:

\begin{lemma} \label{lem:bogus}
Any match pair $\langle \mathtt{R}, \mathtt{S}\rangle$ used in a
satisfying assignment of an SMT encoding is a valid match pair and
reflects an actual possible MCAPI program execution.
\end{lemma}
\begin{proof}
We prove this by contradiction. First, assume that $\langle
\mathtt{R}, \mathtt{S}\rangle$ is an invalid match pair (i.e. one that
is not valid in an actual MCAPI execution). Second, assume that the
SMT solver finds a satisfying assignment.

Since $\langle \mathtt{R}, \mathtt{S}\rangle$ is not a valid match
pair, match $\mathtt{R}$ and $\mathtt{S}$ requires program order,
message non-overtaking, or no-multiple match to be violated. In other
words, the \emph{Happens-Before} constraints encoded in the SMT
problem are not satisfied.

This is a contradiction: either the SMT solver would not return an
assignment or the match pair was actually valid.
\end{proof}

The correctness of our technique relies on completeness:

\begin{theorem}[Completeness]
For all programs, $p$, and traces, $t$, $\mathcal{SEM}(p, t) =
\mathbb{BAD} \Rightarrow \exists m . \mathcal{SOL}(\mathcal{SMT}(p,
m)) = t$.
\end{theorem}

We prove completeness in our extended version~\cite{extended-version}
by designing our semantics, $\mathcal{SEM}$, such that it simulates
the solving of the SMT problem during its operation to ensure that the
two make identical conclusions.

However, these theorems obscure an important problem: how do we know
which match pair set to use? Soundness assumes we have one, while
completeness merely asserts that one exists. Although \secref{sec:mp-gen}
discusses our generation algorithm, we prove here an additional
theorem that asserts that any conservative over-approximation of match
pair sets is safe.

\begin{theorem}[Approximation]
Give two match pair sets $m$ and $m'$, $m \subseteq m' \Rightarrow \mathcal{SOL}(\mathcal{SMT}(p, m))
  \sqsubseteq \mathcal{SOL}(\mathcal{SMT}(p, m'))$, where
  $\mathbb{UNSAT} \sqsubseteq \sigma$.
\end{theorem}

Informally, this is true because larger match pair sets only allow
\emph{more} behavior, which means that the SMT solver has more freedom
to find violations, but that all prior violations are still
present. However, because of soundness, it is not possible that using
a larger match pair set will discover false violations. The formal
proof, in our extended version~\cite{extended-version}, relies on a
match set combination operator that we prove distributes over an
essential part of the semantics.
