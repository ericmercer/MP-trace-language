\newcommand{\epsnd}{\textit{S}}
\newcommand{\eprcv}{\textit{R}}
\newcommand{\snd}{\textit{snd}}
\newcommand{\rcv}{\textit{rcv}}
\newcommand{\frm}{\textit{frm}}
\newcommand{\status}{\textit{s}}
\newcommand{\error}{\ensuremath{\mathbf{error}}}
\newcommand{\aidmap}{\textit{A}}
\newcommand{\thread}{\ensuremath{\mathit{t}}}
\newcommand{\aid}{\ensuremath{\mathit{a}}}
\newcommand{\ploc}{\ensuremath{\rho}}
\newcommand{\loc}{\ensuremath{\mathit{l}}}
\newcommand{\cmd}{\ensuremath{\mathit{c}}}
\newcommand{\op}{\ensuremath{\mathit{op}}}
\newcommand{\applyop}{\ensuremath{\mathrm{op}}}
\newcommand{\wait}{\ensuremath{\mathbf{wait}}}
\newcommand{\sendi}{\ensuremath{\mathbf{sndi}}}
\newcommand{\recvi}{\ensuremath{\mathbf{rcvi}}}
\newcommand{\traceentry}{\ensuremath{\sigma}}
\newcommand{\assume}{\ensuremath{\mathit{assume}}}
\newcommand{\checkassume}{\ensuremath{\mathrm{assume}}}
\newcommand{\assert}{\ensuremath{\mathit{assert}}}
\newcommand{\checkassert}{\ensuremath{\mathrm{assert}}}
\newcommand{\ep}{\ensuremath{\mathbf{\gamma}}}
\newcommand{\src}{\ensuremath{\alpha}}
\newcommand{\dst}{\ensuremath{\beta}}
\newcommand{\true}{\ensuremath{\mathbf{true}}}
\newcommand{\false}{\ensuremath{\mathbf{false}}}
\newcommand{\match}{\ensuremath{\mathrm{m}}}
\newcommand{\matchl}{\ensuremath{\mathrm{match}}}
\newcommand{\smt}{\ensuremath{\mathrm{smt}}}


\newcommand{\addsend}{\ensuremath{\mathrm{addsend}}}
\newcommand{\getsend}{\ensuremath{\mathrm{getsend}}}
\newcommand{\removesend}{\ensuremath{\mathrm{removesend}}}
\newcommand{\addrecv}{\ensuremath{\mathrm{addrecv}}}
\newcommand{\getrecv}{\ensuremath{\mathrm{getrecv}}}
\newcommand{\removerecv}{\ensuremath{\mathrm{removerecv}}}
\newcommand{\hextend}{\ensuremath{\mathrm{hextend}}}
\newcommand{\hlookup}{\ensuremath{\mathrm{hlookup}}}
\newcommand{\etalookup}{\ensuremath{\mathrm{etalookup}}}
\newcommand{\checkmatch}{\ensuremath{\mathrm{checkmatch}}}


\newcommand{\reduce}[1]{\ensuremath{\rightarrow_{#1}}}
% Multiple reductions
\newcommand{\reduceK}[1]{\ensuremath{\rightarrow_{#1}^{*}}}
% Non-deterministic reductions
\newcommand{\reduceN}[1]{\ensuremath{\dashrightarrow_{#1}}}
\newcommand{\reduceNK}[1]{\ensuremath{\dashrightarrow_{#1}^{*}}}
\newcommand{\mt}{\ensuremath{\emptyset}}
\newcommand{\trace}{\ensuremath{\mathit{trace}}}
\newcommand{\ret}{\ensuremath{\mathbf{ret}}}

\newsavebox{\boxLangSyntax}
\newsavebox{\boxEvalSyntax}

\begin{lrbox}{\boxLangSyntax}
\begin{minipage}[c]{0.4\linewidth}
\cfgstart
%  (ctp (thread ...))
\cfgrule{ctp}{\lp\cfgnt{\thread}$~\ldots$\rp}
%  (thread ([ploc cmd] ...))
\cfgrule{\thread}{\lp\lb\cfgt{ploc}~\cfgnt{cmd}\rb~$\ldots$\rp}
%  (cmd (assume e)
%       (assert e)
%       (x := e)
%       (sendi aid src dst e ploc number)
%       (recvi aid dst x ploc)
%       (wait aid)
%       (wait aid aid)
%       )
\cfgrule{\cmd}{\lp\cfgt{assume}~\cfgnt{e}\rp}
   \cfgorline{\lp\cfgt{assert}~\cfgnt{e}\rp}
   \cfgorline{\lp\cfgt{x}~$:=$~\cfgnt{e}\rp}
   \cfgorline{\lp\cfgt{\sendi}~\cfgt{\aid}~\cfgnt{\src}~\cfgnt{\dst}~\cfgnt{e}\rp}
   \cfgorline{\lp\cfgt{\recvi}~\cfgt{\aid}~\cfgnt{\dst}~\cfgt{x}\rp}
   \cfgorline{\lp\cfgt{\wait}~\cfgt{\aid}\rp}
   \cfgorline{\lp\cfgt{\wait}~\cfgt{\aid}~\cfgt{\aid}\rp}
%  (trace (trace-entry ...))
\cfgrule{\trace}{\lp\cfgnt{\traceentry}~$\ldots$\rp}
% (trace-entry ploc
%               (ploc aid))
\cfgrule{\traceentry}{\cfgt{\ploc}\
   \cfgor\lp\cfgt{\ploc}~\cfgt{\aid}\rp}
%  (e (op e e)
%     cmd
%     x
%     v)
\cfgrule{e}{\lp\cfgt{op}~\cfgnt{e}~\cfgnt{e}\rp}
   \cfgorline{\cfgnt{\cmd}}
   \cfgorline{\cfgt{x}}
   \cfgorline{\cfgnt{v}}
%  (v number
%     bool)
\cfgrule{v}{\cfgt{number}}
   \cfgorline{\cfgnt{bool}}
%  (bool true
%        false)
\cfgrule{bool}{\cfgt{true}}
   \cfgorline{\cfgt{false}}
%  (src ep)
%  (dst ep)
\cfgrule{\src}{\cfgt{\ep}}
\cfgrule{\dst}{\cfgt{\ep}}
%% Omitted as not terribly important
%  (ploc id)
%  (ep number)
%  (aid id)
%  (x id)
%  (id variable-not-otherwise-mentioned)
%  (loc number)
\cfgend
\end{minipage}
\end{lrbox}

\begin{lrbox}{\boxEvalSyntax}
\begin{minipage}[c]{0.4\linewidth}
%% TODO: define all the functions separately from the syntax so snd, frm, S, rcv, R, h, \eta
%% are actual functions rather than their current definition in the syntax.  Will simplify life.
\cfgstart
% (machine-state (h eta aid-map ep-send-calls ep-recv-calls ctp trace status smt))
\cfgrule{mstate}{\lp\cfgnt{h}\ \cfgnt{\ensuremath{\eta}}\ \cfgnt{\aidmap}\  
  \cfgnt{\epsnd}\ \cfgnt{\eprcv}\ \cfgnt{ctp}\ \cfgnt{\trace} \cfgnt{\status} \cfgnt{k}\rp}
%  (expr-state (h eta aid-map ep-send-calls ep-recv-calls e status k smt))
\cfgrule{estate}{\lp\cfgnt{h}\ \cfgnt{\ensuremath{\eta}}\ \cfgnt{\aidmap}\  
  \cfgnt{\epsnd}\ \cfgnt{\eprcv}\ \cfgnt{e} \cfgnt{\status} \cfgnt{k}\rp}
%  (h mt
%     (h [loc -> v]))
\cfgrule{h}{\cfgt{\mt}\
   \cfgor\lp\cfgnt{h}~\lb\cfgt{\loc}~$\rightarrow$~\cfgnt{v}\rb\rp}
%  (eta mt
%       (eta [x -> loc]))
\cfgrule{\ensuremath{\eta}}{\cfgt{\mt}\
    \cfgor\lp\cfgnt{\ensuremath{\eta}}~\lb\cfgt{x}~$\rightarrow$~\cfgt{\loc}\rb\rp}
%  (aid-map ((aid ep) ... ))
\cfgrule{\aidmap}{\lp\lp\cfgt{\aid}~\cfgt{\ep}\rp~$\ldots$\rp}
%  (ep-send-calls mt
%                 (ep-send-calls [dst -> from-set]))
\cfgrule{\epsnd}{\cfgt{\mt}\ 
   \cfgor\lp\cfgnt{\epsnd}~\lb\cfgnt{\dst}~$\rightarrow$~\cfgnt{frm}\rb\rp}
%  (from-set mt
%            (from-set [src -> send-set])) 
\cfgrule{frm}{\cfgt{\mt}\ 
  \cfgor\lp\cfgnt{frm}~\lb\cfgnt{\src}~$\rightarrow$~\cfgnt{snd}\rb\rp}
%  (send-set mt
%            (send-set [aid -> v]))
\cfgrule{snd}{\lp\lb\cfgt{\aid}~\cfgt{v}\rb\ \ldots\rp}
%  (ep-recv-calls mt
%                 (ep-recv-calls [dst -> recv-set]))
\cfgrule{\eprcv}{\cfgt{\mt}\ 
   \cfgor\lp\cfgnt{\eprcv}~\lb\cfgnt{\dst}~$\rightarrow$~\cfgnt{rcv}\rb\rp}
%  (recv-set mt
%            (recv-set [aid -> x]))
\cfgrule{rcv}{\lp\lb\cfgt{\aid}~\cfgt{x}\rb\ \ldots\rp}
%  (status status-temp
%          status-final)
%  (status-temp success-temp ;everything's fine
%          failure-temp ;assertion failed
%          infeasable-temp ;assumption failed
%          error-temp) ;impossible to execute
%  (status-final success-final
%                failure-final
%                infeasable-final
%                error-final)
\cfgrule{\status}{\cfgt{success}}
   \cfgorline{\cfgt{failure}}
   \cfgorline{\cfgt{infeasible}}
   \cfgorline{\cfgt{\error}}
%  (machine-state (h eta aid-map ep-send-calls ep-recv-calls ctp trace status smt))
%  (expr-state (h eta aid-map ep-send-calls ep-recv-calls e status k smt))
%(k ret
%     (assert * -> k)
%     (assume * -> k)
%     (x := * -> k)
%     (op * e -> k)
%     (op v * -> k)
%     (match * [aid -> dst x] -> k)
%     (match [aid -> src dst v] [aid -> dst x] -> k)
%     )
\cfgrule{k}{\cfgt{ret}}
   \cfgorline{\lp\cfgt{assert}~\cfgt{*}~$\rightarrow$~\cfgnt{k}\rp}
   \cfgorline{\lp\cfgt{assume}~\cfgt{*}~$\rightarrow$~\cfgnt{k}\rp}
   \cfgorline{\lp\cfgt{x}~$:=$~\cfgt{*}~$\rightarrow$~\cfgnt{k}\rp}
   \cfgorline{\lp\cfgt{op}~\cfgt{*}~\cfgnt{e}~$\rightarrow$~\cfgnt{k}\rp}
   \cfgorline{\lp\cfgt{op}~\cfgt{v}~\cfgt{*}~$\rightarrow$~\cfgnt{k}\rp}
   \cfgorline{\lp\cfgt{\match}~\cfgt{*}~\lb\cfgt{\aid}~$\rightarrow$~\cfgnt{\dst}~\cfgt{x}\rb~
     $\rightarrow$~\cfgt{k}\rp}
%     (match [aid -> src dst v] [aid -> dst x] -> k)
%     )
%  (smt (defs asrts)
%       )
%  (defs (any ...))
%  (asrts (any ...))
\cfgend
\end{minipage}
\end{lrbox}

\begin{figure}
\begin{center}
\setlength{\tabcolsep}{15pt}
\begin{tabular}{cc}
\scalebox{0.7}{\usebox{\boxLangSyntax}}
&
\scalebox{0.7}{\usebox{\boxEvalSyntax}}
\\ \\
(a) & (b)
\end{tabular}
\end{center}
\caption{The trace language syntax with its evaluation syntax for the operational semantics--bold face indicates a terminal. (a) The input syntax with terminals \textbf{x}, \textbf{\ploc}, and \textbf{\aid} defined as strings and \textbf{\ep} as a number. (b) The evaluation syntax with terminal \textbf{\loc} defined as a number.}
\label{fig:expr:stx}
\end{figure}

\begin{figure}
\mprset{flushleft}
\scalebox{0.75}{
\begin{mathpar}
% (--> (h eta aid-map ep-send-calls ep-recv-calls  
%           (thread_0 ... 
%            ([ploc_0 (wait aid_r)] [ploc_1 cmd_1] [ploc_2 cmd_2] ...)
%            thread_2 ...)
%           ([ploc_0 aid_s] trace-entry_1 ...) status smt)
%        (h_pr eta_pr aid-map_pr ep-send-calls_pr ep-recv-calls_pr 
%              (thread_0 ... ([ploc_1 cmd_1] [ploc_2 cmd_2]...) thread_2 ...)
%              (trace-entry_1 ...) status_pr smt_prpr)
%        "Machine Step on Wait"
%        (where (h_pr eta_pr aid-map_pr ep-send-calls_pr ep-recv-calls_pr
%                     e status_pr ret smt_pr)
%               ,(apply-reduction-relation** expr-reductions
%                                            (term (h eta aid-map ep-send-calls
%                                                     ep-recv-calls (wait aid_r aid_s)
%                                                     status ret smt))))
%        (where smt_prpr (add-po smt_pr ploc_0 ploc_1)))
\inferrule[Machine Step on Wait]{
  (h~\eta~\aidmap~\epsnd~\eprcv~(\wait~\aid_r~\aid_s)~\status~\ret)~\reduceK{e}~
  (h_p~\eta_p~\aidmap_p~\epsnd_p~\eprcv_p~e~\status_p~\ret)
}{
  (h~\eta~\aidmap~\epsnd~\eprcv~
           (\thread_0~\ldots~
            ([\ploc_0~(\wait~\aid_r)]~[\ploc_1~\cmd_1]~[\ploc_2~\cmd_2]~\ldots)~\thread_2~\ldots)~
           ([\ploc_0~\aid_s]~\traceentry_1~\ldots)~\status) \reduce{m} \\\\
  (h_p~\eta_p~\aidmap_p~\epsnd_p~\eprcv_r~
              (\thread_0~\ldots~([\ploc_1~\cmd_1]~[\ploc_2~\cmd_2]~\dots)~\thread_2~\dots)~
              (\traceentry_1~\dots)~\status_p)
}
\and
%  (--> (h eta aid-map ep-send-calls ep-recv-calls  
%           (thread_0 ... ([ploc_0 cmd_0] [ploc_1 cmd_1] [ploc_2 cmd_2] ...) thread_2 ...)
%           (ploc_0 trace-entry_1 ...) status smt)
%        (h_pr eta_pr aid-map_pr ep-send-calls_pr ep-recv-calls_pr
%              (thread_0 ... ([ploc_1 cmd_1] [ploc_2 cmd_2] ...) thread_2 ...)
%              (trace-entry_1 ...) status_pr smt_prpr)
%        "Machine Step"
%        (where (h_pr eta_pr aid-map_pr ep-send-calls_pr ep-recv-calls_pr 
%                     e status_pr ret smt_pr)
%               ,(apply-reduction-relation** expr-reductions
%                                            (term (h eta aid-map ep-send-calls
%                                                     ep-recv-calls 
%                                                     cmd_0 status ret smt))))
%        (where smt_prpr (add-po smt_pr ploc_0 ploc_1)))
\inferrule[Machine Step]{
  (h~\eta~\aidmap~\epsnd~\eprcv~\cmd_0~\status~\ret)~\reduceK{e}~
  (h_p~\eta_p~\aidmap_p~\epsnd_p~\eprcv_p~e~\status_p~\ret)
}{
  (h~\eta~\aidmap~\epsnd~\eprcv~
           (\thread_0~\ldots~
            ([\ploc_0~\cmd_0)]~[\ploc_1~\cmd_1]~[\ploc_2~\cmd_2]~\ldots)~\thread_2~\ldots)~
           (\ploc_0~\traceentry_1~\ldots)~\status) \reduce{m} \\\\
  (h_p~\eta_p~\aidmap_p~\epsnd_p~\eprcv_r~
              (\thread_0~\ldots~([\ploc_1~\cmd_1]~[\ploc_2~\cmd_2]~\dots)~\thread_2~\dots)~
              (\traceentry_1~\dots)~\status_p)
}
\end{mathpar}}
\caption{Machine Reductions ($\reduce{m}$)}
\label{fig:machine}
\end{figure}


\begin{figure}
\scalebox{0.75}{%
\mprset{flushleft}
\begin{mathpar}
%(--> (h eta aid-map ep-send-calls ep-recv-calls  x status k smt)
%        (h eta aid-map ep-send-calls ep-recv-calls  v status k smt)
%        "Lookup Variable"
%        (where v (h-lookup h (eta-lookup eta x))))
\inferrule[Variable Lookup]{}{
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ x\ \status\ k)\ \reduce{e} \\\\
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ h(\eta(x))\ \status\ k )
}
\hspace*{60pt}
%   (--> (h eta aid-map ep-send-calls ep-recv-calls  (op e_0 e) status k smt)
%        (h eta aid-map ep-send-calls ep-recv-calls  e_0 status (op * e -> k) smt)
%        "Expr l-operand")
\inferrule[Left Operand]{}{
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ (\op\ e_0\ e)\ \status\ k) \reduce{e} \\\\
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ e_0\ \status\ (\op\ *\ e \rightarrow k))
}
\and
%   (--> (h eta aid-map  ep-send-calls ep-recv-calls  v status (op * e -> k) smt)
%        (h eta aid-map  ep-send-calls ep-recv-calls  e status (op v * -> k) smt)
%        "Expr r-operand")
\inferrule[Right Operand]{}{
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ v\ \status\ (\op\ *\ e \rightarrow k)) \reduce{e} \\\\
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ e\ \status\ (\op\ v\ *\ \rightarrow k))
}
\hspace*{20pt}
%   (--> (h eta aid-map ep-send-calls ep-recv-calls  v_r status (op v_l * -> k) smt)
%        (h eta aid-map ep-send-calls ep-recv-calls  v_res status k smt)
%        "Binary Operation Eval"
%        (where v_res (apply-op op v_l v_r)))
\inferrule[Binary Operation]{}{
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ v_r\ \status\ (\op\ v_l\ * \rightarrow k)) \reduce{e} \\\\
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ \applyop(v_l, v_r)\ \status\ k)
}
\and   
%   (--> (h eta aid-map ep-send-calls ep-recv-calls  (assume e) status k
%           (defs (any ...)))
%        (h eta aid-map ep-send-calls ep-recv-calls  e status (assume * -> k )
%           (defs (e any ...)))
%        "Assume Pull Out Expr")
\inferrule[Assume Expressions Evaluation]{}{
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ (\assume\ e)\ \status\ k) \reduce{e} \\\\
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ e\ \status\ (\assume\ * \rightarrow k))
}
\hspace*{22pt}
%   (--> (h eta aid-map ep-send-calls ep-recv-calls  v status (assume * -> k) smt)
%        (h eta aid-map ep-send-calls ep-recv-calls  v status_pr k smt)
%        "Assume Cmd"
%        (where status_pr (check-assume v status)))
\inferrule[Assume Command]{}{
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ v\ \status\ (\assume\ * \rightarrow k)) \reduce{e} \\\\
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ v\ \checkassume(v, s)\ k)
}
\and
%   ;;Negate expression and add it to the SMT assertions.
%   (--> (h eta aid-map ep-send-calls ep-recv-calls  (assert e) status k
%           (defs (any ...)))
%        (h eta aid-map ep-send-calls ep-recv-calls  e status (assert * -> k)
%           (defs ((not e) any ...)))
%        "Assert Pull Out Expr")
\inferrule[Assert Expressions Evaluation]{}{
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ (\assert\ e)\ \status\ k) \reduce{e} \\\\
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ e\ \status\ (\assert\ * \rightarrow k))
}
\hspace*{22pt}
%   (--> (h eta aid-map ep-send-calls ep-recv-calls  v status (assert * -> k) smt)
%        (h eta aid-map ep-send-calls ep-recv-calls  v status_pr k smt)
%        "Assert Eval"
%        (where status_pr (check-assert v status)))
\inferrule[Assert Command]{}{
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ v\ \status\ (\assert\ * \rightarrow k)) \reduce{e} \\\\
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ v\ \checkassert(v, s)\ k)
}
\and
%   (--> (h eta aid-map ep-send-calls ep-recv-calls  (x := e) status k
%           (defs (any ...)))
%        (h eta aid-map ep-send-calls ep-recv-calls  e status (x := * -> k)
%           (defs ((= x e) any ...)))
%        "Assign Pull Out Expr")
\inferrule[Assign Expressions Evaluation]{}{
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ (x\ :=\ e)\ \status\ k) \reduce{e} \\\\
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ e\ \status\ (x\ :=\ * \rightarrow k))
}
\hspace*{22pt}
%   (--> (h eta aid-map ep-send-calls ep-recv-calls  v status (x := * -> k) smt)
%        (h_pr eta aid-map ep-send-calls ep-recv-calls  v status k smt)
%        "Assign Expr"
%        (where h_pr (h-extend* h [(eta-lookup eta x) -> v])))
\inferrule[Assign Command]{}{
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ v\ \status\ (x\ :=\ *\ \rightarrow k)) \reduce{e} \\\\
  ([h \mid \eta(x) \mapsto v]\ \eta\ \aidmap\ \epsnd\ \eprcv\ v\ \status\ k)
}
\and
%   ;;Adds sendi cmd to aid-map and ep-send-calls. - VALIDATED
%   (--> (h eta ([aid_x ep_x] ...) ep-send-calls ep-recv-calls 
%           (sendi aid src dst x ploc number) status k ((any_d ...) (any_a ...)))
%        (h eta ([aid src] [aid_x ep_x] ...) ep-send-calls_pr ep-recv-calls 
%           true status k ((any_0 any_d ...) (any_1 any_a ...)))
%        "Sendi Cmd x -> v"
%        (where v (h-lookup h (eta-lookup eta x)))
%        (where any_0 (define aid :: send))
%        (where any_1 (make-send aid src dst x ploc number))
%        (where ep-send-calls_pr (add-send ep-send-calls [aid -> src dst v])))
\inferrule[Sndi Command]{
  ([\aid_1\ v_1]\ \ldots) = \epsnd(\dst)(\src) \\ \epsnd_p = [\epsnd \mid \dst \mapsto [\epsnd(\dst) \mid \src \mapsto ([\aid_0\ h(\eta(x))]\ [\aid_1\ v_1]\ \ldots)]]
}{
  (h\ \eta\ ([\aid\ \ep]\ \ldots)\ \epsnd\ \eprcv\ 
     (\sendi\ \aid_0\ \src\ \dst\ x)\ \status\ k) \reduce{e}
  (h\ \eta\ ([\aid_0\ \src]\ [\aid\ \ep]\ \ldots)\ \epsnd_p\ \eprcv\ \true\ \status\ k)
}
\and
%   ;;Adds recvi cmd to aid-map and ep-recv-calls. - VALIDATED
%   (--> (h eta ([aid_x ep_x] ...) ep-send-calls ep-recv-calls
%           (recvi aid dst x ploc) status k ((any_d ...) (any_a ...)))
%        (h eta ([aid dst] [aid_x ep_x] ...) ep-send-calls ep-recv-calls_pr 
%           true status k ((any_0 any_d ...) (any_1 any_a ...)))
%        "Recvi Cmd0"
%        (where ep-recv-calls_pr (add-recv ep-recv-calls [aid -> dst x]))
%        (where any_0 (define aid :: recv))
%        (where any_1 (make-recv aid dst x ploc)))
\inferrule[Rcvi Command]{
  ([\aid_1\ x_1]\ \ldots) = \eprcv(\dst) \\ 
   \eprcv_p = [\eprcv \mid \dst \mapsto ([\aid_0\ x_0]\ [\aid_1\ x_1]\ \ldots)]
}{
  (h\ \eta\ ([\aid\ \ep]\ \ldots)\ \epsnd\ \eprcv\ (\recvi\ \aid_0\ \dst\ x_0)\ \status\ k) \reduce{e}
  (h\ \eta\ ([\aid_0\ \dst]\ [\aid\ \ep]\ \ldots)\ \epsnd\ \eprcv_p\ \true\ \status\ k)
}
\and
%   ;;Eat the send wait. - VALIDATED
%   (--> (h eta aid-map ep-send-calls ep-recv-calls  (wait aid) status k smt)
%        (h eta aid-map ep-send-calls ep-recv-calls  true status k smt)
%        "Eat Sendi Wait")
\inferrule[Wait (sndi) Command]{}{
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ (\wait\ \aid)\ \status\ k) \reduce{e}
  (h\ \eta\ \aidmap\ \epsnd\ \eprcv\ true\ \status\ k)
}
\and
%   ;;Take the recv out of aid-map. - VALIDATED
%   (--> (h eta ([aid_x ep_x] ... [aid_r dst_0] [aid_y ep_y] ...) 
%           ep-send-calls ep-recv-calls 
%           (wait aid_r aid_s) status k 
%           ((any_d ...) (any_a ...)))
%        (h eta ([aid_x ep_x] ... [aid_y ep_y] ...)
%           ep-send-calls ep-recv-calls_pr
%           (wait aid_r aid_s) status (match * [aid_r0 -> dst_0 x_r] -> k) 
%           ((any_d ...) (any_a ...)))
%        "Recvi Wait Cmd 0"
%        (where (ep-recv-calls_pr [aid_r0 -> x_r]) (get-recv ep-recv-calls dst_0)))
% Note:
% We do need multiple rules to pull things out of the action list; though
% I will combine the last two rules into one rule.
\inferrule[Wait (rcvi)--get receive action]{
    ([\aid\ x]\ \ldots\ [\aid_0\ x_0]) = \eprcv(\dst) \\ \eprcv_p = [\eprcv \mid \dst \mapsto ([\aid\ x]\ \ldots)] 
}{
  (h\ \eta\ ([\aid_x\ \ep_x]\ \ldots\ [\aid_r\ \dst]\ [\aid_y\ \ep_y]\ \ldots)\ 
     \epsnd\ \eprcv\ (\wait\ \aid_r\ \aid_s)\ \status\ k) \reduce{e} \\\\
  (h\ \eta\ ([\aid_x\ \ep_x]\ \ldots\ [\aid_y\ \ep_y]\ \ldots)\ 
      \epsnd\ \eprcv_p\ (\wait\ \aid_r\ \aid_s)\ \status\ (\match\ *\ [\aid_0 \rightarrow \dst\ x_0] \rightarrow k))
}
\and
%   ;;Take the send out of aid-map VALIDATED
%   (--> (h eta ([aid_x ep_x] ... [aid_s src_0] [aid_y ep_y] ...)
%           ep-send-calls ep-recv-calls
%           (wait aid_r aid_s) status
%           (match * [aid_r -> dst_r x_r] -> k) smt)
%        (h eta ([aid_x ep_x] ... [aid_y ep_y] ...)
%           ep-send-calls_pr ep-recv-calls
%           (wait aid_r aid_s) status
%           (match [aid_s0 -> src_0 dst_r v_s] [aid_r -> dst_r x_r] -> k) smt)
%        "Recvi Wait Cmd 1"
%        (where (ep-send-calls_pr [aid_s0 -> v_s]) (get-send ep-send-calls src_0 dst_r)))
\inferrule[Wait (rcvi)]{
  ([\aid\ v]\ \ldots\ [\aid_1\ v_1]) = \epsnd(\dst)(\src) \\ 
  \epsnd_p = [\epsnd \mid \dst \mapsto [\epsnd(\dst) \mid \src \mapsto ([\aid\ v]\ \ldots)]] \\
  h_p = [h \mid \eta(x) \mapsto v_1] \\ 
  \status_p = \matchl(\aid_r, \aid_0, \aid_s, \aid_1, s)
}{
  (h\ \eta\ ([\aid_x\ \ep_x]\ \ldots\ [\aid_s\ \src]\ [\aid_y\ \ep_y]\ \ldots)\ 
     \epsnd\ \eprcv\ (\wait\ \aid_r\ \aid_s)\ \status\ 
     (\match\ *\ [\aid_0 \rightarrow \dst\ x] \rightarrow k)) \reduce{e} \\\\
  (h_p\ \eta\ ([\aid_x\ \ep_x]\ \ldots\ [\aid_y\ \ep_y]\ \ldots)\ 
     \epsnd_p\ \eprcv\ \true\ \status_p\ k)
}
\and
%   ;;Then we do the match
%   (--> (h eta aid-map ep-send-calls ep-recv-calls (wait aid_r aid_s) 
%           status (match [aid_s0 -> src dst v] [aid_r0 -> dst x] -> k)
%           (defs (any_a ...)))
%        (h_pr eta aid-map ep-send-calls ep-recv-calls true 
%              status_pr k 
%              (defs ((MATCH aid_r0 aid_s0) any_a ...)))
%        "Recvi Wait Cmd 2"
%        (where h_pr (h-extend* h [(eta-lookup eta x) -> v]))
%        (where status_pr ,(if (and (equal? (term aid_r) (term aid_r0)) 
%                                   (equal? (term aid_s) (term aid_s0))) 
%                              (term status) (term error))))
% Merged into the above rule (Wait (RCVI))
%}
\end{mathpar}}
\caption{Expression Reductions ($\reduce{e}$)}
\label{fig:expression}
\end{figure}

\begin{comment}
\begin{figure}
\begin{center}
\begin{lstlisting}
(((((mt [1 -> 0]) [2 -> 0]) [3 -> 0])[4 -> 4])
((((mt [A -> 1]) [B -> 2]) [C -> 3])[e -> 4])
()
mt
mt
(
(
[t0_0 (sendi send1 1 0 e t0_0 1)]
[t0_1 (wait send1)]
)
(
[t1_0 (recvi recvA 0 A t1_0)]
[t1_1 (wait recvA)]
[t1_2 (assert (= 4 A))]
)

)
(t0_0 t0_1 t1_0 [t1_1 send1] t1_2) 
success-temp
(()()))
))
\end{lstlisting}
\end{center}
\caption{A trace language program to send and receive a single message.}
\label{fig:prog}
\end{figure}
\end{comment}

\section{Trace Language}\label{sec:trace}
The trace language is the theoretical framework for the match-pair
encoding.  The language syntax describes a CTP with a single execution
trace on the same CTP.  The evaluation syntax with its operational
semantics define how to execute the CTP, following the specified
trace, and define when that execution is a success (causes no assertion
violation), a failure (causes an assertion violation), infeasible
(causes an assume to not hold), or an error (uses a bogus match pair).  \secref{sec:smt} defines the encoding of a trace language program as an
SMT problem and extends that encoding to capture a set of possible
traces using match-pairs.

\subsection{Syntax}
\figref{fig:expr:stx}(a) is the syntax for a trace language program.
This presentation uses ellipses ($\ldots$) to represent zero or more
repetitions, bold-face to indicate terminals, and omits commas in tuples for cleanliness. A trace language
program is a CTP with a trace defining a sequential run of the CTP.
The language defines a CTP (\textit{ctp}) as a list of threads.  A
thread (\thread) is a list of pairs with each pair being a program
location and a command.  For simplicity, commands (\textit{c}) are
restricted to assume, assert, assignment, non-blocking send (\snd) and
receive (\rcv), and wait.  The non-terminal \aid\ in the grammar is a
unique string identifier associated with a send or receive command
referred to as an action ID in the text.  The wait command takes a
single action ID belonging to the associated send or receive action.
The other wait command that takes two action IDs is reserved for the
operational semantics only.  The non-terminals $\src$ and $\dst$ are
source and destination endpoints respectively.  The non-terminal $\ep$
is a number.  The terminal \textbf{x} is any string not mentioned in
the grammar definition and represents a program variable.    Expressions (\textit{e}) are defined
using prefix notation over binary operators.  The bottom of
\figref{fig:mcapi} is an example \textit{ctp} in the trace language
(omitting the first and second columns and trivially grouping each
thread and its commands into an appropriate list using parenthesis).

A sequential trace of a CTP in the grammar is a list of trace entries
(\traceentry).  A trace entry is either a program location (\ploc) or
a pair consisting of a program location and an action ID.  An example
of a trace can be seen in the bottom of \figref{fig:mcapi} in the
second column by following the sequential order in the first column
which starts on line \texttt{00} of task 2.  Notice that whenever the
trace reaches a wait command on a receive action, the trace includes
the intended send with which to match in order to resolve any
non-determinism on message orders in the program trace.  In other
words, the trace resolves any non-determinism in scheduling or
message buffering that is present in the CTP.

\subsection{Operational Semantics}
The operational semantics for the trace language are given by a term
rewriting system using a \textit{CESK} style machine
\footnote{The \textit{CESK} machine state is represented with a \textbf{C}ontrol string,
  \textbf{E}nvironment, \textbf{S}tore, and \textbf{K}ontinuation.}
only the machine is augmented to include additional structure for
modeling message passing. \figref{fig:expr:stx}(b) defines the machine
state and other syntax relating to evaluation. 

A machine step ($\reduce{m}$) in \figref{fig:machine} moves a thread forward by a
single command.  The rules operate on a machine state tuple
(\textit{mstate}) defined in \figref{fig:expr:stx}(b).  The tuple
can be partitioned into members relating to the \textit{CESK}
machine, members relating to the message passing model, and the trace status.  The CESK machine members are
\textit{ctp} (the list of thread command sequences), $\eta$ (an environment mapping a variable $x$ to a location $l$),
$h$ (a store mapping a location $l$ to a value $v$), and $k$ (a continuation).
Members belonging to the message passing model are 
\aidmap\ (a dictionary mapping an action ID \aid\ to an endpoint \ep),
\epsnd\ (a store mapping any given destination endpoint \dst\ to another store which then maps any given source endpoint \src\ to a list of pairs where each pair is an action ID \aid\ and a value $v$), and
\eprcv\ (a store mapping any given destination endpoint \dst\ to a list of pairs where each pair is an action ID \aid\ and a variable $x$).  Intuitively, \epsnd\ and \eprcv\ are endpoint queues tracking actions with associated values (sends) or variables (receives).

The trace status in the \textit{mstate} nine-tuple is given by 
\status\ which ranges over a lattice: 
\[\cfgt{success} \prec \cfgt{failure} \prec \cfgt{infeasible} \prec \cfgt{\error}\]
The trace status only moves monotonically up the lattice starting from
success.  A success trace completes the entire trace, meets all the
assume statements, and does not fail an assertion.  A failure trace
completes the entire trace, meets all the assume statements, but fails
an assertion.  An infeasible trace completes the entire trace but does
not meet all the assume statements.  An error is an trace that does
not complete.

The machine reductions modify a given \textit{mstate} nine-tuple
depending on the next command in the trace.  For example, the
\emph{Machine Step on Wait} inference matches any \textit{mstate} with
a thread sitting at a wait command
\[
(\thread_0~\ldots~([\ploc_0~(\wait~\aid_r)]~[\ploc_1~\cmd_1]~[\ploc_2~\cmd_2]~\ldots)~\thread_2~\ldots))
\]
and having the next entry in the trace match on that threads location
$([\ploc_0~\aid_s]~\traceentry_1~\ldots)$.  A match on the inference
rewrites the \textit{mstate} with new entries for each member of the
nine-tuple by applying the expression reduction relation until no
more reductions apply (as indicated by the asterisk).  Note the use of
the reserved version of wait that takes two action ID parameters in
the expression to reduce.  At this point, send and receive actions are matched in the wait expression.  The inference for \textit{Machine Step} is
defined similarly to \emph{Machine Step on Wait}.

Expression reductions for each command in the trace language are given
in \figref{fig:expression} and are defined over the \textit{estate}
eight-tuple in the evaluation syntax of \figref{fig:expr:stx}(b) which
includes a continuation $k$.  The \cfgt{ret} continuation indicates
that nothing follows, and an asterisk in a continuation is a place
holder indication where evaluation is taking place.  For example, the
\emph{Assume Expressions Evaluation} creates a continuation indicating
that it is first evaluating the expression in the assume command.
Once that expression reduces to a value, then the \emph{Assume
  Command} inference matches to validate the assumptions.


The expression reductions use several helper functions.  The function \emph{op}$(v_l,v_r)$
applies the ``op'' to the left and right operands.  The other helper functions are defined below:
\begin{eqnarray*}
\checkassert(v,\status) &=& \left\{ \begin{array}{rl}
                                       \cfgt{failure} & \mathrm{if}~\status \prec \cfgt{failure}\ \wedge \\
                                                      & v = \false \\
                                             \status  & \mathrm{otherwise}
                                    \end{array} \right .\\
\checkassume(v,\status) &=& \left\{ \begin{array}{rl}
                                       \cfgt{infeasible} & \mathrm{if}~\status \prec \cfgt{infeasible}\ \wedge \\
                                                         & v = \false \\
                                                \status  & \mathrm{otherwise}
                                    \end{array} \right . \\
\matchl(\aid_{r}, \aid^\prime_{r}, \aid_s, \aid^\prime_s,s) &=&  \left\{ \begin{array}{rl}
                                                              \cfgt{\error} & \mathrm{if}~\status \prec \cfgt{\error}\ \wedge \\
                                                                            & (\aid_r \neq \aid^\prime_r \vee \aid_s \neq \aid^\prime_s)\\
                                       \status  & \mathrm{otherwise}
                                    \end{array} \right .\\
\end{eqnarray*}
Note that the status only moves monotonically up the lattice as
mentioned previously.  The notation $h(\eta(x))$, $\eprcv(\src)$, or
$\epsnd(\dst)(\src)$ is used for lookup. For example, $\epsnd(\dst)$
returns a store, so $\epsnd(\dst)(\src)$ returns a list of pairs of
action IDs and values as defined in \figref{fig:expr:stx}(b).

The \emph{Sndi Command} and \emph{Rcvi Command} in
\figref{fig:expression} update \eprcv\ and \epsnd\ respectively with
information to complete a message send or receive at a wait command.
Consider a portion of the \emph{Rcvi Command}:  
\begin{eqnarray*}
\eprcv_p &=& [\eprcv \mid \dst \mapsto
  ([\aid_0\ x_0]\ [\aid_1\ x_1]\ \ldots)]\\
([\aid_1\ x_1]\ \ldots) &=& \eprcv(\dst)
\end{eqnarray*}
$\eprcv_p$\ is a new store, just
like the old store $\eprcv$, only the new store maps the destination
end point $\dst$\ to its contents in the old store plus the added
entry to the front of the list of the action ID and variable for the
receive command being evaluated. Considering the entire rule in the figure, it also updates the
action ID map, \aidmap, to include the coupling between the action ID
and its destination endpoint.

The function of the \emph{Wait (Sndi) Command} rule in \figref{fig:expression} is to consume the wait command
only.  The function of other two rules for the wait command are more involved.
The \emph{Wait (Rcvi)--Get Receive Action} goes to $\eprcv$ to get the
next pending receive from the list of pending receive actions on the
specified end point $\dst$, and the rule then puts that action ID and
variable into the continuation $k$, and creates $\eprcv_p$ to reflect
the newly consumed receive action on the endpoint.  The \emph{Waiti
(rcvi)} inference performs the actual update of a delivered message by
modifying the heap $h$ and the pending send store $\epsnd$.  Both of
these rules use and update $\aidmap$ to find destination and
source endpoints from action IDs specified in the actual wait command.

The syntax with the operational semantics, as presented, are
implemented directly in PLT Redex.  PLT Redex is a language for
testing and debugging semantics using term rewriting and is part of the
Racket runtime.

The following definition is important to the proof of the match pair encoding in \secref{sec:smt}.
\begin{definition}
A machine state $(h\ \eta\ \aidmap\ \epsnd\ \eprcv\ \cfgnt{ctp}\ \trace\ \status\ k)$ is well formed if and only if it reduces to a final
state where the CTP and trace run to completion, having matched every send and receive call, and the status is either success,
failure, or infeasible: 
\[(h\ \eta\ \aidmap\ \epsnd\ \eprcv\ \cfgnt{ctp}\ \trace\ \status\ k) \reduceK{m} (h_p\ \eta_p\ \aidmap_p\ \epsnd_p\ \eprcv_p\ \cfgnt{ctp}_p\ \trace_p\ \status_p\ k_p)\]
such that
\[
\begin{array}{llll}
\aidmap_p = ()                    & \wedge & \forall \dst, \forall \src, \epsnd_p(\dst)(\src) = () & \wedge \\
\forall \dst, \eprcv_p(\dst) = () & \wedge & \cfgnt{ctp}_p\ = (()\ \ldots)                         & \wedge \\
\trace_p\  = ()                   & \wedge & \status_p\ \prec \cfgt{error}                         & \wedge \\
k_p = \cfgt{ret}                  &        &                                                       &
\end{array}
\]
For convenience, we define the function $\mathrm{status}(m)$ to return the final status after reduction of a well formed machine state $m$.
\end{definition}

